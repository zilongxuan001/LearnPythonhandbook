<?xml version="1.0" encoding="utf-8"?>
<opml version="2.0">
  <head>
    <title></title>
    <flavor>dynalist</flavor>
    <source>https://dynalist.io</source>
    <ownerName>zilongxuan001</ownerName>
    <ownerEmail>zilongxuan001@163.com</ownerEmail>
  </head>
  <body>
    <outline text="Learn  Python handbook">
      <outline text="证书考试" _note="&#10;[中国教育考试网](http://www.neea.edu.cn/) 可以考python二级&#10;&#10;"/>
      <outline text="目标需求" _note="&#10;学会数据分析，称为数据分析师&#10;&#10;1、 自动生成肉菜和农委运维周报&#10;&#10;2、 分析绿通业务数据。&#10;&#10;3、 分析市场对股市的报道，从而分析市场的情绪等。&#10;&#10;4、 根据股市股票实时变动价格，如果达到阈值，提醒买或卖。&#10;&#10;"/>
      <outline text="Materials" collapsed="true">
        <outline text="《Learn Python3 the hard way》"/>
        <outline text="南京大学公开课 《用Python 玩转数据》" _note="&#10;中国大学Mooc，网易公开课"/>
        <outline text="北京理工大学《Python 语言程序设计》" _note="中国大学Mooc"/>
        <outline text="北京理工大学《Python 数据分析和展示》" _note="&#10;中国大学Mooc"/>
        <outline text="北京理工大学《Python面向对象语法精讲》" _note="&#10;嵩天，BiliBili"/>
        <outline text=""/>
      </outline>
      <outline text="Tool list">
        <outline text="NOTPAD++ " _note="&#10;设置成黑色主题&#10;&#10;【设置】——【语言格式设置】——选择主题【Obsidian】——字体名称【Courier New】，在【使用全局字体】和【使用全局字体大小】打对号，字体大小，可以【12】-【14】"/>
        <outline text="安装numpy"/>
        <outline text="安装matplotlib"/>
        <outline text="安装Anaconda" _note="[Anaconda介绍、安装及使用教程 - 简书](https://www.jianshu.com/p/62f155eb6ac5)"/>
        <outline text="更新pip错误" _note="&#10;[You are using pip version 20.1.1； however, version 20.2.2 is available_小猴子的博客-CSDN博客](https://blog.csdn.net/xyajia/article/details/108067198)"/>
        <outline text="jupyter" _note="&#10;分析数据用软件，&#10;&#10;在cmd里输入 jutpyter notebook可以直接打开，点击new，可以新建python文件。&#10;&#10;alt+enter， 运行本单元，在其下插入新单元 新单元默认为edit模式"/>
      </outline>
      <outline text="小技巧 list" collapsed="true">
        <outline text="如何通过路径打开文件（转义符应用）" _note="&#10;&#10;1、必须有r&#10;&#10;f = open(r&apos;d:\ex\test.txt&apos;, &apos;r&apos;)&#10;&#10;&#10;2、必须有\\&#10;&#10;f = open(&apos;d:\\ex\\test.txt&apos;, &apos;r&apos;)&#10;&#10;&#10;"/>
        <outline text="如何使用非内建函数" _note="&#10;from math import *&#10;&#10;floor(-35.4)"/>
        <outline text="spyder快捷键" _note="&#10;如何在spyder中换行？ ctrl +Enter&#10;&#10;如何取消换行？ shift + Enter&#10;&#10;如何清空？ ctrl + L"/>
      </outline>
      <outline text="learn python3 the hard way" collapsed="true">
        <outline text="command line" collapsed="true">
          <outline text="命令行在windows里powershell中的常用操作">
            <outline text="cd 进入目录"/>
            <outline text="pwd 打印目录途径"/>
            <outline text="rmdir 删除目录"/>
            <outline text="mkdir 建立目录"/>
            <outline text="cp  复制目录或文件"/>
            <outline text="mv 移动目录或文件"/>
            <outline text="pushd 记住当前路径并进入一个新路径"/>
            <outline text="popd 返回最近一次的pushd的目录"/>
            <outline text="more 打开文件部分内容"/>
            <outline text="cat 一次性打开文件所有内容"/>
            <outline text="new-item FileName -type file 新建文件"/>
            <outline text="exit 离开powershell"/>
            <outline text="ls 列出所有目录和文件"/>
            <outline text="cd ~ 回到c盘根目录"/>
            <outline text="cd / 回到当前盘根目录"/>
            <outline text="cd ../ .. / 返回两层目录"/>
            <outline text="dir -r 列出当前文件、当前目录和当前目录下的所用文件和目录"/>
            <outline text="rm 删除文件"/>
          </outline>
        </outline>
        <outline text="exercise" collapsed="true">
          <outline text=" 1  练习 print"/>
          <outline text="2   注释 # 和 “  ‘"/>
          <outline text="3  数字和数字运算"/>
          <outline text="4  变量"/>
          <outline text="5  f&quot;&quot;"/>
          <outline text="6  variable.format()"/>
          <outline text="7 end&quot; &quot;"/>
          <outline text="8 formatter = {}{}{}{}" _note="     formattter.format( , ,  ,)"/>
          <outline text="9  &quot;&quot;&quot;   &apos;&apos;&apos;&quot;&quot;"/>
          <outline text="10 \\" collapsed="true">
            <outline text="\t"/>
            <outline text="\&quot;"/>
            <outline text="\&apos;"/>
            <outline text="\n"/>
            <outline text=""/>
          </outline>
          <outline text="11  input()"/>
          <outline text="12  input(&quot;How are you doing?&quot;)"/>
          <outline text="13  from sys import argv" _note="       script, first, second, third =argv"/>
          <outline text="14 input    f&quot;&quot;  argv"/>
          <outline text="15 打开文件，读取文件">
            <outline text="open() read()"/>
          </outline>
          <outline text="16 写文件 ">
            <outline text="r     r+    w    w+   seek()     read()     write(&quot; &quot;)    close()     truncate()"/>
          </outline>
          <outline text="17 拷贝文件      ">
            <outline text="from oa.path import exists           len()  exists()"/>
          </outline>
          <outline text="18  def "/>
          <outline text="19  def       f&quot; &quot;"/>
          <outline text="20  def   file"/>
          <outline text="21 return"/>
          <outline text="22  复习（前 22 章字符清单）">
            <outline text=""/>
          </outline>
        </outline>
        <outline text="代码编写方式">
          <outline text="正确编写软件的方式" _note="&#10;1. 在一张纸或索引卡上，写下你完成的这个软件所需要做所有任务。这就是你的代办事项列表。&#10;&#10;2. 先找到你列表中最容易的事情。&#10;&#10;3. 在你的源文件中写出注释，作为你完成这项任务的指南。&#10;&#10;4. 在这些注释下面，开始编码。&#10;&#10;5. 然后立即运行你的代码，看它是否正常工作。&#10;&#10;6. 循环的进行代码编写，测试运行，以及代码修正，直到代码正常运行。&#10;&#10;7. 在你的列表中划掉更完成的任务，然后再挑选下一个最容易完成的任务，重复进行以上的步骤。&#10;&#10;来自exercise 36。"/>
          <outline text="在class中使用的编写方式">
            <outline text="自顶向下方式" _note="&#10;&#10; 1. 写出或画出你的问题&#10; 2. 从1中提炼关键问题并搜索相关资料&#10; 3. 从2中的问题创建一个有层次结构的类和对象映射&#10; 4. 编写类和测试代码，并保证它们运行"/>
            <outline text="自下而上方式" _note="&#10;1. 取一小块问题，编写一些代码，并让它们勉强运行&#10;&#10;2. 完善代码，将其转化成一些更正式的包含类和自动化测试的代码。&#10;&#10;3. 提取其中的关键概念，并尝试找出研究它们。&#10;&#10;4. 写出到底发生了什么的描述。&#10;&#10;5. 继续完善代码，也可能是把它扔掉，并重新开始。&#10;&#10;6. 移动到其他问题上，重复步骤。"/>
          </outline>
        </outline>
        <outline text="Study drills" collapsed="true">
          <outline text="1.  从后往前检查。"/>
          <outline text="2. 大声读出来。"/>
          <outline text="3. 把出现的错误写下来。"/>
          <outline text="4. 有不懂的地方，先记下来，周期性的回顾一下，看能否弄明白。"/>
          <outline text="5. 先把代码逐行打出来，得出预想的结果。再想其中的概念和原理。"/>
          <outline text="6. 如何分解代码——把每个功能区块的功能用注释写在上面。"/>
          <outline text="7. 如果程序太大的话，可以把程序分为几段，每次运行一段程序。"/>
          <outline text="8.  在源代码的代码块上标出注释，把注释复制到空白文档中，根据注释把代码写出来。"/>
          <outline text="9. 如何复习" _note=" 来自《learn python3 the hard way》第22章" collapsed="true">
            <outline text="首先，回顾你目前做过的每一个练习，把你曾经用过的每一个词和符号(或者叫做字符)写下来。确保你的符号列表（或称为“清单”）完整无遗漏。"/>
            <outline text=""/>
            <outline text="然后，在每个词或者符号后面，写下他们的名字以及作用。如果你在本书中找不到一个符号的名字，你可以上网搜索一下；如果你不知道一个词或者符号的作用，找到用到该字符的练习章节,通读一遍，并在脚本中测试一下它的功能。"/>
            <outline text=""/>
            <outline text="你或许会遇到一些你怎么也找不到答案的东西，把他们记在列表里，等你下次遇到的时候，再查找他们。"/>
            <outline text=""/>
            <outline text="完成你的列表之后，再花几天时间重写一遍这个列表，并确认列表的内容都是正确的。你可能会觉得这件事情很无聊，但是一定要坚持完成。"/>
            <outline text=""/>
            <outline text="等你记住列表中的内容，尝试默写一遍，包括这些字符的名字和他们的作用，如果发现忘记一些了某些内容，就回去再记一遍。"/>
            <outline text=""/>
            <outline text="记住： 这个练习最重要的是，没有失败，只有尝试。"/>
            <outline text=""/>
            <outline text="每次练习可以花15分钟，然后休息一下。劳逸结合哦！"/>
            <outline text=""/>
          </outline>
        </outline>
        <outline text="常用数学函数" _note="import math">
          <outline text="数值型函数" collapsed="true">
            <outline text="abs(x)  " _note="&#10;绝对值函数"/>
            <outline text="type()" _note="&#10;类型函数"/>
            <outline text="round()" _note="&#10;四舍五入函数"/>
            <outline text="bool()"/>
            <outline text="oct()"/>
            <outline text="int()"/>
            <outline text="hex()"/>
            <outline text="divmond()"/>
            <outline text="ord()"/>
            <outline text="pow()"/>
            <outline text="float()"/>
            <outline text="chr()"/>
            <outline text="complex"/>
          </outline>
          <outline text="实用函数" collapsed="true">
            <outline text="dir()" _note="&#10;dir(__builtins__)  显示所有的内建函数"/>
            <outline text="input()"/>
            <outline text="help()" _note="&#10;help(zip) 显示zip()函数的功能"/>
            <outline text="open()"/>
            <outline text="len()"/>
            <outline text="range()"/>
          </outline>
        </outline>
        <outline text="Function checklist" collapsed="true">
          <outline text="1.  函数开始是不是用def开头？"/>
          <outline text="2. 函数名是不是只有字符和下划线？"/>
          <outline text="3. 函数名后是不是有 (  括号（open parenthesis）？"/>
          <outline text="4. 括号内是不是有参数，参数是不是用逗号分开？"/>
          <outline text="5.  每个参数名是不是唯一的（也就是没有重复的名字）？"/>
          <outline text="6. 参数后是不是有 ) 括号（close parenthesis）和冒号？"/>
          <outline text="7. 函数内的代码是否缩进四个空格？"/>
          <outline text="8. 函数结尾是否缩进？"/>
        </outline>
        <outline text="调用函数的检查清单" collapsed="true">
          <outline text="1. 调用函数时是否打出了函数的名字？"/>
          <outline text="2. 是否在函数后放了 (  括号?"/>
          <outline text="3. 放入括号里的值是否用逗号分开？"/>
          <outline text="4. 结束时是否有 ) 括号？ "/>
        </outline>
      </outline>
      <outline text="Python语言程序设计" _note="&#10;北京理工大学 ，嵩天，202009" collapsed="true">
        <outline text="Python安装" _note="&#10;可以通过官网或者https://python123.io/download下载&#10;&#10;"/>
        <outline text="安装VScode"/>
        <outline text="Python基础语法体系概览" collapsed="true">
          <outline text="基本数据类型">
            <outline text="整数、浮点数、复数"/>
            <outline text="字符串"/>
          </outline>
          <outline text="程序的控制结构">
            <outline text="分支结构和异常处理"/>
            <outline text="遍历循环、无限循环"/>
          </outline>
          <outline text="函数和代码复用">
            <outline text="函数定义和使用"/>
            <outline text="函数递归"/>
          </outline>
          <outline text="组合数据类型">
            <outline text="集合类型"/>
            <outline text="序列类型：元组和列表"/>
            <outline text="字典类型"/>
          </outline>
          <outline text="文件和数据格式化">
            <outline text="文件的使用"/>
            <outline text="一二维数据的表示存储和处理"/>
          </outline>
        </outline>
        <outline text="第1周：Python基本语法元素 #Python快速入门" _note="&#10;—缩进、注释、命名、变量、保留字&#10;&#10;— 数据类型、字符串、整数、浮点数、列表&#10;&#10;—赋值语句、分支语句、函数&#10;&#10;—input()、print()、eval()、print()格式化&#10;&#10;" collapsed="true">
          <outline text="1.1 程序设计基本方法" collapsed="true">
            <outline text="计算机与程序设计" collapsed="true">
              <outline text="计算机" _note="&#10;计算机是根据指令操作数据的设备" collapsed="true">
                <outline text="功能性" _note="&#10;对数据的操作，表现为数据计算、输入输出处理和结果存储等"/>
                <outline text="可编程性" _note="&#10;根据一系列指令自动地、可预测地、准确地完成操作者的意图。"/>
              </outline>
              <outline text="程序设计" _note="&#10;程序设计是计算机可编程性的体现&#10;&#10;程序设计亦称编程，深度应用计算机的主要手段。&#10;&#10;程序设计语言是一种用于交互（交流）的人造语言。&#10;&#10;C语言诞生于1972年，第一个被广泛应用的编程语言。&#10;&#10;Python语言诞生于1990年。"/>
            </outline>
            <outline text="编译和解释" collapsed="true">
              <outline text="编程语言的执行方式" _note="&#10;计算机执行源程序的两种方式：编译和解释" collapsed="true">
                <outline text="源代码：采用某种编程语言编写的计算机程序，人类可读"/>
                <outline text="目标代码：计算机可直接执行，人类不可读（专家除外）"/>
              </outline>
              <outline text="编译" _note="&#10;将源代码一次性转换成目标代码的过程&#10;&#10;源代码→编译器→目标代码&#10;&#10;程序输入→程序执行（目标代码）→结果输出&#10;&#10;执行编译过程的程序叫做编译器（compiler）"/>
              <outline text="解释" _note="&#10;将源代码逐条转换成目标代码同时逐条运行的过程&#10;&#10;源代码（程序输入）→解释器→结果输出&#10;&#10;执行解释过程的程序叫做解释器(interpreter)&#10;&#10;"/>
              <outline text="编译和解释" _note="&#10;编译：一次性翻译，之后不再需要源代码（类似英文翻译）&#10;&#10;解释：每次程序运行时随翻译随执行（类似实时的同声传译）"/>
              <outline text="静态语言和脚本语言" _note="&#10;根据执行方式不同，编程语言分为两类：&#10;&#10;- 静态语言：使用编译执行的编程语言，如C/C++语言，Java语言&#10;&#10;- 脚本语言：使用解释执行的编程语言，如Python语言、JavaScript语言、PHP语言&#10;&#10;&#10;执行方式不同，优势各有不同&#10;&#10;- 静态语言：编译器一次性生成目标代码，优化更充分。程序运行速度更快。&#10;&#10;- 脚本语言：执行程序时需要源代码，维护更灵活。源代码维护灵活，跨多个操作系统平台。"/>
            </outline>
            <outline text="程序的基本编写方法">
              <outline text="IPO" _note="&#10;程序的基本编写方法&#10;&#10;- I：Input 输入，程序的输入&#10;&#10;- P：Process 处理，程序的主要逻辑&#10;&#10;- O：Output 输出，程序的输出"/>
              <outline text="理解IPO" collapsed="true">
                <outline text="输入" _note="&#10;- 程序的输入， 比如 文件输入、网络输入、控制台输入、交互界面输入、内部参数输入等。&#10;&#10;- 输入是一个程序的开始。&#10;"/>
                <outline text="输出" _note="&#10;- 程序的输出，比如控制台输出、图形输出、文件输出、网络输出、操作系统内部变量输出等。&#10;&#10;- 输出是程序展示运算结果的方式。"/>
                <outline text="处理" _note="&#10;- 处理是程序对输入数据进行计算产生输出结果的过程&#10;&#10;- 处理方法统称为算法，它是程序最重要的部分&#10;&#10;- 算法是一个程序的灵魂"/>
              </outline>
              <outline text="问题的计算部分" _note="&#10;一个待解决问题中，可以用程序辅助完成的部分&#10;&#10;- 计算机只能解决计算问题，即问题的计算部分&#10;&#10;- 一个问题可能有多种角度理解，产生不同的计算部分&#10;&#10;- 问题的计算部分一般都有输入、处理和输出过程"/>
              <outline text="编程解决问题的步骤" _note="&#10;6个详细步骤&#10;&#10;&#10;1、分析问题： 分析问题的计算部分，想清楚&#10;&#10;2、划分边界：划分问题的功能边界，规划IPO&#10;&#10;3、 设计算法：设计问题的求解算法，关注算法&#10;&#10;4、编写程序： 编写问题的计算程序，编程序&#10;&#10;5、 调试测试： 调试程序使正确运行，运行测试&#10;&#10;6、升级维护：适应问题的升级维护，更新完善"/>
              <outline text="求解计算问题的精简步骤" _note="&#10;1、 确定IPO：明确计算部分及功能边界&#10;&#10;2、编写程序： 将计算求解的设计变成现实&#10;&#10;3、调试程序： 确保程序按照正确逻辑能够正确运行"/>
            </outline>
            <outline text="计算机编程" collapsed="true">
              <outline text="编程能够训练思维" _note="&#10;- 编程体现了一种抽象交互关系、自动化执行的思维模式&#10;&#10;- 计算思维：区分逻辑思维和实证思维的第三种思维模式&#10;&#10;- 能够促进人类思考，增进观察力和深化对交互关系的理解&#10;"/>
              <outline text="编程能够增进认识" _note="&#10;- 编程不单纯是求解计算问题&#10;&#10;- 不仅要思考解决方法，还要思考用户体验、执行效率等&#10;&#10;- 能够帮助程序员加深用户行为以及社会和文化认识"/>
              <outline text="编程能够带来乐趣" _note="&#10;- 编程能够体更展示自身思想和能力的舞台&#10;&#10;- 让世界增加新的颜色、让自己变得更酷、提升心理满足感&#10;&#10;- 在信息空间里思考创新、将创新变为现实"/>
              <outline text="编程能够提高效率" _note="&#10;- 能够更好地利用计算机解决问题&#10;&#10;- 显著提高工作、生活和学习效率&#10;&#10;- 为个人理想实现提高一种借助计算机的高效手段"/>
              <outline text="编程带来就业机会"/>
            </outline>
            <outline text="学习编程的方法" _note="&#10;- 首先，掌握编程语言的方法，熟悉掌握基本概念和逻辑&#10;&#10;- 其次，结合计算问题思考程序结构，会使用编程套路&#10;&#10;- 最后，参照案例多联系多实践，学会举一反三"/>
          </outline>
          <outline text="1.2 Python开发环境配置" collapsed="true">
            <outline text="Python语言概述" collapsed="true">
              <outline text="Python语言拥有者是Python Software Foundation（简称PSF）" _note="&#10;PSF是非盈利组织，致力于保护Python语言开放、开源和发展"/>
              <outline text="Python诞生" _note="&#10;Python创立者： Guido van Rossum&#10;&#10;2002年，Python2.x&#10;&#10;2008年，Python3.x"/>
            </outline>
            <outline text="Python基本开发环境IDLE" _note="&#10;Python官方提供，适用于小规模程序开发&#10;&#10;下载地址：&#10;&#10;python.org/downloads&#10;&#10;python123.io/downloads">
              <outline text="Python官方环境：Python解释器 + IDLE开发环境"/>
              <outline text="轻量级：只有几十MB大学，使用灵活"/>
              <outline text="功能丰富：编辑器+交互环境+标准库+库安装工具..."/>
            </outline>
            <outline text="Python程序编写与运行">
              <outline text="Python的两种编程方式" _note="&#10;交互式和文件式&#10;&#10;- 交互式：对每个输入语句及时运行结果，适合语法练习&#10;&#10;- 文件式：批量执行一组语句并运行结果，编程的主要方式"/>
            </outline>
            <outline text="Python高级开发环境VSCode" _note="&#10;VSCode：Visual Studio Code" collapsed="true">
              <outline text="特点" collapsed="true">
                <outline text="微软出品，与Visual Studio同质量的专业级开发工具"/>
                <outline text="跨平台免费工具：支持Windows/Linux/MacOS"/>
                <outline text="编辑器模式：轻量级、功能丰富、可扩展性强"/>
              </outline>
              <outline text="安装" _note="&#10;code/visualstudio.com"/>
            </outline>
          </outline>
          <outline text="1.3 实例：温度转换 #实例  " _note="&#10;学会对一个问题进行问题分析：问题定义（关键词的定义是什么）→需求分析（想做什么）→问题分析&#10;&#10;&#10;# TempConvert.py 温度转化器&#10;&#10;# 打印一个输入函数，输入&quot;请输入带有符号的温度值：&quot;。&#10;&#10;# 如果温度的倒数第一个字母是F或者f, 将其转化为摄氏温度。打印输出“转换后的温度是：”&#10;&#10;&#10;&#10;# 如果温度的倒数第一个字母是C或者c, 将其转化为华氏温度。打印输出“转换后的温度是：”&#10;&#10;# 如果两者皆不是，则输入“输入格式错误”&#10;" collapsed="true">
            <outline text="&quot;温度转换&quot;问题分析" _note="&#10;">
              <outline text="温度转换（理解定义）" _note="&#10;温度刻画的两种不同体系&#10;&#10;摄氏度 ： 以1标准大气压下水的结冰点为0度，沸点为100度，将温度进行等分刻画&#10;&#10;华氏度：以1标准大气压下水的结冰点为32度，沸点为212度，将维度进行等分刻画&#10;&#10;"/>
              <outline text="需求分析" _note="&#10;两种温度体系的转换&#10;&#10;- 摄氏度转换为华氏度&#10;&#10;- 华氏度转换为摄氏度"/>
              <outline text="问题分析" _note="&#10;该问题中计算部分的理解和确定&#10;&#10;- 理解1：直接将温度值进行转换&#10;&#10;- 理解2： 将温度信息发布的声音或图像形式进行理解和转换&#10;&#10;- 理解3：监控温度信息发布渠道，实时获取并转换温度值">
                <outline text="分析问题" _note="&#10;- 采用理解1：直接将温度值进行转换&#10;&#10; 温度数需要标明温度体系，即摄氏度或华氏度&#10;&#10; 转换后也要给出温度体系"/>
                <outline text="划分边界" _note="&#10;- 输入：带华氏或摄氏标志的温度值&#10;&#10;- 处理：根据温度标志选择适当的温度转换算法&#10;&#10;- 输出：带摄氏或华氏标志的温度值"/>
                <outline text="输入输出格式设计" _note="&#10;标识放在温度最后，F表示华氏度，C表示摄氏度&#10;&#10;82F表示华氏82度，28C表示摄氏28度"/>
                <outline text="设计算法" _note="&#10;根据华氏和摄氏温度定义，利用转换公式如下：&#10;&#10;C =  (F - 32)/1.8&#10;&#10;F = C*1.8 +32&#10;&#10;其中，C表示摄氏温度，F表示华氏温度"/>
              </outline>
            </outline>
            <outline text="实例编写" _note="&#10;#TempConvert.py&#10;&#10;TempStr = input(&quot;请输入带有符号的温度值：&quot;)&#10;&#10;if TempStr[-1] in [&apos;F&apos;, &apos;f&apos;]:&#10;    C = (eval(TempStr[0:-1]) - 32)/1.8&#10;    print(&quot;转换后的温度是{:.2f}C&quot;.format(C))&#10;&#10;elif TempStr[-1] in [&apos;C&apos;, &apos;c&apos;]:&#10;    F = 1.8* eval(TempStr[0:-1]) + 32&#10;    print(&quot;转换后的温度是{:.2f}F&quot;.format(F))&#10;&#10;else:&#10;    print(&quot;输入格式错误&quot;)"/>
            <outline text="举一反三">
              <outline text="输入输出的改变" _note="&#10;- 温度数值与温度标识之间关系的设计可以改变&#10;&#10;- 标识改变放在温度数值之前： C82，F28&#10;&#10;- 标识字符改变为多个字符：82Ce、28Fa"/>
              <outline text="计算问题的扩展" _note="&#10;- 温度转换问题是各类转换问题的代表性问题&#10;&#10;- 货币转换（人民币和美元）、长度转换（米与寸）、重量转换（千克和公斤）、面积转换（平方米和亩）...&#10;&#10;- 问题不同，但程序代码相似"/>
            </outline>
          </outline>
          <outline text="1.4 Python程序语法元素分析">
            <outline text="程序的格式框架" collapsed="true">
              <outline text="缩进" _note="&#10;缩进是一行代码开始前的空白区域，表达程序的格式框架&#10;&#10;- 严格明确：缩进是语法的一部分，缩进不正确程序会运行错误&#10;&#10;- 所属关系：表达代码间包含和层次关系的唯一手段&#10;&#10;- 长度一致：程序内一致认可，一般用4个空格或1个TAB"/>
              <outline text="注释" _note="&#10;不被程序执行的辅助性说明信息&#10;&#10;- 单行注释：以# 开头，其后内容为注释&#10;&#10;- 多行注释：以&apos;&apos;&apos; 开头和结尾&#10;&#10;举例&#10;&#10;’‘’  这是多行注释的第一行&#10;     这是多行注释的第二行&apos;&apos;&apos;"/>
            </outline>
            <outline text="命名和保留字" collapsed="true">
              <outline text="变量" _note="&#10;程序中用于保存和表示数据的占位符号&#10;&#10;- 变量采用标识符（名字）来表示，关联标识符的过程叫命名&#10;&#10;- 可以使用等号（=）向变量赋值或修改值，= 被称为赋值符号&#10;&#10;举例&#10;&#10;TempStr = &quot;82F&quot;&#10;&#10;# 向变量TempStr赋值“82F”，TempStr是变量名字&#10;"/>
              <outline text="命名" _note="&#10;命名：关联标识符的过程&#10;&#10;- 命名规则：大小写字母、数字、下划线和中文等字符及组合&#10;&#10; 如：TempStr, Python_Great，这是门Python好课&#10;&#10;- 注意事项：大小写敏感、首字符不能是数字、不与保留字相同&#10;&#10; 如：Python和python是不同变量、123Python是不合法的&#10;&#10;&#10;"/>
              <outline text="保留字" _note="&#10;保留字是被编程语言内部定义并保留使用的标识符&#10;&#10;- Python语言有35个保留字（也叫关键字）&#10;&#10;- 保留字是编程语言的基本单词，大小写敏感">
                <outline text="练习：默写35个保留字 #检索练习 " _note="&#10;and    as  assert   break   class  continue def&#10;&#10;elif     else  except  finally  for from if&#10;&#10;import in is lambda  nor or pass&#10;&#10;raise  return try  while with yield del&#10;&#10;global nonlocal  True False None async await&#10;&#10;"/>
              </outline>
            </outline>
            <outline text="数据类型" _note="&#10;&#10;数据类型是供计算机程序理解的程序形式&#10;&#10;- 程序设计语言不允许存在语法歧义，需要定义数据的形式&#10;&#10;- 程序设计语言通过一定方式向计算机表达数据的形式。&#10;" collapsed="true">
              <outline text="字符串" _note="&#10;字符串是由0个或多个字符组成的有序字符序列&#10;&#10;- 字符串由一对单引号或一对双引号表示，比如“中国”   ’中国‘&#10;&#10;- 字符串是是字符的有序序列，可以对其中的字符进行索引 比如&apos;中&apos;是’中华人民共和国‘的第0个字符&#10;">
                <outline text="字符串的序号" _note="&#10;- 正向递增序号，从0开始&#10;&#10;- 反向递减序号，从-1开始"/>
                <outline text="字符串的使用" _note="&#10;使用[]获取字符串中一个或多个字符&#10;&#10;- 索引：返回字符串中单个字符    &lt;字符串&gt;[M]&#10;&#10;- 切片：返回字符串中一段字符子串     &lt;字符串&gt;[M: N]"/>
              </outline>
              <outline text="整数" _note="&#10;数学中的整数  比如32   ，-32"/>
              <outline text="浮点数" _note="&#10;数学中的实数，带有小数部分，比如  1.8    -1.8">
                <outline text="浮点数如何保留两位小数 #检索练习 " _note="&#10;:.2f&#10;&#10;实例1&#10;&#10;print（&quot;{:.2f}&quot;.fromat(area)）&#10;&#10;实例2&#10;&#10; print(f&quot;{area:.2f}&quot;)&#10;&#10;"/>
              </outline>
              <outline text="列表" _note="&#10;由0或多个数据组成的有序序列&#10;&#10;- 列表使用[]表示，采用逗号（,）分隔各元素&#10;&#10;- 使用保留字in判断一个元素是否在列表中&#10;&#10;&#10;"/>
            </outline>
            <outline text="语句与函数" collapsed="true">
              <outline text="赋值语句" _note="&#10;由赋值符号构成的一行代码&#10;&#10;- 赋值语句用来给变量赋予新的数据值&#10;&#10;- 赋值语句右侧的数据类型同时作用于变量"/>
              <outline text="分支语句" _note="&#10;由判断条件决定程序运行方向的语句&#10;&#10;&#10;- 使用保留字if   elif   else构成条件判断的分支结构&#10;&#10;- 每个保留字所在行最后一个冒号(:)，语法的一部分&#10;&#10; 冒号即后续缩进用来表示后续语句与条件的所属关系"/>
              <outline text="函数" _note="&#10;根据输入参数产生不同输出的功能过程&#10;&#10;- 类似数学中的函数，y=f(x)&#10;&#10;- 函数采用&lt;函数名&gt;(&lt;参数&gt;)方式使用"/>
            </outline>
            <outline text="Python程序的输入输出" collapsed="true">
              <outline text="输入函数input()" _note="&#10;输入函数input()是从控制台获得用户的输入的函数&#10;&#10;- input()函数的使用格式：&#10; &#10; &lt;变量&gt; = input(&lt;提示信息字符串&gt;:)&#10;&#10;- 用户输入的信息以字符串类型保存在&lt;变量&gt;中。&#10;&#10; TempStr = input(&quot;请输入&quot;)&#10;&#10;&#10;"/>
              <outline text="输出函数print()" _note="&#10;输出函数print()是以字符形式向控制台输出结果的函数&#10;&#10;- print()函数的基本使用格式：&#10; print()&#10;&#10;- 字符串类型的一对引号仅在程序内部使用，输出无引号&#10;&#10; print(&quot;输入格式错误&quot;)&#10;&#10;- print()函数的格式化：&#10;&#10; print(&quot;转换后的温度是{:.2f}C&quot;.format(C))&#10;&#10;{}表示槽，后续变量填充到槽中。&#10;&#10;&#10;"/>
              <outline text="评估函数eval() " _note="&#10;去掉参数最外侧引号并执行余下语句的函数。&#10;&#10;- eval()函数的基本使用格式：&#10;&#10; eval(&lt;字符串或字符串变量&gt;)&#10;&#10;实例&#10;&#10;eval(&quot;1&quot;)&#10;&#10;eval(&quot;1+2&quot;)&#10;&#10;eval(&apos;&quot; 1 + 2&quot;&apos;)&#10;&#10;eval(&quot;print(&quot;Hello&quot;)&quot;)&#10;&#10;"/>
            </outline>
            <outline text="“温度转换”代码分析"/>
          </outline>
        </outline>
        <outline text="第2周：Python基本图形绘制 #Python快速入门 " _note="&#10;" collapsed="true">
          <outline text="2.1 深入理解Python语言" collapsed="true">
            <outline text="计算机技术的演进" collapsed="true">
              <outline text="1946 - 1981 计算机系统结构时代（35年）  解决计算能力问题"/>
              <outline text="1981 - 2008 网络和视窗时代（27年）          解决交互问题"/>
              <outline text="2008 - 2016 复杂信息系统时代（8年）       解决数据问题"/>
              <outline text="2016 - 人工智能时代                                            解决人类问题"/>
            </outline>
            <outline text="编程语言的多样初心" _note="&#10;编程语言                学习内容                                  语言本质                         解决问题          适用对象&#10;&#10;     C                指针、内存、数据类型       理解计算机系统结构               性能              计算机专业&#10;&#10;   Java            对象、跨平台、运行时        理解主客体关系                       跨平台           软件专业&#10;&#10;   C++            对象、多态、继承                 理解主客体关系                   大规模程序       计算机专业&#10;&#10;   VB               对象、按钮、文本框            理解交互逻辑                        桌面应用             不确定&#10;&#10;   Python        编程逻辑、第三方库           理解问题求解                        各类问题             所有专业&#10;&#10;"/>
            <outline text="Python语言的特点" _note="&#10;&gt; 15万第三方库&#10;&#10;快速增长的计算生态&#10;&#10;避免重复造轮子&#10;&#10;开放共享&#10;&#10;跨操作系统平台"/>
            <outline text="“超级语言的”的诞生">
              <outline text="编程语言的种类">
                <outline text="机器语言" _note="&#10;- 一种二进制语言，直接使用二进制代码表达指令&#10;&#10;- 计算机硬件（CPU）可以直接执行，与具体CPU型号有关&#10;&#10;- 完成2+3功能的机器语言"/>
                <outline text="汇编语言" _note="&#10;- 一种将二进制代码直接对应助记符的编程语言&#10;&#10;- 汇编语言与CPU型号有关，程序不通用，需要汇编器转换&#10;&#10;- 完成2+3功能的汇编语言"/>
                <outline text="高级语言" _note="&#10;&#10;- 更接近自然语言，同时更容易描述计算问题&#10;&#10;- 高级语言与具体CPU型号无关，编译后运行&#10;&#10;- 完成2+3功能的高级语言"/>
                <outline text="超级语言" _note="&#10;- 粘性整合已有程序，具备庞大计算生态，可以很容易利用已有代码功能&#10;&#10;- 编程思维不再是刀耕火种，而是集成开发&#10;&#10;- 完成2+3功能的超级语言"/>
              </outline>
            </outline>
          </outline>
          <outline text="2.2 实例2：Python蟒蛇绘制 #实例 " _note="&#10;" collapsed="true">
            <outline text="问题分析" _note="&#10;用程序绘制一条蟒蛇"/>
            <outline text="实例编写" _note="&#10;# PythonDraw.py&#10;&#10;import turtle&#10;&#10;turtle.setup(650, 350, 200, 200)&#10;turtle.penup()&#10;turtle.fd(-250)&#10;turtle.pendown()&#10;turtle.pensize(25)&#10;turtle.pencolor(&quot;purple&quot;)&#10;turtle.seth(&quot;-40&quot;)&#10;for i in range(4):&#10; turtle.circle(40, 80)&#10; turtle.circle(-40, 80)&#10;turtle.circle(40, 80/2)&#10;turtle.fd(40)&#10;turtle.circle(16, 180)&#10;turtle.fd(40 * 2 / 3)&#10;turtle.done&#10;"/>
            <outline text="举一反三">
              <outline text="Python语言元素理解" _note="&#10;参考框架结构、逐行分析、逐词理解"/>
              <outline text="程序参数的改变" _note="&#10;- Python蟒蛇的颜色：黑色、白色、七彩色&#10;&#10;- Python蟒蛇的长度：1节、3节、10节&#10;&#10;- Python蟒蛇的方向：向左走、斜着走"/>
              <outline text="计算问题的扩展" _note="&#10;- Python蟒蛇绘制问题是各类图像绘制问题的代表&#10;&#10;- 图形绘制、五角星绘制、国旗绘制、机器猫绘制...&#10;&#10;- 掌握绘制一条线的方法，就可以绘制整个世界"/>
            </outline>
          </outline>
          <outline text="2.3 模块1：turtle库的使用">
            <outline text="turtle库基本介绍" collapsed="true">
              <outline text="turtle库概述" _note="&#10;turtle(海龟)库是turtle绘图体系的Python实现&#10;&#10;-  turtle绘图体系：1969年诞生，主要用于程序设计入门&#10;&#10;- Python语言的标准库之一&#10;&#10;- 入门级的图形绘制函数库"/>
              <outline text="标准库" _note="&#10;Python计算生态 = 标准库 + 第三方库&#10;&#10;- 标准库：随解释器直接安装到操作系统中的功能模块&#10;&#10;- 第三方库： 需要经过安装才功能使用的功能模块&#10;&#10;- 库Library、包Package、模块Module，统称模块"/>
              <outline text="turtle的原理" _note="&#10;turtle(海龟)是一种真实的存在&#10;&#10;- 有一只海龟，其实在窗体正中心，在画布上游走&#10;&#10;- 走过的轨迹形成了绘制的图形&#10;&#10;- 海龟由程序控制，可以变换颜色、改变宽度等"/>
            </outline>
            <outline text="turtle绘图窗体布局" collapsed="true">
              <outline text="turtle的绘图窗体" _note="&#10;turtle的一个画布空间，最小单位是像素">
                <outline text="![turtle的绘图窗体](https://upload-images.jianshu.io/upload_images/64046-6f4efbd2c72a4028.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)"/>
                <outline text="turtle.setup(width, height, startx, starty)" _note="&#10;- setup() 设置窗体大小及位置&#10;&#10;- 4个参数中后两个可选&#10;&#10;- setup()不是必须的&#10;&#10;实例&#10;&#10;turtle.setup(800, 400, 0, 0)  # 窗体在左上方&#10;&#10;turtle.setup(800, 400)  # 窗体在正中间"/>
              </outline>
            </outline>
            <outline text="turtle空间坐标体系" collapsed="true">
              <outline text="绝对坐标" _note="&#10;正中间是(0, 0)，建立XY坐标系">
                <outline text="turtle.goto(x,y)" _note="&#10;&#10;turtle.goto(x, y)是turtle的空间坐体系，是以窗口的中心为（0，0）的绝对坐标体系&#10;&#10;&#10;实例&#10;&#10;import turtle&#10;turtle.goto(100, 100)&#10;turtle.goto(100, -100)&#10;turtle.goto(-100, -100)&#10;turtle.goto(-100, 100)&#10;turtle.goto(0, 0)"/>
              </outline>
              <outline text="相对坐标" _note="&#10;以海龟为视角">
                <outline text="turtle.fd(d)" _note="&#10;turtle.fd()是以海龟为中心和视角的相对空间坐标体系。&#10; &#10;d可以为负值。&#10;&#10;表示海龟前进（正值）/后退（负值）多少像素。"/>
                <outline text="turtle.bk(d)" _note="&#10;turtle.bk()是以海龟为中心和视角的相对空间坐标体系。&#10;&#10;表示海龟后退多少像素。"/>
                <outline text="turtle.circle(r, angle)" _note="&#10;turtle.circle(r, rangle)是以海龟为中心和视角的相对空间坐标体系。&#10;&#10;表示海龟转角半径和角度。&#10;"/>
              </outline>
            </outline>
            <outline text="turtle角度坐标体系" collapsed="true">
              <outline text="绝对角度">
                <outline text="turtle.seth(angle)" _note="&#10;turtle.seth(angle)是以视窗坐标系为标准，是绝对角度。&#10;&#10;seth() 改变海龟的方向，不改变前进多少路径，即不行进。&#10;&#10;angle是绝对角度。&#10;&#10;实例&#10;&#10;turtle.seth(45)&#10;&#10;turtle.seth(-135)&#10;"/>
              </outline>
              <outline text="相对角度" _note="&#10;以海龟为视角">
                <outline text="turtle.left(angle)" _note="&#10;turtle.left(angle)是以海龟为视角，是相对角度。&#10;&#10;left() 改变海龟的方向，不改变前进多少路径，即不行进。&#10;&#10;angle是相对角度。&#10;&#10;实例&#10;&#10;turtle.left(45)&#10;&#10;turtle.left(-135)"/>
                <outline text="turtle.right(angle)" _note="&#10;urtle.right(angle)是以海龟为视角，是相对角度。&#10;&#10;简写： turtle.rt()&#10;&#10;right() 改变海龟的方向，不改变前进多少路径，即不行进。&#10;&#10;angle是相对角度。&#10;&#10;实例&#10;&#10;import turtle&#10;&#10;turtle.left(45)&#10;turtle.fd(150)&#10;turtle.right(135)&#10;turtle.fd(300)&#10;turtle.left(135)&#10;turtle.fd(150)&#10;turtle.done()&#10;&#10;"/>
                <outline text="实例" _note="&#10;"/>
              </outline>
            </outline>
            <outline text="RGB色彩体系" collapsed="true">
              <outline text="RGB色彩模式" _note="&#10;由三种颜色构成的万物色&#10;&#10;- RGB指红绿蓝三个通道的颜色组合&#10;&#10;- 覆盖视力所能感知的所有颜色&#10;&#10;- RGB每色去值范围0-255整数或0-1小数"/>
              <outline text="常用RGB色彩" collapsed="true">
                <outline text="![RGB01](https://upload-images.jianshu.io/upload_images/64046-bae2d7e50c8f0314.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)"/>
                <outline text="![RGB02](https://upload-images.jianshu.io/upload_images/64046-a7c5727fdf2b484d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)"/>
              </outline>
              <outline text="turtle的RGB色彩模式" _note="&#10;默认采用小数值，可切换为整数值">
                <outline text="turtle.colormode(mode)" _note="&#10;- 1.0 ：RGB小数值模式&#10;&#10;- 255：RGB整数值模式"/>
                <outline text="turtle.color()" _note="&#10;颜色，可以直接写颜色种类，也可以用RGB的小数值、整数值或元组值&#10;&#10;实例 turtle.color(&quot;purple&quot;)&#10;&#10;使用RGB颜色时，先使用turtle.colormode(1)或turtle.colormode(255)说明采用RGB的颜色范围&#10;&#10;&gt;&gt;turtle.colormode(255)&#10;&gt;&gt;turtle.color(144, 255, 0)&#10;&#10;&gt;&gt;turtle.colormode(1)&#10;&gt;&gt;turtle.color(0.2, 0.8 ,0.485445245)&#10;&#10;&gt;&gt;turtle.color((0.63,0.13, 0.94))"/>
              </outline>
            </outline>
          </outline>
          <outline text="2.4 turtle程序语法元素分析 #重点 ">
            <outline text="库引用与import" collapsed="true">
              <outline text="库引用" _note="&#10;扩充Python程序功能的方式&#10;&#10;- 使用import保留字完成，采用&lt;a&gt;.&lt;b&gt;()编码风格&#10;&#10;&#10;import &lt;库名&gt;&#10;&#10;&lt;库名&gt;.&lt;函数名&gt;(&lt;函数参数&gt;)&#10;&#10;&#10;优点： 不会出现函数重名问题。&#10;&#10;缺点： 比较啰嗦。&#10;&#10;&#10;实例&#10;&#10;import turtle&#10;&#10;turtle.setup()"/>
              <outline text="import  + from" _note="&#10;使用 from 和 import 保留字共同完成&#10;&#10;from &lt;库名&gt; import &lt;函数名&gt;&#10;&#10;from &lt;库名&gt; import *&#10;&#10;&lt;函数名&gt;(&lt;函数参数&gt;)&#10;&#10;&#10;优点： 简洁&#10;&#10;缺点： 会出现函数重名问题，比如库里的函数和你的命名函数名称重复。&#10;&#10;&#10;实例 &#10;&#10;from turtle import *&#10;&#10;setup()"/>
              <outline text="import + as" _note="&#10;使用 import + as 保留字共同完成&#10;&#10;import &lt;库名&gt; as &lt;库别名&gt;&#10;&#10;&lt;库别名&gt;.&lt;函数名&gt;(&lt;函数参数&gt;)&#10;&#10;给调用的外部库关联一个更短、更适合自己的名字 &#10;&#10;优点： 简洁，又避免函数重名&#10;&#10;实例&#10;&#10;import turtle as t&#10;&#10;t.setup()&#10;"/>
            </outline>
            <outline text="turtle笔画控制函数" _note="&#10;画笔操作后一直有效，一般成对出现，直至下次重新设置" collapsed="true">
              <outline text="turtle.penup()" _note="&#10;别名 turtle.pu()&#10;&#10;含义：抬起画笔，海龟在飞行&#10;&#10;应用场景： 不想画出轨迹时使用，飞行时同样可以使用其他函数"/>
              <outline text="turtle.pendown()" _note="&#10;别名 turtle.pd()&#10;&#10;含义：落下画笔，海龟在爬行&#10;&#10;使用场景：和turtle.penup()同时使用，在该函数后海龟会画出轨迹&#10;"/>
              <outline text="turtle.pensize(width)" _note="&#10;别名 turtle.width(width)&#10;&#10;画笔宽度，海龟的腰围&#10;&#10;turtle.pensize(20)"/>
              <outline text="turtle.pencolor()" _note="&#10;画笔颜色，海龟在涂装，color可以有三种形式&#10;&#10;- 颜色字符串&#10;&#10;&gt;&gt; turtle.pencolor(&quot;red&quot;)&#10;&#10;- RGB的小数值或整数值&#10;&#10;使用RGB颜色时，先使用turtle.colormode(1)或turtle.colormode(255)说明采用RGB的颜色范围&#10;&#10;&gt;&gt;turtle.colormode(255)&#10;&gt;&gt;turtle.pencolor(144, 255, 0)&#10;&#10;&gt;&gt;turtle.colormode(1)&#10;&gt;&gt;turtle.pencolor(0.2, 0.8 ,0.485445245)&#10;&#10;- RGB的元组值&#10;&#10;In [7]: turtle.pencolor((0.63,0.13,0.94))&#10;&#10;&#10;&#10;"/>
            </outline>
            <outline text="turtle运动控制函数" _note="&#10;控制海龟行进：走直线&amp;走曲线" collapsed="true">
              <outline text="turtle.forward(d)" _note="&#10;别名turtle.fd(d)&#10;&#10;turtle.fd()是以海龟为中心和视角的相对空间坐标体系，向前前进，海龟走直线&#10; &#10;d可以为负值。&#10;&#10;表示海龟前进（正值）/后退（负值）多少像素。"/>
              <outline text="turtle.bk(d)" _note="&#10;turtle.bk()是以海龟为中心和视角的相对空间坐标体系。&#10;&#10;表示海龟后退多少像素。"/>
              <outline text="turtle.circle(r, extent=None)" _note="&#10;turtle.circle(r, rangle)是以海龟为中心和视角的相对空间坐标体系&#10;&#10;表示海龟转角半径和角度，根据半径r绘制extent角度的弧形&#10;&#10;- r ：默认圆心在海龟左侧r距离的位置（r正值在海龟左侧，r负值在海龟右侧）&#10;&#10;- extent： 绘制角度，默认是360度整圆，正值逆时针画圆，负值顺时针画圆&#10;&#10;适用场景：画圆或弧形时&#10;&#10;&#10;"/>
            </outline>
            <outline text="turtle方向控制函数" _note="&#10;控制海龟面对方向：绝对角度 &amp; 海龟角度" collapsed="true">
              <outline text="turtle.setheading(angle)" _note="&#10;别名turtle.seth(angle)&#10;&#10;是以视窗坐标系为标准，是绝对角度。&#10;&#10;seth() 改变海龟的方向，不改变前进多少路径，即不行进。&#10;&#10;angle是绝对角度。&#10;&#10;实例&#10;&#10;turtle.seth(45)&#10;&#10;turtle.seth(-135)&#10;"/>
              <outline text="turtle.left(angle)" _note="&#10;turtle.left(angle)是以海龟为视角，是相对角度，海龟向左转。&#10;&#10;left() 改变海龟的方向，不改变前进多少路径，即不行进。&#10;&#10;angle是相对角度，是海龟当前行进方向上旋转的角度。&#10;&#10;实例&#10;&#10;turtle.left(45)&#10;&#10;turtle.left(-135)"/>
              <outline text="turtle.right(angle)" _note="&#10;urtle.right(angle)是以海龟为视角，是相对角度，海龟向右转。&#10;&#10;简写： turtle.rt()&#10;&#10;right() 改变海龟的方向，不改变前进多少路径，即不行进。&#10;&#10;angle是相对角度，是海龟当前行进方向上旋转的角度。&#10;&#10;实例&#10;&#10;import turtle&#10;&#10;turtle.left(45)&#10;turtle.fd(150)&#10;turtle.right(135)&#10;turtle.fd(300)&#10;turtle.left(135)&#10;turtle.fd(150)&#10;turtle.done()&#10;&#10;">
                <outline text="实例" _note="&#10;"/>
              </outline>
            </outline>
            <outline text="turtle其他函数" collapsed="true">
              <outline text="turtle.title(titlestring)" _note="&#10;titlestring -- 一个字符串，显示为海龟绘图窗口的标题栏文本&#10;&#10;一般放在代码的最前面&#10;&#10;&gt;&gt;turtle.title(&apos;自动轨迹绘制&apos;)&#10;&#10;"/>
              <outline text="turtle.fillcolor()" _note="&#10;允许以下四种输入格式:&#10;&#10;fillcolor()返回以颜色描述字符串或元组 (见示例) 表示的当前填充颜色。可用作其他 color/pencolor/fillcolor 调用的输入。&#10;&#10;fillcolor(colorstring)设置填充颜色为 colorstring 指定的 Tk 颜色描述字符串，例如 &quot;red&quot;、&quot;yellow&quot; 或 &quot;#33cc8c&quot;。&#10;&#10;fillcolor((r, g, b))设置填充颜色为以 r, g, b 元组表示的 RGB 颜色。r, g, b 的取值范围应为 0..colormode，colormode 的值为 1.0 或 255。&#10;&#10;fillcolor(r, g, b)设置填充颜色为 r, g, b 表示的 RGB 颜色。r, g, b 的取值范围应为 0..colormode。&#10;&#10;如果 turtleshape 为多边形，该多边形内部也以新设置的填充颜色填充。"/>
              <outline text="turtle.done()" _note="&#10;海龟绘图结束，保留绘制窗口。"/>
              <outline text="turtle.begin_fill() " _note="&#10;开始填充"/>
              <outline text="turtle.end_fill()" _note="&#10;结束填充"/>
              <outline text="turtle.hideturtle()" _note="&#10;隐藏海龟箭头"/>
              <outline text="turtle.write()" _note="&#10;直接写字&#10;&#10;&gt;&gt; turtle.write(&apos;日&apos;, font=(&quot;Arial&quot;, 18, &quot;normal&quot;))"/>
              <outline text="turtle.speed()" _note="&#10;&#10;在python3.8中，speed()的值越大，速度越快，&#10;&#10;&gt;&gt;turtle.speed(1000)&#10;&#10;&#10;&#10;[turtle --- 海龟绘图 — Python 3.7.8 文档](https://docs.python.org/zh-cn/3.7/library/turtle.html)"/>
            </outline>
            <outline text="循环语句与range()函数" collapsed="true">
              <outline text="循环语句" _note="&#10;按照一定次数循环执行一组语句&#10;&#10;">
                <outline text="for &lt;变量&gt; in range &lt;次数&gt;:" _note="&#10;for &lt;变量&gt; in range &lt;次数&gt;:&#10; &#10; &lt;被循环执行的语句&gt;&#10;&#10;-&lt;变量&gt;表示每次循环的计数，0到&lt;次数&gt;-1&#10;&#10;&#10;实例&#10;&#10;In [1]: for i in range(5):&#10; ...: print(i)&#10; ...: &#10;0&#10;1&#10;2&#10;3&#10;4"/>
                <outline text="for &lt;变量&gt; in &lt;list&gt;:" _note="&#10;for &lt;变量&gt; in &lt;list&gt;:&#10; &#10; &lt;被循环执行的语句&gt;&#10;&#10;-&lt;变量&gt;表示循环取出list中的数字&#10;&#10; sum =0&#10;for i in [1,2,4,5]:&#10; sum += i&#10;print(sum)&#10;&#10;"/>
                <outline text="for  &lt;变量&gt; in &lt;str&gt;:" _note="&#10;&#10;for &lt;变量&gt; in &lt;str&gt;:&#10; &#10; &lt;被循环执行的语句&gt;&#10;&#10;-&lt;变量&gt;表示循环取出字符串中的字符&#10;&#10;str = &quot;&quot;&#10;count = 1&#10;for i in &quot;我是中国人&quot;:&#10;    str +=i&#10;print(str)"/>
              </outline>
              <outline text="range()函数" _note="&#10;产生循环计数序列&#10;&#10;- range(N)&#10;&#10; 产生0到N-1的整数序列，共N个&#10;&#10;- range(M, N)&#10;&#10; 产生M到N-1的整数序列，共N-M个"/>
            </outline>
            <outline text="&quot;Python蟒蛇绘制&quot;代码分析"/>
          </outline>
          <outline text="实例 ">
            <outline text="立体渐变色的心形  #实例 " _note="&#10;&#10;import turtle as t&#10;t.penup()&#10;t.seth(-90)&#10;t.fd(160)&#10;t.pendown()&#10;t.pensize(20)&#10;t.colormode(255)&#10;for j in range(10):&#10;    t.speed(1000)&#10;    t.pencolor(25*j,5*j,15*j)&#10;    t.seth(130)&#10;    t.fd(220)&#10;    for i in range(23):&#10;        t.circle(-80,10)&#10;    t.seth(100)&#10;    for i in range(23):&#10;        t.circle(-80,10)&#10;    t.fd(220)&#10;t.done()&#10;&#10;&#10;点评：这段代码中，使用&#10;&#10;for j in range(10):&#10;  t.pencolor(25*j,5*j,15*j)&#10;&#10;产出渐变色&#10;&#10;&#10;使用&#10;&#10;import turtle as t&#10;&#10;t.seth(130)&#10;t.fd(220)&#10;t.circle(-80,230)&#10;t.seth(100)&#10;t.circle(-80,230)&#10;t.fd(220)&#10;&#10;可以画心形&#10;&#10;画心形会产生偏移，海龟不会回到原位置，但画正方形就不行。&#10;"/>
          </outline>
        </outline>
        <outline text="第3周：基本数据类型 #基础语法" collapsed="true">
          <outline text="3.1 数字类型及操作" collapsed="true">
            <outline text="整数类型 " collapsed="true">
              <outline text="整数无限制  pow()" _note="&#10;整数与数学中整数的概念一致&#10;&#10;可正可负，没有取值范围限制&#10;&#10;pow(x,y) 函数：计算x的y次幂，想算多大算多大&#10;&#10;In [1]: pow(2,100)&#10;Out[1]: 1267650600228229401496703205376&#10;&#10;&#10;In [2]: pow(2, pow(2,15))&#10;Out[2]: 14154610310449547...&#10;&#10;"/>
              <outline text="4种进制表示形式" _note="&#10;&#10;十进制： 1010， 99， -217&#10;&#10;二进制， 以0b或0B开头： 0b010, -0B101&#10;&#10;八进制，以0o或0O开头：0o123, -0o456&#10;&#10;十六进制，以0x或0X开头：0x9a, -0X89"/>
            </outline>
            <outline text="浮点数类型" collapsed="true">
              <outline text="与数学中实数的概念一致" _note="&#10;- 带有小数点及小数的数字&#10;&#10;- 浮点数取值范围和小数精度都存在限制，但常规计算可忽略&#10;&#10;- 取值范围是数量级约-10的307次幂到10的308次幂，精度数量级为10的-16次幂&#10;&#10;"/>
              <outline text="浮点数间运算存在不确定尾数，不是bug" _note="&#10;In [5]: 0.1+0.3&#10;Out[5]: 0.4&#10;&#10;&#10;In [6]: 0.1+0.2&#10;Out[6]: 0.30000000000000004&#10;&#10;In [10]: 0.1+0.2 ==0.3&#10;Out[10]: False&#10;&#10;&#10;In [11]: round(0.1 +0.2, 1)==0.3&#10;Out[11]: True&#10;&#10;&#10;&#10;&#10;">
                <outline text="round(x,d)" _note="&#10;round(x,d)对x四舍五入， d是小数截取位数&#10;&#10;浮点数间运算与比较用round()函数辅助&#10;&#10;不确定尾数一般发生在10的-16次幂左右，round()十分有效"/>
              </outline>
              <outline text="浮点数可以采用科学计数法表示 " _note="&#10;以e或E作为幂的符号，以10为基数。&#10;&#10;&lt;a&gt;e&lt;b&gt;   表示a乘以10的b次幂&#10;&#10;实例&#10;&#10;4.3e-3  值为 0.0043&#10;&#10;In [13]: 9.6e5&#10;Out[13]: 960000.0"/>
            </outline>
            <outline text="复数类型 " _note="&#10;与数学中复数的概念一致&#10;&#10;a + bj 被称为复数， a是实部， b是虚部&#10;&#10;z = 1.23e-4 + 5.6e+89j&#10;&#10;z.real 获得实部&#10;&#10;z.imag 获得虚部&#10;&#10;&#10;In [14]: z=1.23e-4+5.6e+89j&#10;&#10;&#10;In [15]: z.real&#10;Out[15]: 0.000123&#10;&#10;&#10;In [16]: z.imag&#10;Out[16]: 5.6e+89"/>
            <outline text="数值运算操作符   " collapsed="true">
              <outline text="操作符 #重点 " _note="&#10;操作符是完成运算的一种符号体系">
                <outline text=" x + y"/>
                <outline text="x - y"/>
                <outline text="x * y"/>
                <outline text="x/y"/>
                <outline text="x//y" _note="&#10;整数除，x与y之整数商， 100//3的结果是33"/>
                <outline text="+x" _note="&#10;x本身"/>
                <outline text="-x" _note=" x的负值"/>
                <outline text="x%y" _note="&#10;余数，模运算 10%3的结果是1"/>
                <outline text="x** y " _note="&#10;幂运算，x的y次方， &#10;&#10;当y是小数时，开方运算 10**0.5是对10开平方"/>
                <outline text="x op = y" _note="&#10;增强操作符&#10;x = x op y，其中， op为二元操作符&#10;&#10;x + =y   x-=y    x* = y  x/=y&#10;&#10;x//= y   x% =y  x ** =y"/>
              </outline>
              <outline text="数据类型的关系" _note="&#10;类型间可以进行混合运算，生成结果为“最宽”类型&#10;&#10;三种类型存在一种逐渐“扩展”或“变宽”的关系：&#10;&#10;整数 -&gt; 浮点数 -&gt; 复数&#10;&#10;In [17]: 127.0 +4&#10;Out[17]: 131.0"/>
            </outline>
            <outline text="数值运算函数   #重点 " _note="&#10;以函数形式提供的数值运算功能" collapsed="true">
              <outline text="abs(x)" _note="&#10;求绝对值， x的绝对值&#10;&#10;e.g.&#10;&#10;abs(-10.01) &#10;&#10;"/>
              <outline text="divmod(x, y)" _note="&#10;求商余， （x//y, x%y）,同时输出商和余数&#10;&#10;e.g.&#10;&#10;divmod(10, 3) 结果为（3，1）"/>
              <outline text="pow(x, y [, z])" _note="&#10;幂余，（x**y）%z，[..]表示参数z可省略&#10;&#10;e.g.&#10;pow(3, pow(3, 99), 10000) 表示3的99次方后再作为幂，求3的该次方的最后4位。"/>
              <outline text="round(x [, d])" _note="&#10;四舍五入， d是保留小数位数，默认值为0&#10;&#10;e.g.&#10;&#10;round(-10.123, 2) 结果为-10.12"/>
              <outline text="max(x1 , x2, ...., xn)" _note="&#10;最大值， 返回x1 , x2, ...., xn中的最大值，n不限&#10;&#10;e.g.&#10;&#10;max(1, 9, 5, 4)    结果为 9"/>
              <outline text="min(x1 , x2, ...., xn)" _note="&#10;最小值， 返回x1 , x2, ...., xn中的最小值，n不限&#10;&#10;e.g.&#10;&#10;max(1, 9, 5, 4) 结果为 1"/>
              <outline text="int(x)" _note="&#10;将x变成整数，舍弃小数部分&#10;&#10;e.g.&#10;&#10;int(123.56) 结果为123&#10;&#10;int(‘123’) 结果为123"/>
              <outline text="float(x)" _note="&#10;将x变成浮点数，增加小数部分&#10;&#10;e.g.&#10;&#10;float(12)结果为 12.0&#10;&#10;float(&apos;1.23&apos;) 结果为1.23"/>
              <outline text="compelx(x)" _note="&#10;将x变成负数，增加虚数部分&#10;&#10;e.g.&#10;&#10;complex(4), 结果为4+ 0j"/>
            </outline>
          </outline>
          <outline text="3.2 实例3：天天向上 #实例 " _note="&#10;基本问题：持续的价值" collapsed="true">
            <outline text="问题1： 1‰的力量" _note="      &#10;一年365天，每天进步1‰，累计进步多少呢？一年365天，每天退步1‰，累计剩下多少呢？&#10;&#10;#DayDayUPQ1.py&#10;&#10;dayup = pow(1.001, 365)&#10;daydown = pow(0.999, 365)&#10;print(&quot;向上： {:.2f}, 向下： {:.2f}&quot;.format(dayup,daydown))&#10;&#10;向上： 1.44 ， 向下：0.69"/>
            <outline text="问题2：5‰和1%的力量" _note="&#10;一年365天，每天进步5‰或1%，累计进步多少呢？一年365天，每天退步5‰或1%，累计剩下多少呢？&#10;&#10;#DayDayUPQ2.py&#10;&#10;dayfactor = 0.005&#10;dayup = pow(1+ dayfactor, 365)&#10;daydown = pow(1- dayfactor, 365)&#10;print(&quot;向上： {:.2f}, 向下：{:.2f}&quot;.format(dayup, daydown))&#10;&#10;dayup2 = pow(1+ dayfactor*2, 365)&#10;daydown2 = pow(1- dayfactor*2, 365)&#10;print(&quot;向上： {:.2f}, 向下：{:.2f}&quot;.format(dayup2, daydown2))&#10;&#10;&#10;结果&#10;&#10;向上： 6.17 ， 向下：0.16&#10;向上： 37.78 ， 向下：0.03&#10;"/>
            <outline text="问题3： 工作日的力量" _note="&#10;一年365天，一周5个工作日，每天进步1%；一年365天，一周2个休息日，每天退步1%；这种工作日的力量如何呢？&#10;&#10;&#10;&#10;&#10;#DayDayUPQ3.py&#10;&#10;dayup = 1.0&#10;dayfactor = 0.01&#10;for i in range(365):&#10;    if i % 7 in [6,0]:&#10;        dayup=dayup*(1- dayfactor)&#10;    else:&#10;        dayup = dayup*(1+ dayfactor)&#10;print(&quot;工作日的力量：{:.2f}&quot;.format(dayup))&#10;&#10;&#10;结果&#10;&#10;工作日的力量：4.63"/>
            <outline text="问题4：  工作日的努力                                                                                                                   " _note="&#10;工作日模式要努力到什么水平，才能与每天努力1%一样？ A君： 一年365天，每天进步1%，不停歇 。B君： 一年365天，一周工作5天休息2天，休息日下降1%，要多努力呢？   &#10;&#10;&#10;#DayDayUPQ4.py&#10;&#10;def dayUP(df):&#10;    dayup = 1&#10;    for i in range(365):&#10;        if i % 7 in [6, 0]:&#10;            dayup = dayup*(1-0.01)&#10;        else:&#10;            dayup = dayup*(1+df)&#10;    return dayup&#10;dayfactor = 0.01   &#10;while dayUP(dayfactor) &lt; 37.78:&#10;    dayfactor += 0.001&#10;print(&quot;工作日的努力参数是：{:.3f}&quot;.format(dayfactor))&#10;&#10;&#10;结果&#10;&#10;工作日的努力参数是：0.019&#10;&#10;"/>
            <outline text="扩展问题" collapsed="true">
              <outline text="工作日模式中，如果休息日不下降呢？"/>
              <outline text="如果努力每天提高1%，休息时每天下降1‰？"/>
              <outline text="如果工作3天休息1天呢？"/>
              <outline text="“三天打鱼，两天晒网”呢？"/>
              <outline text="双休日不退步呢？"/>
              <outline text="多一份努力呢？（努力比下降多一点儿）"/>
              <outline text="多一点懈怠呢？（下降比努力多一点儿）"/>
            </outline>
          </outline>
          <outline text="3.3 字符串类型及操作" collapsed="true">
            <outline text="字符串类型的表示" collapsed="true">
              <outline text="字符串" _note="&#10;由0或多个字符组成的有序字符序列&#10;&#10;- 字符串由一对单引号或一对双引号表示&#10;&#10;- 字符串是字符的有序序列，可以对其中的字符进行索引&#10;&#10;"/>
              <outline text="字符串有2类4种表示方法" _note="&#10;- 由一对单引号或双引号表示，仅表示单行字符串&#10;&#10;-  由一对三单引号或三双引号表示，可表示多行字符串"/>
              <outline text="字符串的序号" _note="&#10;正向递增序号，从0开始&#10;&#10;反向递减序号，从-1开始"/>
              <outline text="字符串的使用" _note="&#10;使用[]获取字符串中一个或多个字符&#10;&#10;- 索引：返回字符串中单个字符    &lt;字符串&gt;[M]&#10;&#10;- 切片：返回字符串中一段字符子串     &lt;字符串&gt;[M:N]"/>
              <outline text="字符串切片高级用法 #检索练习 " _note="&#10;使用[M:N:K]根据步长对字符串切片" collapsed="true">
                <outline text="&lt;字符串&gt;[M: N]    " _note="&#10;M缺失表示至开头，N缺失表示至结尾&#10;&#10;e.g.&#10;&#10;&quot;〇一二三四五六七八九十&quot;[:3]   的结果是&apos;〇一二&apos;&#10;&#10;&quot;〇一二三四五六七八九十&quot;[3:]    的结果是 &apos;三四五六七八九十&apos;"/>
                <outline text="&lt;字符串&gt;[M: N: K]" _note="&#10;根据步长K对字符串切片&#10;&#10;e.g.&#10;&#10;&quot;〇一二三四五六七八九十&quot;[1:8:2]     结果是 &apos;一三五七&apos;&#10;&#10;&quot;〇一二三四五六七八九十&quot;[::-1]        结果是&apos;十九八七六五四三二一〇&apos;"/>
              </outline>
              <outline text="字符串的特殊字符——转义符 #检索练习 " _note="&#10;- 转义符表达特定字符的本意&#10;&#10;- 转义符形成一些组合，表达一些不可打印的含义&#10;" collapsed="true">
                <outline text="\b" _note="&#10;回退"/>
                <outline text="\n" _note="&#10;换行，光标移到下行首"/>
                <outline text="\r" _note="&#10;回车， 光标移到本行首"/>
              </outline>
            </outline>
            <outline text="字符串操作符 #检索练习  #重点 " collapsed="true">
              <outline text="x + y" _note="&#10;连接两个字符串&#10;&#10;&quot;apple&quot; + &quot; banana&quot;   结果  &apos;apple banana&apos;"/>
              <outline text="n *x 或 x *n" _note="&#10;复制n次字符串x&#10;&#10;&quot;apple &quot; * 4  结果是 &apos;apple apple apple apple &apos;"/>
              <outline text="x in s" _note="&#10;如果x是s的子串，返回True， 否则返回False&#10;&#10;&apos;a&apos; in &quot;apple&quot;  结果  True&#10;&#10;&quot;s&quot; in &quot;apple&quot;  结果 False"/>
              <outline text="字符串操作符实例 ">
                <outline text="获取星期字符串 #实例 " _note="问题： 获取星期字符串&#10;&#10;输入：1-7的整数，表示星期几&#10;&#10;输出： 输入整数对应的星期字符串&#10;&#10;例如： 输入3， 输出 星期三&#10;&#10;&#10;代码1&#10;&#10;# WeekNamePrintV1.py&#10;weekStr = &quot;星期一星期二星期三星期四星期五星期六星期七&quot;&#10;&#10;weekId = eval(input(&quot;请输入星期数字（1-7）：&quot;))&#10;&#10;pos = (weekId -1) *3&#10;&#10;print(weekStr[pos: pos+3])&#10;&#10;&#10;感悟：&#10;&#10;关键是序号和字符串之间的关系 pos = (wwkeId -1) *3&#10;&#10;&#10;代码2&#10;&#10;# WeekNamePrintV2.py&#10;&#10;weekStr = &quot;一二三四五六七&quot;&#10;weekId = eval(input(&quot;请输入星期数字（1-7）：&quot;))&#10;print(&quot;星期&quot; + weekStr[weekId-1])"/>
              </outline>
            </outline>
            <outline text="字符串处理函数 #检索练习 #重点 " _note="&#10;以函数形式提供的字符串处理功能">
              <outline text="len(x)" _note="&#10;长度，返回字符串x的长度&#10;&#10;e.g.&#10;&#10;len(&quot;一二三456&quot;)   结果 6"/>
              <outline text="str(x)" _note="&#10;任意类型x所对应的字符串形式&#10;&#10;str(1.23)   结果 &apos;1.23&apos;&#10;&#10;str([1, 2]) 结果  &apos;[1, 2]&apos;"/>
              <outline text="hex(x)" _note="&#10;整数x的十六进制小写形式字符串&#10;&#10;输入：整数&#10;&#10;输出：十六进制小写形式的字符串&#10;&#10;使用目的： 将整数转换为十六进制小写形式&#10;&#10;hen(425)  结果 “0x1a9”"/>
              <outline text="oct(x)" _note="&#10;&#10;整数x的八进制小写形式字符串&#10;&#10;输入：整数&#10;&#10;输出：八进制小写形式的字符串&#10;&#10;oct(425)结果是“0o651”"/>
              <outline text="chr(x)" _note="&#10;x为Unicode编码，返回其对应的字符&#10;&#10;chr(23)   结果是 &apos;\x17&apos;&#10;&#10;输入： Unicode编码&#10;&#10;输出：对应字符&#10;"/>
              <outline text="ord(x)" _note="&#10;x为字符，返回其对应的Unicode编码&#10;&#10;ord(&apos;\x17&apos;)  结果是 23&#10;&#10;输入：单个字符&#10;&#10;输出：Unicode编码"/>
            </outline>
            <outline text="字符串处理方法 #检索练习 ">
              <outline text="方法的定义" _note="&#10;“方法”在编程中是一个专有名词&#10;&#10;- “方法”特指&lt;a&gt;.&lt;b&gt;()风格中的函数&lt;b&gt;()&#10;&#10;- 方法本身也是函数，但与&lt;a&gt;有关，&lt;a&gt;.&lt;b&gt;()风格使用&#10;&#10;- 字符串或字符串变量是&lt;a&gt;，存在一些可用方法&#10;"/>
              <outline text="字符串处理方法 #重点 " _note="&#10;以方法形式提供的字符串处理功能">
                <outline text="str.lower() " _note="&#10;返回字符串的副本，全部字符小写&#10;&#10;输入：字符串&#10;&#10;输出：字母变小写，数字不变&#10;&#10;&#10;&#10;&gt;&gt; &quot;APPLE&quot;.lower()&#10;&apos;apple&apos;&#10;"/>
                <outline text="str.upper()" _note="&#10;返回字符串的副本，全部字符大写&#10;&#10;输入： 字符串&#10;&#10;输出：字母大写，数字不变&#10;&#10;&gt;&gt; &quot;apple&quot;.upper()&#10;&apos;APPLE&apos;"/>
                <outline text="str.split(sep=None)" _note="&#10;返回一个列表，有str根据sep被分割成的部分组成&#10;&#10;输入：字符串&#10;&#10;输出：列表&#10;&#10;方法：根据split()里的字符决定&#10;&#10;&gt;&gt; &quot;A,B,C&quot;.split(&apos;,&apos;)&#10; [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]&#10;&#10;&gt;&gt; &apos;a b c&apos;.split(&apos; &apos;)&#10;[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]&#10;&#10;&gt;&gt; &apos;15.23.46&apos;.split(&apos;.&apos;)&#10;[&apos;15&apos;, &apos;23&apos;, &apos;46&apos;]&#10;"/>
                <outline text="str.count(sub)" _note="&#10;返回子串sub在str中出现的次数&#10;&#10;输入：字符串和子串s&#10;&#10;输出：子串在字符串的出现次数，是数字&#10;&#10;&#10;&#10;&gt;&gt; &apos;an apple a day&apos;.count(&quot;a&quot;)&#10;4"/>
                <outline text="str.replace(old, new)" _note="&#10;返回字符串str副本， 所有old子串都被替换为new&#10;&#10;输入：字符串，旧字符串，新字符串&#10;&#10;输出：被新字符串替换的字符串&#10;&#10;&gt;&gt; &quot;python&quot;.replace(&quot;n&quot;,&quot;n123.io&quot;)&#10;&apos;python123.io&apos;&#10;&#10;&gt;&gt; &quot;上传数据53条&quot;.replace(&quot;53&quot;,&quot;48&quot;)&#10;&apos;上传数据48条&apos;"/>
                <outline text="str.center(width[, fillchar])" _note="&#10;字符串str根据宽度width居中，fillchar可选&#10;&#10;输入：字符串，宽度，要填充的字符&#10;&#10;输出：字符串居中，两边是要填充的字符。如果小于字符串长度，则只输出字符串。&#10;&#10;&gt;&gt; &quot;python&quot;.center(20,&quot;=&quot;)&#10;&apos;=======python=======&apos;&#10;&#10;注：没有str.left()  和str.right()"/>
                <outline text="str.strip(chars)  #难点" _note="&#10;从str中去掉在其左侧和右侧chars中列出的字符&#10;&#10;输入：字符串，要去掉的字符串&#10;&#10;输出：去掉在其左侧和右侧chars中列出字符的字符串&#10;&#10;注意：无论是正序还是逆序，chars必须在str是连续的，如果不连续，则无法去除。&#10;&#10;&gt;&gt; &quot;= python=&quot;.strip(&quot; =np&quot;)   # 去除np和=以及空格&#10;&apos;ytho&apos;&#10;&#10;&gt;&gt; &quot;= python=&quot;.strip(&quot;=n p&quot;)&#10;&apos;ytho&apos;&#10;&#10;&gt;&gt; &quot;= python=&quot;.strip(&quot;=np&quot;)  # 因为p左边有空格，p和=之间不连续，所以无法去除p&#10;&apos; pytho&apos;&#10;&#10;&gt;&gt; &quot;英雄不问出处&quot;.strip(&apos;问处&apos;)   # 因为“问”和“处”之间隔着“出”，所以无法去除“问”&#10;&apos;英雄不问出&apos;&#10;&#10;&gt;&gt;  &quot;英雄不问出处&quot;.strip(&apos;英雄处&apos;) &#10;&apos;不问出&apos;&#10;&#10;&gt;&gt; &quot;英雄不问出处&quot;.strip(&apos;雄英处&apos;)  # 即使“雄英”两字逆序，但是连续，所以可以去除&#10;&apos;不问出&apos;&#10;&#10;注： chars的字符可以无序"/>
                <outline text="str.join(iter) " _note="&#10;在iter变量除最后元素个数外每个元素后面增加一个str，主要用于字符串分隔等&#10;&#10;&gt;&gt; &quot;,&quot;.join(&quot;12345&quot;)&#10;&apos;1,2,3,4,5&apos;"/>
              </outline>
            </outline>
            <outline text="字符串类型的格式化 #检索练习 " collapsed="true">
              <outline text="格式化定义" _note="&#10;格式化是对字符串进行格式 表达的方式&#10;&#10;- 字符串格式化使用.format()方法，用法如下：&#10;&#10;&#10;&lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;)&#10;&#10;e.g.&#10;&#10;&gt;&gt;&quot;{}:计算机的{}的CPU占用率为{}%&quot;.format(&quot;2018-10-10&quot;,&quot;C&quot;,10)&#10;&apos;2018-10-10:计算机的C的CPU占用率为10%&apos;&#10;&#10;{}被称为槽&#10;"/>
              <outline text="format()方法的格式控制 #难点" collapsed="true">
                <outline text="{&lt;参数序号&gt;: &lt;格式控制标记&gt;}"/>
                <outline text="：" _note="&#10;引导冒号"/>
                <outline text="&lt;填充&gt;" _note="&#10;用于填充的单个字符"/>
                <outline text="&lt;对齐&gt;" _note="&#10;&lt; 左对齐&#10;&#10;&gt; 右对齐&#10;&#10;^ 居中对齐&#10;&#10;"/>
                <outline text="&lt;宽度&gt;" _note="&#10;槽设定的输出宽度&#10;&#10;&gt;&gt; &quot;{0:=^20}&quot;.format(&quot;PYTHON&quot;)&#10;&apos;=======PYTHON=======&apos;&#10;&#10;&gt;&gt;&quot;{0:=^9}&quot;.format(&quot;PYTHON&quot;)&#10;&apos;=PYTHON==&apos;&#10;&#10;&gt;&gt; &quot;{0:*&gt;20}&quot;.format(&quot;BIT&quot;)&#10;&apos;*****************BIT&apos;&#10;&#10;&gt;&gt;  &quot;{:10}&quot;.format(&quot;BIT&quot;)&#10;&apos;BIT       &apos;&#10;"/>
                <outline text="&lt;,&gt;" _note="&#10;数字的千位分隔符"/>
                <outline text="&lt;.精度&gt;" _note="&#10;浮点数小数精度或字符串最大输出长度"/>
                <outline text="&lt;类型&gt;" _note="&#10;整数类型b, c, d, o, x, X&#10;&#10;浮点数类型e,  E, f, %&#10;&#10;```&#10;&gt;&gt; &quot;{0:,.2f}&quot;.format(12345.6789)&#10;&apos;12,345.68&apos;&#10;&#10;&gt;&gt; &quot;{0:b},{0:c},{0:d},{0:o},{0:x},{0:X}&quot;.format(425)&#10;&apos;110101001,Ʃ,425,651,1a9,1A9&apos;&#10;&#10;&gt;&gt; &quot;{0:e},{0:E},{0:f},{0:%}&quot;.format(3.14)&#10;&apos;3.140000e+00,3.140000E+00,3.140000,314.000000%&apos;&#10;&#10;&#10;In [55]: a&#10;Out[55]: &apos;中华人民共和国万岁&apos;&#10;&#10;In [57]: b=&quot;肉菜追溯&quot;&#10;&#10;&#10;In [58]: b&#10;Out[58]: &apos;肉菜追溯&apos;&#10;&#10;&#10;In [59]: &quot;{1:*^12},{0:$&gt;12}&quot;.format(a,b)   # {}里的1和0说的是后面变量的顺序&#10;Out[59]: &apos;****肉菜追溯****,$$$中华人民共和国万岁&apos;&#10;&#10;```"/>
                <outline text="![format](https://upload-images.jianshu.io/upload_images/64046-bd841cf01b2db9b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)"/>
              </outline>
              <outline text="实例：超出宽度的字符串" _note="&#10;s=&apos;PYTHON&apos;&#10;print(&quot;0:3&quot;.format(s))&#10;&#10;执行结果是什么&#10;&#10;" collapsed="true">
                <outline text="答案" _note="&#10;PYTHON&#10;&#10;{0:3}表示输出的宽度是3，但如果字符串超过长度3，则以字符串长度显示。"/>
              </outline>
              <outline text="实例：带+的平方根">
                <outline text="描述：" _note="&#10;&#10;&#10;获得用户输入的一个整数a，计算a的平方根，保留小数点后3位，并打印输出。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬&#10;&#10;输出结果采用宽度30个字符、右对齐输出、多余字符采用加号(+)填充。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬&#10;&#10;如果结果超过30个字符，则以结果宽度为准。&#10;&#10;输入输出示例&#10;&#10; 输入10&#10;&#10;输出+++++++++++++++++++++++++3.162"/>
                <outline text="答案" _note="&#10;a = eval(input())&#10;&#10;print(&quot;{:+&gt;30.3f}&quot;.format(pow(a, 0.5)))"/>
              </outline>
              <outline text="实例：星号三角形" collapsed="true">
                <outline text="描述" _note="&#10;问题：&#10;&#10;读入一个整数N，N是奇数，输出由星号字符组成的等边三角形，要求：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬&#10;第1行1个星号，第2行3个星号，第3行5个星号，依次类推，最后一行共N的星号。"/>
                <outline text="答案" _note="‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬&#10;&#10;代码：&#10;&#10;n = eval(input())&#10;for i in range(1,n+1,2):&#10;  print(&quot;{0:^{1}}&quot;.format(&apos;*&apos;*i, n))&#10;&#10;评价：&#10;&#10;关键是对槽的理解， print(&quot;{0:^{1}}&quot;.format(&apos;*&apos;*i, n)) 中的0是参数序号，代指&apos;*&apos;*i；1也是参数序号，代指 n。&#10;&#10;该行代码含义是n个字符中，&apos;*&apos;*i居于中间位置。"/>
              </outline>
              <outline text="实例：[凯撒密码](https://python123.io/student/courses/3382/groups/39666/problems/programmings/6921)">
                <outline text="描述" _note="&#10;恺撒密码是古罗马恺撒大帝用来对军事情报进行加解密的算法，它采用了替换方法对信息中的每一个英文字符循环替换为字母表序列中该字符后面的第三个字符，即，字母表的对应关系如下：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬&#10;&#10;原文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬&#10;密文：D E F G H I J K L M N O P Q R S T U V W X Y Z A B C‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬&#10;&#10;对于原文字符P，其密文字符C满足如下条件：C=(P+3) mod 26‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬&#10;上述是凯撒密码的加密方法，解密方法反之，即：P=(C-3) mod 26‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬&#10;假设用户可能使用的输入包含大小写字母a~zA~Z、空格和特殊符号，请编写一个程序，对输入字符串进行恺撒密码加密，直接输出结果，其中空格不用进行加密处理。使用input()获得输入。&#10;&#10;输入&#10;&#10;python is good&#10;&#10;输出&#10;&#10;sbwkrq lv jrrg&#10;"/>
                <outline text="答案" _note="&#10;s = input()&#10;t = &quot;&quot;&#10;for c in s:&#10; if &apos;a&apos; &lt;= c &lt;= &apos;z&apos;:&#10;   t += chr( ord(&apos;a&apos;) + ((ord(c)-ord(&apos;a&apos;)) + 3 )%26 ) &#10; elif &apos;A&apos; &lt;= c &lt;= &apos;Z&apos;:&#10;  t += chr( ord(&apos;A&apos;) + ((ord(c)-ord(&apos;A&apos;)) + 3 )%26 ) &#10; else: &#10;  t += c &#10;print(t)"/>
              </outline>
            </outline>
            <outline text="补充知识" collapsed="true">
              <outline text="Unicode" _note="&#10;Unicode通过chr(u)转换为单字符；单字符通过ord(x)转换为Unicode&#10;&#10;In [20]: ord(&quot;1&quot;)&#10;Out[20]: 49&#10;&#10;&#10;In [21]: ord(&quot;2&quot;)&#10;Out[21]: 50&#10;&#10;&#10;In [22]: chr(51)&#10;Out[22]: &apos;3&apos;&#10;&#10;&#10;">
                <outline text="Unicode定义" _note="&#10;- 统一字符编码，即覆盖几乎所有字符的编码形式&#10;&#10;- 从0到1114111（0x10FFFF）空间，每个编码对应一个字符&#10;&#10;- Python字符串中每个字符都是Unicode编码字符&#10;"/>
                <outline text="Unicode编码举例" _note="&#10;&#10;&#10;&#10;&gt;&gt; &quot;1+1 =2 &quot; + chr(10004)&#10;&apos;1+1 =2 ✔&apos;&#10;&#10;&gt;&gt; &quot;这个字符♉的Unicode值是：&quot; + str(ord(&quot;♉&quot;))&#10;&apos;这个字符♉的Unicode值是：9801&apos;&#10;&#10;# 十二星座的表示方式&#10;&gt;&gt; for i in range(12):&#10;      print(chr(9800 +i), end=&quot;&quot;)&#10;&#10;♈♉♊♋♌♍♎♏♐♑♒♓"/>
              </outline>
              <outline text="CZ思考">
                <outline text="实例1" _note="&#10;# 如果正向和反向的是同一个字符，则出现空字符&#10;&#10;In [1]: a=&quot;中国人&quot;&#10;&#10;&#10;In [2]: a[1:-2]&#10;Out[2]: &apos;&apos;&#10;&#10;"/>
              </outline>
            </outline>
          </outline>
          <outline text="3.4 time库 #模块">
            <outline text="time库基本介绍" _note="&#10;time库是Python中处理时间的标准库。&#10;&#10;- 计算机时间的表达&#10;&#10;- 提取获取系统时间并格式化输出功能&#10;&#10;- 提供系统级精确及时功能，用于程序性能分析&#10;&#10;&#10;import time&#10;&#10;time.&lt;b&gt;()&#10;"/>
            <outline text="time库函数 #检索练习  #重点 ">
              <outline text="时间获取 #检索练习 " _note="&#10;time.time() &#10;&#10;time.ctime()&#10;&#10;gmtime()">
                <outline text="time.time()" _note="&#10;获取当前时间戳， 即计算机内部时间值，浮点数&#10;&#10;&gt;&gt; time.time()&#10;1600161291.0276325&#10;"/>
                <outline text="time.ctime()" _note="&#10;获取当前时间并以易读方式表示，返回字符串&#10;&#10;&gt;&gt; time.ctime()&#10;&apos;Tue Sep 15 17:16:32 2020&apos;"/>
                <outline text="time.gmtime()" _note="&#10;获取当前时间， 表示为计算机可处理的时间格式&#10;&#10;&gt;&gt; time.gmtime()&#10;time.struct_time(tm_year=2020, tm_mon=9, tm_mday=15, tm_hour=9, tm_min=18, tm_sec=44, tm_wday=1, tm_yday=259, tm_isdst=0)"/>
              </outline>
              <outline text="时间格式化 #检索练习 " _note="&#10;格式化：类似字符串格式化，需要有展示模板&#10;&#10;展示模板有特定的格式化控制符表示&#10;&#10;&#10;time.strftime()&#10;&#10;time.strptime()">
                <outline text="time.strftime(tpl, ts)" _note="&#10;tpl是格式化模板字符串，用来定义输出效果&#10;&#10;ts 是计算机内部时间类型变量&#10;&#10;&gt;&gt; t = time.gmtime()&#10;&gt;&gt; time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,t)&#10;&apos;2020-09-15 09:23:04&apos;&#10;&#10;&gt;&gt; timeStr = &quot;2018-01-26 12:55:20&quot;&#10;&gt;&gt;  time.strptime(timeStr, &quot;%Y-%m-%d %H:%M:%S&quot;)&#10;time.struct_time(tm_year=2018, tm_mon=1, tm_mday=26, tm_hour=12, tm_min=55, tm_sec=20, tm_wday=4, tm_yday=26, tm_isdst=-1)&#10;&#10;&#10;&gt;&gt; time.strftime(&apos;%Y-%m=%d+&apos;,time.gmtime())&#10;&apos;2020-10=02+&apos;"/>
                <outline text="time.strptime(str, tpl)" _note="&#10;str是字符串形式的时间值&#10;&#10;tpl是格式化模板字符串，用来定义输入效果&#10;&#10;In [25]: import time&#10;&#10;In [26]: timeStr = &apos;2018-01-26 12:55:20&apos;&#10;&#10;In [28]: time.strptime(timeStr, &quot;%Y-%m-%d %H:%M:%S&quot;)&#10;&#10;Out[28]: time.struct_time(tm_year=2018, tm_mon=1, tm_mday=26, tm_hour=12, tm_min=55, tm_sec=20, tm_wday=4, tm_yday=26, tm_isdst=-1)&#10;&#10;&#10;&#10;"/>
                <outline text="格式化控制符" _note="&#10;格式化字符串     说明                 范围&#10;&#10;%Y                            年份               0000—9999&#10;&#10;%m                           月份               01-12&#10;&#10;%B                           月份名称        January—December&#10;&#10;%b                            月份名称缩写   Jan—Dec&#10;&#10;%d                           日期                      01-31&#10;&#10;%A                           星期                   Monday—Sunday&#10;&#10;%a                            星期缩写     Mon—Sun&#10;&#10;%H                           小时（24h制） 00—23&#10;&#10;%I                           小时（12h制）    01—12&#10;&#10;%p                           上午/下午              AM，PM&#10;&#10;%M                          分钟                        00—59&#10;&#10;%S                             秒                           00—59&#10;"/>
              </outline>
              <outline text="程序计时 #检索练习 " _note="&#10;time.sleep()&#10;&#10;time.perf_counter()">
                <outline text="time.perf_counter()" _note="&#10;返回一个CPU级别的精确时间计数值，单位为秒&#10;&#10;由于这个计数值起点不确定，连续调用差值才有意义&#10;&#10;e.g.&#10;&#10;&gt;&gt; import time&#10;&gt;&gt; start = time.perf_counter()&#10;64.9212636&#10;&gt;&gt; end = time.perf_counter()&#10;101.6023207&#10;&gt;&gt; end-start&#10;36.681057100000004&#10;&#10;&#10;"/>
                <outline text="time.sleep(s)" _note="&#10;s拟休眠的时间，单位是秒，可以是浮点数&#10;&#10;&gt;&gt; def wait():&#10;      time.sleep(3.3)&#10;&#10;&gt;&gt; wait()&#10;    "/>
              </outline>
            </outline>
            <outline text="补充微软课程">
              <outline text="函数">
                <outline text="datetime.now()" _note="&#10;获得当前时间&#10;&#10;datetime.now().day&#10;&#10;datetime.now().month&#10;&#10;datetime.now().year"/>
                <outline text="timedelta()" _note="&#10;获得一段时间&#10;"/>
                <outline text="datetime.strptime()" _note="&#10;生成固定格式的时间"/>
              </outline>
              <outline text="想完成的想法">
                <outline text="将单个文件名字改成文件名+当前日期" _note="&#10;```&#10;# 将文件改成文件名+当前日期&#10;# 获得当前日期，并转化为YYYYMMDD的字符串&#10;from datetime import datetime&#10;import os.path as op&#10;import os&#10;current_time=datetime.now()&#10;&#10;# 获得自己想要的日期形式&#10;Year_month_day = str(current_time.year)+str(current_time.month)+str(current_time.day)&#10;&#10;# 读取文件名：获得文件路径，和文件名字&#10;file_name = op.basename(&quot;D://ex//农产品供求交易服务平台暂停服务公告.docx&quot;)&#10;print(&apos;原文件名称：&apos;, file_name)&#10;&#10;# 文件名+字符串&#10;new_file_name=file_name.replace(&apos;.&apos;,f&apos;{Year_month_day}.&apos;)&#10;&#10;print(&apos;新文件名称：&apos;,new_file_name)&#10;&#10;# 将原文件名替换为新的文件名&#10;os.rename(file_name, new_file_name)&#10;```"/>
                <outline text="根据文件的创建时间，批量修改文件名为文件名+日期" _note="&#10;&#10;```&#10;# 批量修改目录下文件名称&#10;# 输入：子目录下文件&#10;# 输出：文件名称修改为所有文件+创建时间&#10;&#10;import os,time&#10;from datetime import datetime&#10;&#10;path=input(&apos;请输入文件路径(结尾加上/)：&apos;)       &#10;&#10;# 获取该目录下所有文件名称，以字符串形式存入列表中&#10;fileList=os.listdir(path)&#10;&#10;n=0&#10;for i in fileList:&#10;    &#10;    # 设置旧文件名（就是路径+文件名）&#10;    oldname=path+ os.sep + i  # os.sep添加系统分隔符\\&#10;&#10;    # 获取该文件的创建时间，形成字符串形式&#10;    t=time.gmtime(os.path.getctime(path + os.sep + i))&#10;    creat_time=str(time.strftime(&quot;%Y%m%d&quot;,t))&#10;    &#10;    # 设置新文件名，如果文件名带后缀，则日期插在后缀前面，如果没有后缀，则日期直接放在最后&#10;    if &apos;.&apos; in i:&#10;        newname= path + os.sep + i.replace(&apos;.&apos;,f&apos;_{creat_time}.&apos;)&#10;    else:&#10;        newname= path + os.sep + i+ &apos;_&apos;+ creat_time&#10;    &#10;    os.rename(oldname,newname)   #用os模块中的rename方法对文件改名&#10;    print(oldname,&apos;======&gt;&apos;,newname)&#10;&#10;    ```"/>
                <outline text="读取文件内容，将第一页的日期改成当前日期"/>
              </outline>
              <outline text="we often need current date and time when logging errors and saving data" _note="&#10;```&#10;# To get current date and time&#10;# we need to use the datetime library&#10;from datetime import datetime&#10;&#10;current_date=datetime.now()&#10;# the now function returns a datetime object&#10;&#10;# You must convert the datetime object to a string&#10;#  before you can concatenate it to another string&#10;print(&apos;Today is:&apos; + str(current_date))&#10;&#10;&#10;```"/>
              <outline text="There are functions you can use with datetime objects to manipulate dates" _note="&#10;```&#10;# To get current date and time we need to use the datetime library&#10;import datetime&#10;# The now function returns current date and time&#10;today = datetime.datetime.now()&#10;&#10;print(&apos;Today is &apos; + str(today))&#10;&#10;# You can use timedelta to  add or remove days, or weeks to  a date&#10;# timedelta is used to define a period of time&#10;one_day =datetime.timedelta(days=1)&#10;yesterday = today-one_day&#10;print(&apos;Yesterday was: &apos; + str(yesterday))&#10;&#10;one_week = dt.timedelta(weeks=1)&#10;last_week = today - one_week&#10;print(&apos;Last week was &apos; + str(last_week))&#10;&#10;&#10;&#10;```"/>
              <outline text="Use date functions to  control date fromatting" _note="&#10;```&#10;# To get current date and  time we need to use the datetime library&#10;from datetime import datetime&#10;&#10;# The now fuctions returns current date and time&#10;current_date= datetime.now()&#10;&#10;# use day,month, year, hour, minute, second functions&#10;#  to display only part of the date&#10;# All these functions return integers&#10;# Convert them to strings before concatenating them to anonter string&#10;print(&apos;Day: &apos; + str(current_date.day))&#10;print(&apos;Month: &apos; + str(current_date.month))&#10;print(&apos;Year: &apos; + str(current_date.year))&#10;&#10;print(&apos;Hour: &apos; + str(current_date.hour))&#10;print(&apos;Minute: &apos; + str(current_date.minute))&#10;print(&apos;Second: &apos; + str(current_date.second))&#10;&#10;```"/>
              <outline text="Sometimes you receive the date as a string and need to convert it to a datetime object" _note="&#10;```&#10;from datetime import datetime&#10;birthday = input(&apos;When is your birthday (dd/mm/yyyy)? &apos;)&#10;&#10;birthday_date = datetime.strptime(birthday, &apos;%d/%m/%Y&apos;)&#10;&#10;print(&apos;Birthday: &apos; + str(birthday_date))&#10;&#10;```&#10;&#10;"/>
            </outline>
          </outline>
          <outline text="3.5 实例4：文本进度条 #实例 " collapsed="true">
            <outline text="问题分析">
              <outline text="需求分析" _note="&#10;- 采用字符串方式打印可以动态变化的文本进度条&#10;&#10;- 进度条需要能在一行中逐渐变化"/>
              <outline text="问题分析" _note="&#10;如何获得文本进度条的变化时间？&#10;&#10;- 采用sleep()模拟一个持续的进度&#10;&#10;"/>
            </outline>
            <outline text="简单的开始" _note="&#10;版本1&#10;&#10;#TextProBarV1.py&#10;import time&#10;scale = 10&#10;print(&quot;------执行开始------&quot;)&#10;for i in range(scale+1):&#10;    a = &apos;*&apos; * i&#10;    b = &apos;.&apos; *(scale-i)&#10;    c = (i/scale)*100&#10;    print(&quot;{:^3.0f}%[{}-&gt;{}]&quot;.format(c, a, b))&#10;    time.sleep(0.1)&#10;print(&quot;------执行结束------&quot;)&#10;&#10;&#10;版本2&#10;&#10;#TextProBarV1.py&#10;import time&#10;scale = 10&#10;print(&quot;{0:-^16}&quot;.format(&quot;执行开始&quot;))&#10;for i in range(scale+1):&#10;    a = &apos;*&apos; * i&#10;    b = &apos;.&apos; *(scale-i)&#10;    c = (i/scale)*100&#10;    print(&quot;{:^3.0f}%[{}-&gt;{}]&quot;.format(c, a, b))&#10;    time.sleep(0.1)&#10;print(&quot;{0:-^16}&quot;.format(&quot;执行结束&quot;))"/>
            <outline text="单行动态刷新">
              <outline text="刷新的关键\r" _note="&#10;- 刷新的本质是：用之后打印的字符覆盖之前的字符&#10;&#10;- 不能换行：print()需要被控制&#10;&#10;- 要能退回：打印后光标退回到之前的"/>
              <outline text="代码" _note="&#10;&#10;&#10;&#10;&#10;#TextProBarV2.py&#10;# 单行动态刷新&#10;import time&#10;for i in range(101):&#10; print(&quot;\r{:3}%&quot;.format(i), end=&quot;&quot;)&#10; time.sleep(0.1)&#10;"/>
            </outline>
            <outline text="实例完整效果" _note="&#10;#TextProBarV3.py&#10;&#10;import time&#10;scale = 50&#10;print(&quot;执行开始&quot;.center(scale//2,&quot;-&quot;))&#10;start = time.perf_counter()&#10;for i in range(scale+1):&#10;    a = &apos;*&apos; * i&#10;    b = &apos;-&apos; * (scale - i)&#10;    c = (i/scale) * 100&#10;    dur = time.perf_counter() - start&#10;    print(&quot;\r{:^3.0f}%[{}-&gt;{}]{:.2f}s&quot;.format(c, a, b, dur), end= “ ”)&#10;    time.sleep(0.1)&#10;print(&apos;\n&apos;+&apos;执行结束&apos;.center(scale//2, &apos;-&apos;))"/>
            <outline text="举一反三">
              <outline text="文本进度条程序使用了perf_counter()计时"/>
              <outline text="计时方法适合各类需要统计时间的计算的问题" _note="&#10;例如 比较不同算法时间&#10;           &#10;           统计程序运行时间"/>
              <outline text="进度条应用" _note="&#10;在任何运行时间需要较长的程序中增加进度条&#10;&#10;在任何系统提高用户体验的应用中增加进度条&#10;&#10;进度条是人机交互的纽带之一"/>
              <outline text="文本进度条的不同设计函数" _note="&#10;设计名称               趋势                          设计函数&#10;&#10;Linear                    Constant                   f(x) =x&#10;&#10;Early Pause           Speeds up                 f(x) = x + (1- sin(x*π*2 + π/2))/-8&#10;&#10;....."/>
            </outline>
          </outline>
        </outline>
        <outline text="第4周：程序的控制结构 #基础语法" collapsed="true">
          <outline text="4.1 程序的分支结构">
            <outline text="单分支结构" _note="&#10;根据判断条件结果而选择不同向前路径的运动方式&#10;&#10;if &lt;条件&gt;：&#10; &lt;语句块&gt;&#10;&#10;&#10;e.g.&#10;&#10;guess = eval(input())&#10;&#10;if guess == 99:&#10;    print(&quot;猜对了&quot;)&#10;&#10;&#10;if True:&#10;    print(“条件准确”)"/>
            <outline text="二分支结构" _note="&#10;根据判断条件结果而选择不同向前路径的运动方式&#10;  ">
              <outline text="典型结构" _note="&#10;&#10;if &lt;条件&gt;：&#10; &lt;语句块1&gt;&#10;&#10;else ：&#10; &lt;语句块2&gt;&#10;&#10;&#10;if True:&#10; print(&quot;语句块1&quot;)&#10;else:&#10; print(&quot;语句块2&quot;)&#10;&#10;&#10;e.g.&#10;&#10;guess = eval(input(&quot;请猜数字：&quot;))&#10;if guess == 99:&#10; print(&quot;猜对了&quot;)&#10;else:&#10; print(&quot;猜错了&quot;)">
                <outline text="应用">
                  <outline text="计算中位数" _note="&#10;```&#10;# 计算中位数&#10;def median(numbers):&#10;    sorted(numbers)&#10;    size = len(numbers)&#10;    if size %2 ==0:&#10;        med = (numbers[size//2 -1] +numbers[size//2])/2&#10;    else:&#10;        med = numbers[size//2]&#10;    return med&#10;&#10;n= median([ 1, 2, 3,4])&#10;```"/>
                </outline>
              </outline>
              <outline text="紧凑形式" _note="&#10;适用于简单表达式的二分支结构&#10;&#10;&lt;表达式1&gt;  if  &lt;条件&gt;  else &lt;表达式2&gt;&#10;&#10;e.g.&#10;&#10;guess = eval(input(&quot;请猜数字：&quot;))&#10;&#10;print(&quot;猜{}了&quot;.format(&quot;对&quot; if guess==99 else &quot;错&quot;))"/>
            </outline>
            <outline text="多分支结构" _note="&#10;&#10;if &lt;条件1&gt; ：&#10; &lt;语句块1&gt;&#10;elif &lt;条件2&gt;：&#10; &lt;语句块2&gt;&#10;.....&#10;else:&#10; &lt;语句块N&gt;&#10;&#10;e.g.&#10;&#10;# score.py&#10;score = eval(input(&quot;请输入成绩: &quot;))&#10;if score &gt;= 60 and score &lt; 70:&#10;    grade = &quot;D&quot;&#10;elif score &gt;= 70 and score &lt; 80:&#10;    grade = &quot;C&quot;&#10;elif score &gt;= 80 and score &lt;90:&#10;    grade = &quot;B&quot;&#10;elif score &gt;= 90 and score &lt;= 100:&#10;    grade = &quot;A&quot;&#10;else:&#10;    grade = &quot;0&quot;&#10;    print(&quot;请输入100以内的分数。&quot;)&#10;    &#10;&#10;print(&quot;输入成绩属于级别{}&quot;.format(grade))"/>
            <outline text="条件判断操作符 #检索练习 " _note="&#10;&lt;&#10;&#10;&lt;=&#10;&#10;&gt;=&#10;&#10;&gt;&#10;&#10;==&#10;&#10;!=&#10;"/>
            <outline text="条件组合保留字 #检索练习 " _note="&#10;x and y  逻辑与&#10;&#10;x or y      逻辑或&#10;&#10;not  x      逻辑非&#10;&#10;"/>
            <outline text="条件组合" _note="&#10;if not True:&#10; print(&quot;语句块2&quot;)&#10;else:&#10; print(&quot;语句块1&quot;)&#10;&#10;&#10;e.g.&#10;&#10;guess = eval(input(&quot;请猜数字： &quot;))&#10;&#10;if guess &gt; 99 or guess &lt; 99:&#10;    print(&quot;猜错了&quot;)&#10;else:&#10;    print(&quot;猜对了&quot;)&#10;&#10;&#10;"/>
            <outline text="异常处理 #难点">
              <outline text="异常处理的基本使用 #检索练习 " _note="&#10;&#10;try: &#10; &lt;语句块1&gt;&#10;except:&#10; &lt;语句块2&gt;&#10;&#10;&#10;try:&#10; &lt;语句块1&gt;&#10;except &lt;异常类型&gt;：&#10; &lt;语句块2&gt;&#10;&#10;&#10;e.g.1 :&#10;&#10;try:&#10;    num = eval(input(&quot;请输入一个整数：&quot;))&#10;    print(num **2)&#10;except :&#10;    print(&quot;输入不是整数&quot;)&#10;    &#10;&#10;e.g.2:&#10;&#10;try:&#10;    num = eval(input(&quot;请输入一个整数：&quot;))&#10;    print(num **2)&#10;except NameError:&#10;    print(&quot;输入不是整数&quot;)"/>
              <outline text="异常处理的高级使用 #检索练习 " _note="&#10;try :&#10; &lt;语句块1&gt;&#10;except :&#10; &lt;语句块2&gt;&#10;else :&#10; &lt;语句块3&gt;&#10;finally:&#10; &lt;语句块4&gt;&#10;&#10;&#10;注：finally 对应语句块4一定执行&#10;          else 对应语句块3在不发生异常时执行&#10;&#10;"/>
            </outline>
          </outline>
          <outline text="4.2 实例5：身体质量指数 BMI #实例 " _note="&#10;BMI = 体重（kg）/身高的平方（m*m）&#10;&#10;国际和国内的BMI标准不一样&#10;&#10;                               国际BMI                         国内BMI&#10;偏瘦            &lt; 18.5                                       &lt;18.5&#10;&#10;正常            18.5-25                                   18.5-24&#10;&#10;偏胖            25-30                                      24-28&#10;&#10;肥胖            ≥30                                          ≥28&#10;&#10;难点：同时输出国际和国内对应的分类&#10;&#10;" collapsed="true">
            <outline text="V1 国际" _note="&#10;# CalBMIv1.py&#10;height,weight = eval(input(&quot;请输入身高（米）和体重（千克）[用逗号隔开]: &quot;))&#10;bmi = weight/pow(height, 2)&#10;print(&quot;BMI 数值为：{:.2f}&quot;.format(bmi))&#10;who = &quot;&quot;&#10;if bmi &lt;18.5:&#10;    who = &quot;偏瘦&quot;&#10;elif 18.5&lt;= bmi &lt; 25:&#10;    who = &quot;正常&quot;&#10;elif 25 &lt;= bmi &lt; 30:&#10;    who = &quot;偏胖&quot;&#10;else:&#10;    who = &quot;肥胖&quot;&#10;print(&quot;BMI 指标为国际&apos;{0}&apos;&quot;.format(who))"/>
            <outline text="V2 国内" _note="&#10;# CalBMIv2.py&#10;height,weight = eval(input(&quot;请输入身高（米）和体重（千克）[用逗号隔开]: &quot;))&#10;bmi = weight/pow(height, 2)&#10;print(&quot;BMI 数值为：{:.2f}&quot;.format(bmi))&#10;nat = &quot;&quot;&#10;if bmi &lt;18.5:&#10;    nat = &quot;偏瘦&quot;&#10;elif 18.5&lt;= bmi &lt; 24:&#10;    nat = &quot;正常&quot;&#10;elif 24 &lt;= bmi &lt; 28:&#10;    nat = &quot;偏胖&quot;&#10;else:&#10;    nat = &quot;肥胖&quot;&#10;print(&quot;BMI 指标为国内&apos;{0}&apos;&quot;.format(nat))"/>
            <outline text="举一反三 #检索练习 " _note="&#10;· 多分支条件之间的覆盖是重要问题&#10;&#10;· 程序可运行， 但如果不正确， 要注意多分支&#10;&#10;· 分支结构是程序的重要框架，读程序先看分支"/>
          </outline>
          <outline text="4.3 程序的循环结构" collapsed="true">
            <outline text="遍历循环">
              <outline text="for  in" _note="&#10;for &lt;循环变量&gt; in &lt;遍历结构&gt;：&#10; &lt;语句块&gt;&#10;&#10;&#10;遍历循环是从遍历结构中逐一提取元素，放在循环变量中&#10;"/>
              <outline text="应用 #检索练习 " collapsed="true">
                <outline text="计数循环（N次）" _note="&#10;for  i in range(N):&#10; &lt;语句块&gt;&#10;&#10;遍历由range()函数产生的数字序列，产生循环&#10;&#10;e.g.&#10;&#10; &gt;&gt;for i in range(5):&#10;      print(i)&#10;&#10;&#10;&gt;&gt;  for i in range(5):&#10;      print(&quot;Hello:&quot;, i)&#10;&#10;"/>
                <outline text="计数循环（特定次）" _note="&#10;for i in range(M, N, K):&#10; &lt;语句块&gt;&#10;&#10;遍历由range()函数产生的数字序列，产生循环&#10;&#10;e.g.&#10;&#10;&gt;&gt; for i in range(1,6):&#10;      print(i)&#10;&#10;&gt;&gt; for i in range(1,6,2):&#10;     print(&quot;Hello:&quot;,i)"/>
                <outline text="字符串遍历循环" _note="&#10;for c in s:&#10; &lt;语句块&gt;&#10;&#10;注意：s是字符串，遍历字符串每个字符，产生循环&#10;&#10;e.g.&#10;&#10;&gt;&gt;for c in &quot;Python123&quot;:&#10;     print(c, end= &quot;,&quot;)&#10;&#10;&gt;&gt; for c in &quot;Python123&quot;:&#10;   print(c, end= &quot;\n&quot;) "/>
                <outline text="列表遍历循环" _note="&#10;for item in ls:&#10; &lt;语句块&gt;&#10;&#10;注：ls是一个列表， 遍历其每个元素，产生循环&#10;&#10;e.g.&#10;&#10;&gt;&gt;  for item in [123, &quot;PY&quot;, 456]:&#10;      print(item, end=&quot;,&quot;)&#10;&#10;&gt;&gt; for item in [123, &quot;PY&quot;, 456]:&#10;      print(item, end=&quot;\r&quot;)&#10;&#10;&gt;&gt; for item in [123, &quot;PY&quot;, 4]:&#10;      print(item, end=&quot;\r&quot;)">
                  <outline text="应用">
                    <outline text="计算数字平均值" _note="&#10;```&#10;# 计算平均值&#10;def mean(numbers):&#10;    s = 0.0&#10;    for num in numbers:&#10;        s +=num&#10;    return s/len(numbers)&#10;&#10;n = mean([1, 2, 3, 4])&#10;&#10;```&#10;&#10;&#10;&#10;&#10;"/>
                    <outline text="计算数字方差" _note="&#10;```&#10;# 计算方差：&#10;def dev(numbers,mean):&#10;    sdev =0.0&#10;    for num in numbers:&#10;        sdev +=(num-mean)**2&#10;    return pow(sdev/(len(numbers)-1),0.5)&#10;&#10;n = dev([1,2,3,4], 5)&#10;&#10;```"/>
                  </outline>
                </outline>
                <outline text="文件遍历循环" _note="&#10;for line in fi:&#10; &lt;语句块&gt;&#10;&#10;fi是一个文件标识符，遍历其每行，产生循环&#10;&#10;e.g.&#10;&#10;&gt;&gt; for line in fi:&#10;  print(line)&#10;&#10;"/>
              </outline>
            </outline>
            <outline text="无限循环">
              <outline text="由条件开支的循环运行方式"/>
              <outline text="while" _note="&#10;while &lt;条件&gt;：&#10; &lt;语句块&gt;&#10;&#10;反复执行语句块，直到条件不满足时结束&#10;&#10;&#10;e.g.&#10;&#10;&gt;&gt;  a = 3&#10;&gt;&gt; while a&gt;0:&#10;     a = a-1&#10;    print(a)&#10;&#10;&#10;&gt;&gt; a =3&#10;&gt;&gt; while a&gt;0:&#10; a = a+1&#10; print(a)&#10;&#10;按ctrl +C退出执行">
                <outline text="while应用">
                  <outline text="循环往列表输入数据" _note="&#10;```&#10;# 获取用户不定长度数字的输入&#10;def getNum():&#10;    nums = [] &#10;    iNumStr = input(&quot;请输入数字（回车退出）：&quot;)&#10;    while iNumStr !=&quot;&quot;:&#10;        nums.append(eval(iNumStr))&#10;        iNumStr = input(&quot;请输入数字（回车退出）：&quot;)&#10;    return nums&#10;```&#10;&#10;扩展应用&#10;&#10;· 获得用户不定长度的词组输入"/>
                </outline>
              </outline>
            </outline>
            <outline text="循环控制保留字 #检索练习 ">
              <outline text="break" _note="&#10;跳出并结束当前整个循环，执行循环后的语句&#10;&#10;e.g.&#10;&#10;&gt;&gt; for c in &quot;PYTHON&quot;:&#10;      if c == &quot;T&quot;:&#10;          break&#10;      print(c, end=&quot;&quot;)&#10;    &#10;结果&#10;&#10;PY&#10;&#10;&#10;break 仅跳出当前最内层循环&#10;&#10;&gt;&gt; s = &quot;PYTHON&quot;&#10;&gt;&gt; while s !=&quot;&quot;:&#10;      for c in s:&#10;           print(c, end=&quot;&quot;)&#10;      s = s[:-1]&#10;&#10;结果&#10;PYTHONPYTHOPYTHPYTPYP&#10;&#10;&#10;&gt;&gt; s = &quot;PYTHON&quot;&#10;&gt;&gt; while s !=&quot;&quot;:&#10;      for c in s:&#10;           if c==&quot;T&quot;:&#10;               break&#10;           print(c, end=&quot;&quot;)&#10;      s = s[:-1]&#10;&#10;结果&#10;PYPYPYPYPYP&#10;&#10;"/>
              <outline text="continue" _note="&#10;结束当次循环，继续执行后续次数循环&#10;&#10;break和 continue可以与for和while循环搭配使用&#10;&#10;e.g.&#10;&#10;&gt;&gt;  for c in &quot;PYTHON&quot;:&#10;      if c == &quot;T&quot;:&#10;           continue&#10;      print(c, end=&quot;&quot;)&#10;&#10;结果&#10;PYHON"/>
            </outline>
            <outline text="循环的高级用法 #检索练习 ">
              <outline text="循环与else">
                <outline text="for....in.....else" _note="&#10;&#10;for &lt;变量&gt; in &lt;遍历结构&gt;：&#10; &lt;语句块1&gt;&#10;else:&#10; &lt;语句块2&gt;&#10;&#10;e.g.&#10;&#10;&gt;&gt; for c in &quot;PYTHON&quot;:&#10;      if c == &quot;T&quot;:&#10;           continue&#10;      print(c, end=&quot;&quot;)&#10;     else:&#10;      print(&quot;正常退出&quot;)&#10;&#10;结果&#10;PYHON正常退出&#10;&#10;&#10;&gt;&gt; for c in &quot;PYTHON&quot;:&#10;   if c == &quot;T&quot;:&#10;     break&#10;   print(c, end=&quot;&quot;)&#10; else:&#10;   print(&quot;正常退出&quot;)&#10;&#10;结果&#10;PY&#10;"/>
                <outline text="while....else" _note="&#10;&#10;while &lt;条件&gt;：&#10; &lt;语句块1&gt;&#10;else:&#10; &lt;语句块2&gt;&#10;&#10;&#10;"/>
                <outline text="说明" _note="&#10;当循环没有被break语句退出时，执行else语句块&#10;&#10;else语句块作为“正常”完成循环的奖励&#10;&#10;这里else的用法与异常处理中else的用法相似"/>
              </outline>
            </outline>
          </outline>
          <outline text="4.4 random库  #模块">
            <outline text="random库是使用随机数的Python标准库，用于生成随机数"/>
            <outline text="采用伪随机数：利用梅森旋转算法生成伪随机序列中元素"/>
            <outline text="引用库" _note="&#10;import random"/>
            <outline text="random库函数 #重点  #难点  " collapsed="true">
              <outline text="基本随机数函数 #检索练习 ">
                <outline text="seed(a=None)" _note="&#10;初始化给定的随机数种子，默认为当前系统时间&#10;&#10;&gt;&gt; random.seed(10)&#10;&#10;产生了10对应的序列"/>
                <outline text="random()" _note="&#10;生成一个[0.0, 1.0]之间的随机小数&#10;&#10;&gt;&gt;import random&#10;&gt;&gt; random.seed(10)&#10;&gt;&gt; random.random()&#10;0.5714025946899135&#10;&gt;&gt; random.random()&#10;0.4288890546751146&#10;&#10;&gt;&gt;import random&#10;&gt;&gt; random.seed(10)&#10;&gt;&gt; random.random()&#10;0.5714025946899135&#10;&gt;&gt; random.seed(10)&#10;&gt;&gt; random.random()&#10;0.5714025946899135&#10;&#10;通过random.seed()，可以产出相同的随机数。&#10;&#10;&#10;"/>
              </outline>
              <outline text="扩展随机数函数 #检索练习 ">
                <outline text="randint(a, b)" _note="&#10;生成一个[a,b]之间的整数&#10;&#10;&gt;&gt; random.randint(10,100)&#10;87&#10;&#10;&#10;&gt;&gt; random.seed(19)&#10;&gt;&gt;random.randint(10,100)&#10;96&#10;&gt;&gt;random.seed(19)&#10;&gt;&gt;random.randint(10,100)&#10;96"/>
                <outline text="randrange(m, n(, [k]))" _note="&#10;生成一个[m, n]之间以k为步长的随机整数&#10;&#10;&gt;&gt;random.randrange(10,100,10)&#10;10&#10;&gt;&gt;random.randrange(10,100,10)&#10;90&#10;&#10;&gt;&gt;random.seed(19)&#10;&gt;&gt;random.randrange(10,100,10)&#10;10&#10;&gt;&gt;random.seed(19)&#10;&gt;&gt;random.randrange(10,100,10)&#10;10"/>
                <outline text="getrandbits(k)" _note="&#10;生成一个k比特长的随机整数&#10;&#10;&gt;&gt; random.getrandbits(16)&#10;7909&#10;"/>
                <outline text="uniform(a, b)" _note="&#10;生成一个[a, b]之间的随机整数&#10;&#10;&gt;&gt;random.uniform(10, 100)&#10;56.03425322439341&#10;"/>
                <outline text="choice(seq)" _note="&#10;从序列seq中随机选择一个元素&#10;&#10;&gt;&gt;random.choice([1,2,3,4,5,6,7,8,9])&#10; 6"/>
                <outline text="shuffle(seq)" _note="&#10;将序列seq中元素随机排列，返回打乱后的序列&#10;&#10;&gt;&gt; s=[1,2,3,4,5,6,7,8,9]&#10;&gt;&gt;random.shuffle(s)&#10;&gt;&gt;print(s)&#10;[4, 7, 8, 9, 5, 1, 3, 6, 2]"/>
              </outline>
            </outline>
          </outline>
          <outline text="4.5 实例6：圆周率 #实例">
            <outline text="方法1 公式法" _note="&#10;程序&#10;&#10;#CalPiV1.py&#10;pi =0&#10;N =100&#10;for k in range(N):&#10;    pi +=1/pow(16,k)*(\&#10;        4/(8*k+1)-2/(8*k +4)- \&#10;        1/(8*k+5) - 1/(8*k +6))&#10;print(&quot;圆周率值是：{}&quot;.format(pi))&#10;&#10;&#10;结果&#10;&#10;圆周率值是：3.141592653589793"/>
            <outline text="方法2 蒙特卡罗方法 #难点 " _note="&#10;#CalPiV2.py&#10;&#10;# 引入random库和time库&#10;&#10;from random import random&#10;from time import perf_counter&#10;&#10;&#10;# 设置值一共1000*1000个灰尘，落入灰尘设为初始值0，设置开始时间。&#10;DARTS = 1000*1000&#10;hits = 0.0&#10;start = perf_counter()&#10;&#10;&#10;# 随机落入灰尘，根据直角公式求第三边也就是灰尘到圆心的距离，距离小于1则在圆内，距离大于1则在圆外。叠加在圆内的灰尘。&#10;# 圆的直径是1，则圆面积就是π。&#10;&#10;for i in range(1,DARTS+1):&#10;    x, y =random(), random()  #  学习这种同时给两个变量赋值的方法&#10;    dist = pow(x**2 + y**2, 0.5)&#10;    if dist &lt;=1.0:&#10;      hits = hits + 1&#10;&#10;# 因为算的是1/4的面积，所以算所有的圆面积，则乘以4      &#10;pi = 4 * (hits/DARTS)&#10;print(&quot;圆周率值是：{}&quot;.format(pi))&#10;print(&quot;运行时间是：{:.5f}s&quot;.format(perf_counter()-start))&#10;"/>
            <outline text="举一反三">
              <outline text="数学思维：找到公式，利用公式求解"/>
              <outline text="计算思维：抽象一种过程，用计算机自动化求解"/>
              <outline text="程序运行时间分析">
                <outline text="使用time库的计时方法获得程序运行时间"/>
                <outline text="改变撒点数量，理解程序运行时间的分布"/>
                <outline text="初步掌握简单的程序性能分析方法"/>
              </outline>
            </outline>
          </outline>
          <outline text="实例：三位水仙花数" collapsed="true">
            <outline text="问题" _note="&#10;描述&#10;&#10;&quot;水仙花数&quot;是指一个三位整数，其各位数字的3次方和等于该数本身。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬&#10;&#10;例如：ABC是一个&quot;3位水仙花数&quot;，则：A的3次方＋B的3次方＋C的3次方 = ABC。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬&#10;&#10;请按照从小到大的顺序输出所有的3位水仙花数，请用&quot;逗号&quot;分隔输出结果。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬ &#10;&#10;&#10;问题的难点竟然在于如何去掉最后一个逗号"/>
            <outline text="代码" _note="&#10;s = &quot;&quot;&#10;for i in range(100, 1000):&#10;    t = str(i)&#10;    if pow(eval(t[0]),3) + pow(eval(t[1]),3) + pow(eval(t[2]),3) == i :&#10;        s += &quot;{},&quot;.format(i)&#10;print(s[:-1])"/>
          </outline>
          <outline text="实例：求N的5位质数">
            <outline text="要求" _note="&#10;# 获得用户输入数字N，计算并输出从N开始的5个质数，单行输出，质数间用逗号,分割。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬&#10;# 注意：需要考虑用户输入的数字N可能是浮点数，应对输入取整数；最后一个输出后不用逗号。&#10;# 几个功能块&#10;# 判断数字是否小于2&#10;# 判断是否为质数，质数为True&#10;# 判断是否为整数&#10;# 打印数字，并加上逗号"/>
            <outline text="代码" _note="&#10;def prime(N):&#10;    if N &lt; 2:                   # 判断数字是为小于2，如果为2，则返回错误&#10;        return False&#10;    else:&#10;        n = int(pow(N, 0.5) +1) # 求取平方根，减少运算次数。&#10;        for i in range(2,n):    # 判断是否为质数。&#10;            if N %i ==0:&#10;                return False&#10;        else:                   # 如果for循环执行完毕，则返回True。&#10;            return True&#10;num =eval(input())              # 输入数字&#10;if num != int(num):             # 判断是否为整数，如果不是，则+1&#10;    num =int(num)+1&#10;else:&#10;    num = int(num)              &#10;count =5&#10;while count &gt;0:&#10;    if prime(num):              # if如果为True,则为质数，执行下面语句&#10;        if count &gt;1:            # 如果为前4个数，则在后面加逗号。&#10;            print(num, end=&apos;,&apos;)&#10;        else:                   &#10;            print(num)          # 如果是第五个数，则不加逗号。&#10;        count -=1&#10;    num +=1"/>
          </outline>
          <outline text="实例：100以内素数之和">
            <outline text="问题" _note="&#10;求解100以内的素数的和"/>
            <outline text="代码1" _note="&#10;def is_prime(n):&#10; for i in range(2,n): &#10;  if n%i == 0: &#10;   return False&#10; return True&#10;&#10;sum = 0&#10;for i in range(2,100): &#10; if is_prime(i): &#10;  sum += i &#10;print(sum)"/>
            <outline text="代码2" _note="&#10;sum =0&#10;for i in range(2,101):&#10;    for b in range(2,i):&#10;        if i%b == 0:&#10;            break&#10;    else:&#10;        sum += i&#10;print(sum)"/>
          </outline>
        </outline>
        <outline text="第5周：函数和代码复用 #基础语法" collapsed="true">
          <outline text="5.1 函数的定义和使用">
            <outline text="函数的理解与定义">
              <outline text="函数理解" _note="&#10;函数是一段代码的表示&#10;&#10;- 函数是一段具有特定功能的、可重用的语句组。&#10;&#10;- 函数是一种功能的抽象，一段函数表达特定功能&#10;&#10;- 两个作用：降低编程难度和代码复用"/>
              <outline text="函数定义def" _note="&#10;def &lt;函数名&gt;(参数(0个或多个)):&#10; &lt;函数体&gt;&#10; return &lt;返回值&gt;&#10;&#10;&#10;- 函数定义时，所指定的参数是一种占位符&#10;&#10;- 函数定义后，如果不经过调用，不会被执行&#10;&#10;- 函数定义时，参数是输入、函数体是处理、结果是输出（IPO）&#10;&#10;&#10;e.g. 定义n!&#10;&#10;def fact(n):&#10;    s =1&#10;    for i in range(1, n+1):&#10;        s *= i&#10;    return s&#10;"/>
            </outline>
            <outline text="函数的使用及调用过程" collapsed="true">
              <outline text="函数的使用" _note="&#10;- 调用时要给出实际参数&#10;&#10;- 实际参数替换定义中的参数&#10;&#10;- 函数调用后得到返回值&#10;&#10;e.g. 定义n!&#10;&#10;# 函数的定义&#10;def fact(n):&#10;  s =1&#10;  for i in range(1, n+1):&#10;   s *= i&#10;  return s&#10;&#10;# 函数的调用&#10;fact(10)&#10;&#10;"/>
            </outline>
            <outline text="函数的参数传递 #重点" collapsed="true">
              <outline text="参数个数" _note="&#10;函数可以有参数，也可以没有，但必须保留括号&#10;&#10;def &lt;函数名&gt;():&#10; &lt;函数体&gt;&#10; return &lt;返回值&gt;&#10;&#10;&#10;e.g.&#10;&#10;def fact():&#10; print(&quot;我也是函数&quot;)"/>
              <outline text="可选参数传递 #难点 " _note="&#10;函数定义时可以为某些参数指定默认值，构成可选参数&#10;&#10;&#10;def &lt;函数名&gt;(&lt;非可选参数&gt;, &lt;可选参数&gt;):&#10; &lt;函数体&gt;&#10; return &lt;返回值&gt;&#10; &#10;&#10;e.g.&#10;&#10;# 计算n!//m，其中的m=1就是可选参数。&#10;# nm.py&#10;&#10;def fact(n, m=1):&#10;    s =1&#10;    for i in range(1, n+1):&#10;        s *=i&#10;    return s//m&#10;&#10;&#10;&gt;&gt; fact(10)&#10; 3628800&#10;&#10;&gt;&gt;fact(10,5)&#10;725760&#10;&#10;"/>
              <outline text="可变参数传递 #难点 " _note="&#10;函数定义时可以设计可变数量参数，即不确定参数总数量&#10;&#10;# *b就是可变参数&#10;&#10;def &lt;函数名&gt;(&lt;参数&gt;, *b):&#10; &lt;函数体&gt;&#10; return &lt;返回值&gt;&#10;&#10;e.g.&#10;&#10;# 计算n!乘数&#10;&#10;def fact(n, *b):&#10;    s = 1&#10;    for i in range(1, n+1):&#10;        s *=i&#10;    for item in b:    # b 是可变参数，如果没有，则不执行；如果有，则有几个，s就相乘它们&#10;        s *= item&#10;    return s&#10;&#10;&#10;&gt;&gt;fact(10)&#10;3628800&#10;&#10;&gt;&gt;fact(10,3)   &#10;10886400&#10;&#10;&gt;&gt;fact(10,3,5,8)   # 计算的是fact(10)*3*5*8的值，item取值分别是3，5，8&#10;435456000"/>
              <outline text="参数传递的两种方式 #难点 ">
                <outline text="位置传递" _note="&#10;位置传递是常用方式&#10;&#10;&#10;def fact(n, m=1):&#10;    s=1&#10;    for i in range(1, n+1):&#10;        s *=i&#10;    return s//m&#10;&#10;# 无需输入参数名称，直接按照参数的顺序依次传入参数&#10;&gt;&gt; fact(10, 5)&#10;725760"/>
                <outline text="名称传递" _note="&#10;def fact(n, m=1):&#10; s=1&#10;  for i in range(1, n+1):&#10;   s *=i&#10;  return s//m&#10;&#10; # 直接输入参数名称进行传递，即使位置不同，但还是会传递到相应参数上&#10;&gt;&gt; fact(m=5, n= 10)  &#10;725760"/>
              </outline>
            </outline>
            <outline text="函数的返回值" _note="&#10;函数可以返回0个或多个结果" collapsed="true">
              <outline text="return" _note="&#10;- return保留字用来传递返回值&#10;&#10;- 函数可以有返回值，也可以没有，可以有return，也可以没有&#10;&#10;- return可以传递0个返回值，也可以传递任意多个返回值&#10;"/>
              <outline text="函数调用时，参数可以按照位置或名称方式传递" _note="&#10;e.g.&#10;&#10;def fact(n, m=1):&#10;    s =1&#10;    for i in range(1, n+1):&#10;        s *=i&#10;    return s//m, n, m &#10;&#10;&gt;&gt; fact(10,5)&#10;(725760, 10, 5)&#10;&#10;# 返回元组类型&#10;&#10;&gt;&gt;a,b,c= fact(10,5)   # 按照位置进行传递&#10;&gt;&gt;print(a,b,c)&#10;725760 10 5"/>
            </outline>
            <outline text="局部变量和全局变量 #难点 #重点 " collapsed="true">
              <outline text="结构" _note="&#10;&lt;语句块1&gt;&#10;&#10;def &lt;函数名&gt;(&lt;参数&gt;):&#10; &lt;函数体&gt;&#10; return &lt;返回值&gt;&#10;&#10;&lt;语句块2&gt;&#10;&#10;e.g.&#10;&#10;n, s = 10, 100        # n和s是全局变量&#10;def fact(n):             # fact()函数中的n和s是局部变量&#10;    s = 1&#10;    for i in range(1, n+1):&#10;        s *=i&#10;    return s&#10;print(fact(n),s)     # n和s是全局变量&#10;&#10;&gt;&gt; &#10;3628800 100"/>
              <outline text="规则1：基本数据类型，无论是否重名，局部变量和全部变量是不同变量" _note="&#10;- 局部变量是函数内部的占位符，与全部变量可能重名但不同&#10;&#10;- 函数运算结束后，局部变量被释放&#10;&#10;- 可以使用global保留字在函数内部使用全部变量&#10;&#10;&#10;e.g.&#10;&#10;n, s = 10, 100&#10;def fact(n):                        # fact()函数中s是局部变量，与全局变量s不同&#10;    s = 1&#10;    for i in range(1, n+1):&#10;        s *=i&#10;    return s                            # 此处局部变量s是3628800&#10;print(fact(n),s)                  # 此处全局变量s是100&#10;&#10;&gt;&gt; &#10;3628800 100&#10;&#10;&#10;"/>
              <outline text="规则2：可以通过global保留字在函数内部声明全局变量" _note="&#10;e.g.&#10;&#10;n, s = 10, 100&#10;def fact(n):&#10;  global s # fact()函数中使用global保留字声明，此处s是全局变量s&#10; for i in range(1, n+1):&#10;   s *=i&#10;  return s # 此处s是指全局变量s&#10;print(fact(n),s) # 此处全局变量s被函数修改&#10;&#10;&gt;&gt;&#10;362880000 362880000"/>
              <outline text="规则3：组合数据类型，如果局部变量未真实创建，则等同于全部变量" _note="&#10;e.g.&#10;&#10;ls = [&apos;F&apos;, &apos;f&apos;]                   # 通过使用[]真实创建了一个全局变量列表ls&#10;def func(a):&#10;    ls.append(a)            # 此处ls是列表类型，未真实创建，则等同于全局变量&#10;    return&#10;func(&quot;c&quot;)                     # 全局变量ls被修改&#10;print(ls)&#10;&#10;&gt;&gt;&#10;[&apos;F&apos;, &apos;f&apos;, &apos;c&apos;]&#10;&#10;&#10;e.g.&#10;&#10;ls = [&apos;F&apos;, &apos;f&apos;]                  # 通过使用[]真实创建了一个全局变量列表ls&#10;def func(a):&#10;    ls = []                          # 此处ls是列表类型，真实创建，ls是局部变量&#10;    ls.append(a)&#10;    return&#10;func(&quot;c&quot;)                          # 局部变量ls被修改&#10;print(ls)                         # 打印全局变量ls&#10;&#10;&gt;&gt;                               &#10;[&apos;F&apos;, &apos;f&apos;]&#10;&#10;&gt;&gt; print(func(&quot;c&quot;))      # 打印局部变量&#10;[&apos;c&apos;]&#10;&#10;&#10;"/>
            </outline>
            <outline text="lambda函数 #检索练习  #难点" collapsed="true">
              <outline text="lambda函数返回函数名作为结果" _note="&#10;- lambda函数是一种匿名函数，即没有名字的函数&#10;&#10;- 使用lambda保留字定义， 函数名是返回结果&#10;&#10;- lambda函数用于定义简单的、能够在一行内表示的函数"/>
              <outline text="结构" _note="&#10;&lt;函数名&gt; = lambda &lt;参数&gt;: &lt;表达式&gt;&#10;&#10;&#10;等价于&#10;&#10;def &lt;函数名&gt;(&lt;参数&gt;)：&#10; &lt;函数体&gt;&#10; return &lt;返回值&gt;&#10;&#10;&#10;e.g.&#10;&#10;&gt;&gt;f = lambda x,y : x+y&#10;&gt;&gt;f(10, 15)&#10;25&#10;&#10;&gt;&gt;f = lambda :&quot;lambda函数&quot;&#10;&gt;&gt;print(f())&#10;lambda函数"/>
              <outline text="谨慎使用lambda函数" _note="&#10;- lambda函数主要用作一些特定函数或方法的参数&#10;&#10;- lambda函数有一些固定使用方式，建议逐步掌握&#10;&#10;- 一般情况下，建议使用def定义的普通参数"/>
            </outline>
          </outline>
          <outline text="5.2 实例7：七段数码管绘制 #实例 " collapsed="true">
            <outline text="基本思路" _note="&#10;步骤1：绘制单个数字对应的数码管&#10;&#10;步骤2：获得一串数字，绘制对应的数码管&#10;&#10;步骤3：获得当前系统时间，绘制对应的数码管&#10;&#10;&#10;注意：基本思路是从绘制单个数字，到多个数字，最后关联时间">
              <outline text="步骤1：绘制单个数码管" _note="&#10;- 七段数码管由7个基本线条组成&#10;&#10;- 七段数码管可以有固定顺序&#10;&#10;- 不同数字显示不同的线条&#10;&#10;先绘制不同的单个数字&#10;&#10;&#10;import turtle&#10;&#10;def drawLine(draw):   #绘制单段数码管&#10;    turtle.pendown() if draw else turtle.penup()&#10;    turtle.fd(40)&#10;    turtle.right(90)&#10;  &#10;def drawDigit(digit): #根据数字绘制七段数码管，最好自己将10个数字用七段数码管画一下，这样比较好理解。&#10;    drawLine(True) if digit in [2,3,4,5,6,8,9] else drawLine(False)   # 中间一横&#10;    drawLine(True) if digit in [0,1,3,4,5,6,8,9] else drawLine(False) # 右边下方的一竖&#10;    drawLine(True) if digit in [0,2,3,5,6,8,9] else drawLine(False)   # 最下边一横&#10;    drawLine(True) if digit in [0,2,6,8] else drawLine(False)         # 左边下方的一竖&#10;    &#10;    turtle.left(90)&#10;    drawLine(True) if digit in [0,4,5,6,8,9] else drawLine(False)     # 左边上方的一竖&#10;    drawLine(True) if digit in [0,2,3,5,6,7,8,9] else drawLine(False)  # 最上边的一横&#10;    drawLine(True) if digit in [0,1,2,3,4,7,8,9] else drawLine(False)  # 右边上方的一竖&#10;&#10;    turtle.left(180)&#10;    turtle.penup()  # 为绘制后续数字确定位置&#10;    turtle.fd(20)   # 为绘制后续数字确定位置&#10;&#10;drawDigit(9)&#10;&#10;turtle.done()"/>
              <outline text="步骤2： 获取一段数字，绘制多个数码管" _note="&#10;&#10;- 绘制固定给好的一个数字&#10;&#10;- 增加数码管之间的间隔&#10;&#10;&#10;# singleDigitalCub.py&#10;&#10;import turtle&#10;&#10;def drawGap():  # 绘制数码管间隔&#10;    turtle.penup()&#10;    turtle.fd(5)&#10;&#10;def drawLine(draw):   #绘制单段数码管&#10;    drawGap()&#10;    turtle.pendown() if draw else turtle.penup()&#10;    turtle.fd(40)&#10;    drawGap()&#10;    turtle.right(90)&#10;  &#10;def drawDigit(digit): #根据数字绘制七段数码管，最好自己将10个数字用七段数码管画一下，这样比较好理解。&#10;    drawLine(True) if digit in [2,3,4,5,6,8,9] else drawLine(False)   # 中间一横&#10;    drawLine(True) if digit in [0,1,3,4,5,6,8,9] else drawLine(False) # 右边下方的一竖&#10;    drawLine(True) if digit in [0,2,3,5,6,8,9] else drawLine(False)   # 最下边一横&#10;    drawLine(True) if digit in [0,2,6,8] else drawLine(False)         # 左边下方的一竖&#10;    &#10;    turtle.left(90)&#10;    drawLine(True) if digit in [0,4,5,6,8,9] else drawLine(False)     # 左边上方的一竖&#10;    drawLine(True) if digit in [0,2,3,5,6,7,8,9] else drawLine(False)  # 最上边的一横&#10;    drawLine(True) if digit in [0,1,2,3,4,7,8,9] else drawLine(False)  # 右边上方的一竖&#10;&#10;    turtle.left(180)&#10;    turtle.penup()  # 为绘制后续数字确定位置&#10;    turtle.fd(20)   # 为绘制后续数字确定位置&#10;&#10;def drawDate(date):    #获得要输出的数字,date为日期，格式为&apos;%Y-%m=%d+&apos;&#10;    for i in date:&#10;  drawDigit(eval(i))            &#10;                    &#10;def main():&#10;    turtle.setup(800, 350, 200, 200)&#10;    turtle.penup()&#10;    turtle.fd(-300)&#10;    turtle.pensize(5)&#10;    drawDate(&apos;20181010&apos;)&#10;    turtle.hideturtle()&#10;    turtle.done() &#10;    &#10;main()&#10;&#10;"/>
              <outline text="步骤3：获取系统时间，绘制七段数码管" _note="&#10;-使用time库获得系统当前时间&#10;&#10;- 增加年月日标记&#10;&#10;- 年月日颜色不同&#10;&#10;&#10;# singleDigitalCub.py&#10;&#10;import turtle,time&#10;&#10;def drawGap():  # 绘制数码管间隔&#10;    turtle.penup()&#10;    turtle.fd(5)&#10;&#10;def drawLine(draw):   #绘制单段数码管&#10;    drawGap()&#10;    turtle.pendown() if draw else turtle.penup()&#10;    turtle.fd(40)&#10;    drawGap()&#10;    turtle.right(90)&#10;  &#10;def drawDigit(digit): #根据数字绘制七段数码管，最好自己将10个数字用七段数码管画一下，这样比较好理解。&#10;    drawLine(True) if digit in [2,3,4,5,6,8,9] else drawLine(False)   # 中间一横&#10;    drawLine(True) if digit in [0,1,3,4,5,6,8,9] else drawLine(False) # 右边下方的一竖&#10;    drawLine(True) if digit in [0,2,3,5,6,8,9] else drawLine(False)   # 最下边一横&#10;    drawLine(True) if digit in [0,2,6,8] else drawLine(False)         # 左边下方的一竖&#10;    &#10;    turtle.left(90)&#10;    drawLine(True) if digit in [0,4,5,6,8,9] else drawLine(False)     # 左边上方的一竖&#10;    drawLine(True) if digit in [0,2,3,5,6,7,8,9] else drawLine(False)  # 最上边的一横&#10;    drawLine(True) if digit in [0,1,2,3,4,7,8,9] else drawLine(False)  # 右边上方的一竖&#10;&#10;    turtle.left(180)&#10;    turtle.penup()  # 为绘制后续数字确定位置&#10;    turtle.fd(20)   # 为绘制后续数字确定位置&#10;&#10;def drawDate(date):    #获得要输出的数字,date为日期，格式为&apos;%Y-%m=%d+&apos;&#10;    turtle.pencolor(&quot;red&quot;)&#10;    for i in date:&#10;        if i == &quot;-&quot;:&#10;            turtle.write(&apos;年&apos;, font=(&quot;Arial&quot;, 18, &quot;normal&quot;))&#10;            turtle.pencolor(&quot;green&quot;)&#10;            turtle.fd(40)&#10;        elif i == &quot;=&quot;:&#10;            turtle.write(&apos;月&apos;, font=(&quot;Arial&quot;, 18, &quot;normal&quot;))&#10;            turtle.pencolor(&quot;green&quot;)&#10;            turtle.fd(40)&#10;        elif i == &quot;+&quot;:&#10;            turtle.write(&apos;日&apos;, font=(&quot;Arial&quot;, 18, &quot;normal&quot;))&#10;        else:&#10;            drawDigit(eval(i))&#10;            &#10;                    &#10;def main():&#10;    turtle.setup(800, 350, 200, 200)&#10;    turtle.penup()&#10;    turtle.fd(-300)&#10;    turtle.pensize(5)&#10;    drawDate(time.strftime(&apos;%Y-%m=%d+&apos;,time.gmtime()))&#10;    turtle.hideturtle()&#10;    turtle.done() &#10;    &#10;main()"/>
            </outline>
            <outline text="理解方法思维" _note="&#10;- 模块化思维：确定模块接口，封装功能&#10;&#10;- 规则化思维：抽象过程为规则，计算机自动执行&#10;&#10;- 化繁为简：将大功能变为小功能组合，分而治之"/>
            <outline text="举一反三" _note="&#10;- 绘制带小数点的七段数码管&#10;&#10;- 带刷新的时间倒计时效果&#10;&#10;- 绘制高级的数码管，比如说方框米字数码管，绘制数字，26个字母，单词&#10;&#10;"/>
          </outline>
          <outline text="5.3 代码复用与函数递归" collapsed="true">
            <outline text="代码复用">
              <outline text="把代码当成资源进行抽象" _note="&#10;- 代码资源化：程序代码是用一种用来表达计算的“资源”&#10;&#10;- 代码抽象化： 使用函数等方法对代码赋予更高级别的定义&#10;&#10;- 代码复用：同一份代码在需要时可以被重复使用"/>
              <outline text="函数和对象是代码复用的两种主要形式">
                <outline text="函数" _note="&#10;将代码命名，在代码层面建立初步抽象"/>
                <outline text="对象" _note="&#10;属性&lt;a&gt;.&lt;b&gt;和方法&lt;a&gt;.&lt;b&gt;()&#10;&#10;在函数之上再次组织进行抽象"/>
              </outline>
            </outline>
            <outline text="模块化设计">
              <outline text="分而治之" _note="&#10;- 通过函数或对象封装将程序划分为模块及模块间的表达&#10;&#10;- 具体包括：主程序、子程序和子程序间关系&#10;&#10;- 分而治之：一种分而治之、分层抽象、体系化的设计思想&#10;"/>
              <outline text="紧耦合   松耦合" _note="&#10;- 紧耦合： 两个部分之间交流很多，无法独立存在&#10;&#10;- 松耦合：两个部分之间交流很少，可以独立存在&#10;&#10;- 模块内部紧耦合，模块之间松耦合"/>
            </outline>
            <outline text="函数递归的理解">
              <outline text="递归定义" _note="&#10;函数定义中调用函数自身的方式&#10;&#10;e.g.&#10;&#10;n!  &#10;&#10;n = 0            n!=1&#10;&#10;otherwise   n!=n(n-1)  "/>
              <outline text="递归的两个关键特征">
                <outline text="链条" _note="&#10;计算过程存在递归链条"/>
                <outline text="基例" _note="&#10;存在一个或多个不需要再次递归的基例"/>
              </outline>
              <outline text="递归类似数学归纳法">
                <outline text="数学归纳法" _note="&#10;- 证明当n取第一个值n0时命题成立&#10;&#10;- 假设当nk时命题成立，证明当n=n(k+1)时命题也成立"/>
                <outline text="递归是数学归纳法思维的编程体现"/>
              </outline>
            </outline>
            <outline text="函数递归的调用过程">
              <outline text="递归的实现举例" _note="&#10;e.g.&#10;&#10;def fact(n):&#10;    if n==0:&#10;        return 1&#10;    else:&#10;        return n*fact(n-1)"/>
              <outline text="递归的实现=函数+分支语句" _note="&#10;- 递归本身是一个函数，需要函数定义方式描述&#10;&#10;- 函数内部，采用分支语句对输入参数进行判断&#10;&#10;- 基例和链条，分别编写对应代码"/>
            </outline>
            <outline text="函数递归实例解析">
              <outline text="字符串翻转 #实例 " _note="&#10;将字符串s翻转后输出&#10;&#10;- 函数+ 分支结构&#10;&#10;- 递归链条&#10;&#10;- 递归基例&#10;&#10;&#10;e.g.&#10;&#10;def rvs(s):&#10; if s == &quot;&quot;:&#10;  return s&#10; else:&#10;  return rvs(s[1:]) + s[0]&#10;        &#10;print(rvs(&quot;abcdefg&quot;))"/>
              <outline text="裴波那契数列 #实例 " _note="&#10;n =1   F(n) =1&#10;&#10;n=2   F(n) =1&#10;&#10;otherwise F(n) = F(n-1) + F(n-2)&#10;&#10;- 函数+分支结构&#10;&#10;- 递归链条&#10;&#10;- 递归基例&#10;&#10;def  f(n):&#10; if n ==1 or n ==2&#10;  return 1&#10; else:&#10;  return f(n-1) + f(n-2)"/>
              <outline text="汉诺塔 #实例  #难点 " _note="&#10;输入：&#10;&#10;三根柱子 ABC，圆盘从下往上是按从大往小放在A柱子上，&#10;&#10;输出：&#10;&#10;把圆盘从下往上按从大往小移到在C柱子上&#10;&#10;要求：&#10;&#10;在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘&#10;&#10;&#10;&#10;&#10;&#10;">
                <outline text="代码1：" _note="&#10;steps = 0&#10;def hanoi(src, des, mid, n):&#10;    global steps&#10;    if n == 1:&#10;        steps += 1&#10;        print(&quot;[STEP{:&gt;4}] {}-&gt;{}&quot;.format(steps, src, des))&#10;    else:&#10;        hanoi(src, mid, des, n-1)&#10;        steps += 1&#10;        print(&quot;[STEP{:&gt;4}] {}-&gt;{}&quot;.format(steps, src, des))        &#10;        hanoi(mid, des, src, n-1)&#10;N = eval(input())&#10;hanoi(&quot;A&quot;, &quot;C&quot;, &quot;B&quot;, N)&#10;&#10;# 这个是把步数打印出来了。">
                  <outline text="代码2" _note="&#10;count=0&#10;def hanoi(n,src, dst, mid):&#10;    global count&#10;    if n == 1:&#10;        print(f&quot;{1}:{src}-&gt;{dst}&quot;)&#10;        count+=1&#10;    else:&#10;        hanoi(n-1,src,mid,dst)       #第一步：n-1阶从A→B&#10;        print(f&quot;{n}:{src}-&gt;{dst}&quot;)   #第二步：第n个从A→C&#10;        count+=1&#10;        hanoi(n-1,mid,dst,src)       # 第三步：n-1阶从B→C&#10;    &#10;&#10;def main():&#10;    n = eval(input(&quot;请输入阶数：&quot;))&#10;    hanoi(n, &quot;A&quot;,&quot;C&quot;,&quot;B&quot;)&#10;    print(count)&#10;    &#10;main()&#10;&#10;# 这个是把每个环的移动情况打印出来了。&#10;&#10;# 原理：&#10;# 汉诺塔是典型的函数递归应用的案例，不能用2阶汉诺塔、3阶汉诺塔推理至n阶汉诺塔的方式去理解，必须站在n和n-1的关系去理解。&#10;# 有三个柱子A、B、C,有n阶汉诺塔，从递归的角度考虑，把汉诺塔分为第n个和n-1阶&#10;# 第一步：n-1阶从A→B&#10;# 第二步：第n个从A→C&#10;# 第三步：n-1阶从B→C"/>
                </outline>
              </outline>
            </outline>
          </outline>
          <outline text="5.4 模块：PyInstaller库的使用 #模块 #重点" collapsed="true">
            <outline text="概述" _note="&#10;- PyInstaller库将.py源代码转换成无需源代码的可执行文件&#10;&#10;- PyInstaller库是第三方库，使用pip工具安装&#10;&#10;- 官网：pyinstaller.org&#10;"/>
            <outline text="安装" _note="&#10;cmd里&#10;&#10;pip install pyinstaller"/>
            <outline text="使用" _note="&#10;(cmd命令行里)&#10;&#10;pyinstaller -F &lt;文件名.py&gt;"/>
            <outline text="库常用参数">
              <outline text="-h" _note="&#10;查看帮助"/>
              <outline text="--clean" _note="&#10;清理打包过程中的临时文件"/>
              <outline text="-D, --onedir" _note="&#10;默认值，生成dist文件夹"/>
              <outline text="-F, --onedir" _note="&#10;在dist文件夹中只生成独立的打包文件"/>
              <outline text="-i&lt;图标文件名.ico&gt;" _note="&#10;指定打包程序使用的图标（icon）文件"/>
            </outline>
            <outline text="使用举例" _note="&#10;pyinstaller -i curve.ico -F SevenDigitsDrawV2.py"/>
          </outline>
          <outline text="5.5 实例8：科赫雪花小包裹 #实例 " collapsed="true">
            <outline text="科赫曲线的绘制" _note="&#10;- 递归思想： 函数+分支&#10;&#10;- 递归链条： 线段的组合&#10;&#10;- 递归基例：出事线段&#10;&#10;&#10;e.g.&#10;&#10;# KochDrawV2.py&#10;# 科赫雪花&#10;&#10;import turtle&#10;def koch(size,n):&#10;    if n ==0:&#10;        turtle.fd(size)&#10;    else:&#10;        for angle in [0, 60, -120, 60]:&#10;            turtle.left(angle)&#10;            koch(size/3, n-1)&#10;def main():&#10;    turtle.setup(600, 600)&#10;    turtle.penup()&#10;    turtle.goto(-200,100)&#10;    turtle.pendown()&#10;    turtle.pensize(2)&#10;    turtle.color(&quot;green&quot;)&#10;    level =3&#10;    koch(400, level)&#10;    turtle.right(120)&#10;    koch(400,level)&#10;    turtle.right(120)&#10;    koch(400,level)&#10;    turtle.hideturtle()&#10;&#10;main()&#10;turtle.done()"/>
            <outline text="举一反三：绘制条件的扩展" _note="&#10;- 修改分型几何绘制阶数&#10;&#10;- 修改科赫曲线的基本定义及旋转角度&#10;&#10;- 修改绘制科赫雪花的基础框架图形"/>
            <outline text="举一反三：分形几何千千万">
              <outline text="康托尔集、谢尔宾斯基三角形、门格海绵"/>
              <outline text="龙形曲线、空间填充曲线、科赫曲线"/>
              <outline text="函数递归的深入应用"/>
            </outline>
          </outline>
          <outline text="实例">
            <outline text="随机密码生成">
              <outline text="要求" _note="&#10;描述&#10;&#10;补充编程模板中代码，完成如下功能：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬&#10;&#10;以整数17为随机数种子，获取用户输入整数N为长度，产生3个长度为N位的密码，密码的每位是一个数字。每个密码单独一行输出。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬&#10;产生密码采用random.randint()函数。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬&#10;&#10;示例 1 &#10;3 &#10;&#10;634&#10;524&#10;926"/>
              <outline text="代码" _note="&#10;import random&#10;def genpwd(length):&#10;    a = pow(10, length - 1)&#10;    b = pow(10, length) - 1&#10;    return &quot;{}&quot;.format(random.randint(a, b))&#10;&#10;length = eval(input())&#10;random.seed(17)&#10;for i in range(3):&#10;    print(genpwd(length))&#10;&#10;"/>
            </outline>
          </outline>
        </outline>
        <outline text="第6周：组合数据类型 #基础语法" collapsed="true">
          <outline text="6.1 集合类型及操作" collapsed="true">
            <outline text="集合类型定义" collapsed="true">
              <outline text="集合是多个元素的无序组合" _note="&#10;- 集合类型与数学中的集合概念一致&#10;&#10;- 集合类型之间无序，每个元素唯一，不存在相同元素&#10;&#10;- 集合元素不可更改，不能是可变数据类型&#10;&#10;&#10;&#10;** 集合应用 ** ： 如果想数据组合内没有重复元素的话，就把数据转化成集合"/>
              <outline text="集合类型表示（如何新建集合）#重点" _note="&#10;- 集合用{}表示， 元素间用逗号分隔&#10;&#10;- 建立集合类型用{}或set()&#10;&#10;- 建立空集合类型，必须使用set()&#10;&#10;&#10;&#10;" collapsed="true">
                <outline text="set()" _note="&#10;&#10;&#10;&#10;```&#10;In [33]: A = set((&quot;hard&quot;,&quot;python&quot;)) # set建立多个词组。&#10;&#10;In [34]: A&#10;Out[34]: {&apos;hard&apos;, &apos;python&apos;}&#10;&#10;&#10;In [4]: B = set(&quot;Python&quot;) # set拆分单词为字母&#10;&#10;&#10;In [5]: B&#10;Out[5]: {&apos;P&apos;, &apos;h&apos;, &apos;n&apos;, &apos;o&apos;, &apos;t&apos;, &apos;y&apos;}&#10;&#10;&#10;In [6]: B= set(&quot;Python, 中欧冠&quot;)&#10;&#10;&#10;In [7]: B&#10;Out[7]: {&apos; &apos;, &apos;,&apos;, &apos;P&apos;, &apos;h&apos;, &apos;n&apos;, &apos;o&apos;, &apos;t&apos;, &apos;y&apos;, &apos;中&apos;, &apos;冠&apos;, &apos;欧&apos;}&#10;&#10;```"/>
                <outline text="&lt;变量&gt; ={}" _note="&#10;```&#10;In [2]: A = {&quot;python&quot;, 123, &quot;python&quot;, 123}&#10;&#10;&#10;In [3]: A&#10;Out[3]: {123, &apos;python&apos;}&#10;&#10;```&#10;&#10;注意 {}不是空集合，而是空字典。"/>
              </outline>
            </outline>
            <outline text="集合操作符  #检索练习 #重点 " collapsed="true">
              <outline text="S | T" _note="&#10;并，返回一个新集合，包括在集合S和T中的所有元素&#10;&#10;&#10;```&#10;In [9]: A&#10;Out[9]: {123, &apos;hard&apos;, &apos;python&apos;}&#10;&#10;&#10;In [10]: B&#10;Out[10]: {123, &apos;Python&apos;, &apos;money&apos;}&#10;&#10;&#10;In [11]: A |B&#10;Out[11]: {123, &apos;Python&apos;, &apos;hard&apos;, &apos;money&apos;, &apos;python&apos;}&#10;&#10;&#10;&#10;```"/>
              <outline text="S - T" _note="&#10;差， 返回一个新集合，包括在集合S但不在T中的元素&#10;&#10;&#10;&#10;&#10;```&#10;In [9]: A&#10;Out[9]: {123, &apos;hard&apos;, &apos;python&apos;}&#10;&#10;&#10;In [10]: B&#10;Out[10]: {123, &apos;Python&apos;, &apos;money&apos;}&#10;&#10;&#10;In [12]: A-B&#10;Out[12]: {&apos;hard&apos;, &apos;python&apos;}&#10;&#10;&#10;&#10;```"/>
              <outline text="S &amp; T" _note="&#10;交，返回一个新集合，包括同时在集合S和T中的元素&#10;&#10;只包含 S 和T中的相同元素&#10;&#10;```&#10;In [9]: A&#10;Out[9]: {123, &apos;hard&apos;, &apos;python&apos;}&#10;&#10;&#10;In [10]: B&#10;Out[10]: {123, &apos;Python&apos;, &apos;money&apos;}&#10;&#10;&#10;IIn [14]: A &amp; B&#10;Out[14]: {123}&#10;&#10;&#10;&#10;```&#10;&#10;"/>
              <outline text="S ^ T" _note="&#10;补，返回一个新集合，包括集合S和T中的非相同元素&#10;&#10;也就是取出S和T的相同元素，把剩下的元素放到一起。&#10;&#10;```&#10;In [9]: A&#10;Out[9]: {123, &apos;hard&apos;, &apos;python&apos;}&#10;&#10;&#10;In [10]: B&#10;Out[10]: {123, &apos;Python&apos;, &apos;money&apos;}&#10;&#10;&#10;In [16]: A ^ B&#10;Out[16]: {&apos;Python&apos;, &apos;hard&apos;, &apos;money&apos;, &apos;python&apos;}&#10;&#10;&#10;```&#10;&#10;"/>
              <outline text="S &lt;= T 或 S &lt; T" _note="&#10;返回True或False， 判断S和T的子集关系，S是否是T的一个子集&#10;&#10;```&#10;In [9]: A&#10;Out[9]: {123, &apos;hard&apos;, &apos;python&apos;}&#10;&#10;&#10;In [10]: B&#10;Out[10]: {123, &apos;Python&apos;, &apos;money&apos;}&#10;&#10;&#10;In [17]: A &lt;= B&#10;Out[17]: False&#10;&#10;&#10;In [18]: A &lt; B&#10;Out[18]: False&#10;&#10;&#10;```"/>
              <outline text="S &gt;= T 或 S &gt; T" _note="&#10;返回True或False，判断S和T的包含关系，S是否包含T&#10;&#10;```&#10;In [9]: A&#10;Out[9]: {123, &apos;hard&apos;, &apos;python&apos;}&#10;&#10;&#10;In [10]: B&#10;Out[10]: {123, &apos;Python&apos;, &apos;money&apos;}&#10;&#10;&#10;In [19]: A &gt;=B&#10;Out[19]: False&#10;&#10;&#10;In [20]: A &gt; B&#10;Out[20]: False&#10;&#10;&#10;&#10;```"/>
              <outline text="S |= T" _note="&#10;并，更新集合S，包括在集合S和T中的所有元素&#10;&#10;改变集合S，包含原来S和T中所有元素。&#10;&#10;&#10;```&#10;In [9]: A&#10;Out[9]: {123, &apos;hard&apos;, &apos;python&apos;}&#10;&#10;&#10;In [10]: B&#10;Out[10]: {123, &apos;Python&apos;, &apos;money&apos;}&#10;&#10;&#10;In [21]: A |=B&#10;&#10;&#10;In [22]: A&#10;Out[22]: {123, &apos;Python&apos;, &apos;hard&apos;, &apos;money&apos;, &apos;python&apos;}&#10;&#10;In [23]: A &gt;= B&#10;Out[23]: True&#10;&#10;&#10;In [24]: A &gt; B&#10;Out[24]: True&#10;&#10;```"/>
              <outline text="S -= T" _note="&#10;目的：求差&#10;&#10;输入： 集合S，集合T&#10;&#10;方法：在集合S中去除和集合T相同的元素&#10;&#10;输出：返回更新集合S，新集合S包括在集合S但不在T中的元素&#10;&#10;&#10;&#10;```&#10;&#10;In [10]: B&#10;Out[10]: {123, &apos;Python&apos;, &apos;money&apos;}&#10;&#10;&#10;In [22]: A&#10;Out[22]: {123, &apos;Python&apos;, &apos;hard&apos;, &apos;money&apos;, &apos;python&apos;}&#10;&#10;IIn [25]: A -=B&#10;&#10;&#10;In [26]: A&#10;Out[26]: {&apos;hard&apos;, &apos;python&apos;}&#10;&#10;```"/>
              <outline text="S &amp;= T" _note="&#10;交，更新集合S，包括同时在集合S和T中的元素&#10;&#10;```&#10;In [26]: A&#10;Out[26]: {&apos;hard&apos;, &apos;python&apos;}&#10;&#10;&#10;In [27]: B&#10;Out[27]: {123, &apos;Python&apos;, &apos;money&apos;}&#10;&#10;&#10;In [28]: A &amp;=B&#10;&#10;&#10;In [29]: A&#10;Out[29]: set()&#10;```"/>
              <outline text="S ^= T" _note="&#10;补，更新集合S，包括集合S和T中的非相同元素。&#10;&#10;```&#10;In [34]: A&#10;Out[34]: {&apos;hard&apos;, &apos;python&apos;}&#10;&#10;&#10;In [35]: B&#10;Out[35]: {123, &apos;Python&apos;, &apos;money&apos;}&#10;&#10;&#10;In [36]: A.add(&quot;Python&quot;)&#10;&#10;&#10;In [37]: A&#10;Out[37]: {&apos;Python&apos;, &apos;hard&apos;, &apos;python&apos;}&#10;&#10;&#10;In [38]: A ^=B&#10;&#10;&#10;In [39]: A&#10;Out[39]: {123, &apos;hard&apos;, &apos;money&apos;, &apos;python&apos;}&#10;&#10;&#10;```&#10;"/>
            </outline>
            <outline text="集合处理方法   #检索练习 #重点" collapsed="true">
              <outline text="S.add(x)" _note="目的：添加元素x到集合S中&#10;&#10;方法：如果x不在集合S中，将x增加到S；如何x在集合S中，则不新添加x&#10;&#10;输出：新集合S&#10;&#10;```&#10;&#10;In [40]: A&#10;Out[40]: {123, &apos;hard&apos;, &apos;money&apos;, &apos;python&apos;}&#10;&#10;&#10;In [41]: A.add(123)&#10;&#10;&#10;In [42]: A&#10;Out[42]: {123, &apos;hard&apos;, &apos;money&apos;, &apos;python&apos;}&#10;&#10;&#10;In [43]: A.add(&quot;word&quot;)&#10;&#10;&#10;In [44]: A&#10;Out[44]: {123, &apos;hard&apos;, &apos;money&apos;, &apos;python&apos;, &apos;word&apos;}&#10;&#10;&#10;```&#10;&#10;"/>
              <outline text="S.discard(x)" _note="&#10;移除集合S中元素x，如果x不在集合S中，不报错&#10;"/>
              <outline text="S.remove(x)" _note="&#10;&#10;移除集合S中元素x，如果x不在集合S中，产生KeyError异常"/>
              <outline text="S.clear()" _note="&#10;移除集合S中所有元素"/>
              <outline text="S.pop()" _note="&#10;随机返回集合S的一个元素，更新集合S，若S为空则产生KeyError异常"/>
              <outline text="S.copy()" _note="&#10;返回集合S的一个副本"/>
              <outline text="len(S)" _note="&#10;返回集合S的元素个数"/>
              <outline text="x in S" _note="&#10;判断集合S中元素x，x在集合S中，返回True，否则返回False"/>
              <outline text="x not in S" _note="&#10;判断集合S中元素x，x不在集合S中，返回True，否则返回False"/>
              <outline text="set(x)" _note="&#10;将其他类型变量x转变为集合类型"/>
            </outline>
            <outline text="集合类型及应用场景" collapsed="true">
              <outline text="包含关系比较" _note="&#10;&gt;&gt;&gt; &quot;p&quot; in {&quot;p&quot;, &quot;y&quot;, 123}&#10;True&#10;&#10;&gt;&gt;&gt; {&quot;p&quot;,&quot;y&quot;} &gt;= {&quot;p&quot;, &quot;y&quot;, 123}&#10;False"/>
              <outline text="数据去重：集合类型所有元素无重复" _note="&#10;&gt;&gt;&gt; ls = [&quot;p&quot;,&quot;p&quot;,&quot;y&quot;,&quot;y&quot;,123]&#10;&gt;&gt;&gt; s = set(ls)    # 列表转化为集合&#10;{&apos;p&apos;,&apos;y&apos;, 123}&#10;&gt;&gt;&gt; lt = list(s)     # 集合转化为列表&#10;[&apos;p&apos;,&apos;y&apos;,123&apos;]"/>
            </outline>
          </outline>
          <outline text="6.2 序列类型及操作" collapsed="true">
            <outline text="序列类型定义(什么是序列类型)" collapsed="true">
              <outline text="序列是具有先后关系的一组元素" _note="&#10;- 序列是一维元素向量，元素类型可以不同&#10;&#10;- 类似数学元素序列&#10;&#10;- 元素间由序号引导，通过下标访问序列的特定元素"/>
              <outline text="序列是一个基类类型" _note="&#10;序列类型包括&#10;&#10;- 字符串类型&#10;&#10;- 元组类型&#10;&#10;-  列表类型"/>
            </outline>
            <outline text="序列处理函数及方法（序列类型有哪些函数和方法）  #检索练习" collapsed="true">
              <outline text="序列类型通用操作符  #重点">
                <outline text="x in s" _note="&#10;如果 x是序列s的元素， 返回True，否则返回False"/>
                <outline text="x not in s" _note="&#10;如果 x是序列s的元素， 返回False，否则返回True"/>
                <outline text="s + t" _note="&#10;连接两个序列 s +t"/>
                <outline text="s*n 或 n*s" _note="&#10;将序列s复制n次"/>
                <outline text="s[i]" _note="&#10;索引，返回s中的第i个元素， i是序列的序号"/>
                <outline text="s[i: j]或s[i: j: k]" _note="&#10;切片，返回序列s中第i到第j以k为步长的元素子序列"/>
              </outline>
              <outline text="序列类型通用函数和方法 #重点">
                <outline text="len(s)" _note="&#10;返回序列s的长度，即元素个数"/>
                <outline text="min(s)" _note="&#10;返回序列s的最小元素，s中元素需要可比较"/>
                <outline text="max(s)" _note="&#10;&#10;返回序列s的最大元素，s中元素需要可比较&#10;&#10;&#10;e.g.&#10;&#10; &gt;&gt;s=&quot;python123.io&quot;&#10;&gt;&gt;min(s)&#10; &apos;.&apos;&#10;&gt;&gt;max(s)&#10; &apos;y&apos;&#10;&#10;"/>
                <outline text="s.index(x) 或 s.index(x, i, j)" _note="&#10;返回序列s从i开始到j位置中第一次出现元素x的位置"/>
                <outline text="s.count(x)" _note="&#10;返回序列s中出现x的总次数"/>
                <outline text="type(x)" _note="&#10;返回变量x的类型"/>
              </outline>
            </outline>
            <outline text="元组类型及操作" collapsed="true">
              <outline text="元组是序列类型的一种扩展" _note="&#10;- 元组是一种序列类型，一旦创建就不能更改&#10;&#10;- 使用小括号() 或tuple()创建，元素间用逗号， 分隔&#10;&#10;- 可以使用或不使用小括号&#10;&#10;e.g.&#10;&#10;def func():&#10; return 1, 2&#10;&#10;&#10;&#10;&gt;&gt; creature = &quot;cat&quot;,&quot;dog&quot;,&quot;tiger&quot;,&quot;human&quot;&#10;&gt;&gt;creature&#10;(&apos;cat&apos;, &apos;dog&apos;, &apos;tiger&apos;, &apos;human&apos;)&#10;&#10;&gt;&gt;color = (0x001100, &quot;blue&quot;, creature)&#10;&gt;&gt;color&#10; (4352, &apos;blue&apos;, (&apos;cat&apos;, &apos;dog&apos;, &apos;tiger&apos;, &apos;human&apos;))"/>
              <outline text="元组继承序列类型的全部通用操作" _note="&#10;- 元组继承了序列类型的全部通用操作&#10;&#10;- 元组因为创建后不能修改，因此没有特殊操作&#10;&#10;- 使用或不使用小括号&#10;&#10;&#10;e.g.&#10;&#10;&#10;&gt;&gt; creature = &quot;cat&quot;,&quot;dog&quot;,&quot;tiger&quot;,&quot;human&quot;&#10;&gt;&gt; creature[::-1]&#10; (&apos;human&apos;, &apos;tiger&apos;, &apos;dog&apos;, &apos;cat&apos;)&#10;&#10;&gt;&gt;color = (0x001100, &quot;blue&quot;, creature)&#10;&gt;&gt;color[-1][2]&#10; &apos;tiger&apos;"/>
            </outline>
            <outline text="列表类型及操作" collapsed="true">
              <outline text="列表是序列类型的一种扩展，十分有用" _note="&#10;- 列表是序列类型，创建后可以随意更改&#10;&#10;- 使用方括号[] 或list()创建，元素间用逗号，分隔&#10;&#10;- 列表中各元素类型可以不同，无长度限制&#10;&#10;e.g.&#10;&#10; &gt;&gt;ls =[ &quot;cat&quot;,&quot;dog&quot;,&quot;tiger&quot;,1024]&#10;&gt;&gt;ls&#10;[&apos;cat&apos;, &apos;dog&apos;, &apos;tiger&apos;, 1024]&#10;&#10;&gt;&gt;lt = ls&#10;&gt;&gt;lt&#10;[&apos;cat&apos;, &apos;dog&apos;, &apos;tiger&apos;, 1024]"/>
              <outline text="列表类型操作函数和方法  #检索练习  #重点">
                <outline text="ls[i] = x" _note="&#10;替换列表ls第i元素为x"/>
                <outline text="ls[i: j: k] = lt" _note="&#10;用列表lt替换ls切片后所对应元素子列表"/>
                <outline text="del ls[i]" _note="&#10;删除列表ls中第i元素"/>
                <outline text="del ls[i: j: k]" _note="&#10;删除列表ls中第i到第j以k为步长的元素"/>
                <outline text="ls +=lt" _note="&#10;更新列表ls，将列表lt元素增加到列表ls中"/>
                <outline text="ls *= n" _note="&#10;更新列表s，其元素重复n次。&#10;&#10;&#10;e.g.&#10;&#10;&#10;&gt;&gt;ls= [&quot;cat&quot;, &quot;dog&quot;, &quot;tiger&quot;, 1024]&#10;&#10;&gt;&gt;ls[1:2]=[1,2,3,4]&#10;&gt;&gt;ls&#10;[&apos;cat&apos;, 1, 2, 3, 4, &apos;tiger&apos;, 1024]&#10;&#10;&gt;&gt;ls[1:6:2]=[&quot;old dog&quot;,&quot;boy&quot;, &quot;women&quot;]&#10;&gt;&gt;ls&#10;[&apos;cat&apos;, &apos;old dog&apos;, 2, &apos;boy&apos;, 4, &apos;women&apos;, 1024]&#10;&#10;&gt;&gt;del ls[::3]&#10;&gt;&gt;ls&#10; [&apos;old dog&apos;, 2, 4, &apos;women&apos;]&#10;&#10;&gt;&gt;ls*2&#10; [&apos;old dog&apos;, 2, 4, &apos;women&apos;, &apos;old dog&apos;, 2, 4, &apos;women&apos;]"/>
                <outline text="sorted(ls)" _note="&#10;不改变原列表，对列表的元素按从小到大进行排序&#10;&#10;```&#10;In [78]: lt&#10;Out[78]: [3, 4, 8, 9, 1]&#10;&#10;&#10;In [79]: sorted(lt)&#10;Out[79]: [1, 3, 4, 8, 9]&#10;&#10;&#10;In [80]: sorted(lt,reverse=True)&#10;Out[80]: [9, 8, 4, 3, 1]&#10;```"/>
                <outline text="ls.append(x)" _note="&#10;在列表ls最后增加一个元素x&#10;&#10;lt.append()只能添加一个元素"/>
                <outline text="ls.clear()" _note="&#10;删除列表ls中所有元素"/>
                <outline text="ls.copy()" _note="&#10;生成一个新列表，赋值ls中所有元素"/>
                <outline text="ls.insert(i,x)" _note="&#10;在列表ls的第i位置增加元素x&#10;&#10;如果i 为正，则x占据i位置，原位置数字右移；如果i为负，x占据（i-1）位置&#10;&#10;```&#10;In [31]: lt&#10;Out[31]: [98, 1, 2, 7, 89, 33, 45, 3, 2]&#10;&#10;&#10;In [32]: lt.insert(1,6)&#10;&#10;&#10;In [33]: lt&#10;Out[33]: [98, 6, 1, 2, 7, 89, 33, 45, 3, 2]&#10;&#10;&#10;In [34]: lt.insert(-1,7)&#10;&#10;&#10;In [35]: lt&#10;Out[35]: [98, 6, 1, 2, 7, 89, 33, 45, 3, 7, 2]&#10;```"/>
                <outline text="ls.pop(i)" _note="&#10;在列表ls中第i位置元素取出并删除该元素"/>
                <outline text="ls.remove(x)" _note="&#10;将列表ls中出现的第一个元素x删除"/>
                <outline text="ls.reverse()" _note="&#10;将列表ls中的元素反转&#10;&#10;e.g.&#10;&#10;&gt;&gt;ls= [&quot;cat&quot;, &quot;dog&quot;, &quot;tiger&quot;, 1024]&#10;&gt;&gt;ls.append(1234)&#10;&gt;&gt;ls&#10;[&apos;cat&apos;, &apos;dog&apos;, &apos;tiger&apos;, 1024, 1234]&#10;&gt;&gt;ls.insert(3,&quot;human&quot;)&#10;&gt;&gt;ls&#10; [&apos;cat&apos;, &apos;dog&apos;, &apos;tiger&apos;, &apos;human&apos;, 1024, 1234]&#10;&gt;&gt;ls.reverse()&#10;&gt;&gt;ls&#10;[1234, 1024, &apos;human&apos;, &apos;tiger&apos;, &apos;dog&apos;, &apos;cat&apos;]"/>
              </outline>
              <outline text="练习： 列表功能默写  #检索练习 #重点" collapsed="true">
                <outline text="定义空列表lt" _note="&#10;lt = []"/>
                <outline text="向lt新增5个元素" _note="&#10;lt +=[1, 2, 3, 4, 5]"/>
                <outline text="修改lt中第2个元素" _note="&#10;lt[1] = &quot;good&quot;"/>
                <outline text="向lt中第2个位置增加一个元素" _note="&#10;lt.insert(2, 7)&#10;&#10;"/>
                <outline text="从lt中第1个位置删除一个元素" _note="&#10;del lt[1]"/>
                <outline text="删除lt中第1-3位置元素" _note="&#10;del lt[1:4]"/>
                <outline text="判断lt中是否包含数字0" _note="&#10;0 in lt"/>
                <outline text="向lt新增数字0" _note="&#10;lt.append[0]"/>
                <outline text="返回数字0所在lt中的索引" _note="&#10;lt.index(0)"/>
                <outline text="lt的长度" _note="&#10;len(it)"/>
                <outline text="lt中最大元素" _note="&#10;max(lt)"/>
                <outline text="清空lt" _note="&#10;lt.clear()"/>
              </outline>
              <outline text="应用">
                <outline text="空列表[]" _note="&#10;空列表一般应用于获得输入数字&#10;&#10;比如&#10;&#10;```&#10;# 获取用户不定长度的输入&#10;def getNum():&#10;    nums = [] &#10;    iNumStr = input(&quot;请输入数字（回车退出）：&quot;)&#10;    while iNumStr !=&quot;&quot;:&#10;        nums.append(eval(iNumStr))&#10;        iNumStr = input(&quot;请输入数字（回车退出）：&quot;)&#10;    return nums&#10;```"/>
              </outline>
            </outline>
            <outline text="序列类型应用场景" collapsed="true">
              <outline text="数据表示：元组和列表" _note="&#10;- 元组用于元素不改变的应用场景， 更多用于固定搭配场景&#10;&#10;- 列表更加灵活，它是最常用的序列类型&#10;&#10;- 最主要作用：表示一组有序数列， 进而操作它们"/>
              <outline text="元素遍历" _note="&#10;for item in ls:&#10; &lt;语句块&gt;&#10;&#10;&#10;for item in tp:&#10; &lt;语句块&gt;"/>
              <outline text="数据保护" _note="&#10;如果不希望数据被程序所改变，转换成元组类型&#10;&#10;&gt;&gt;ls= [&quot;cat&quot;, &quot;dog&quot;, &quot;tiger&quot;, 1024]&#10;&gt;&gt;lt= tuple(ls)&#10;&gt;&gt;lt&#10; (&apos;cat&apos;, &apos;dog&apos;, &apos;tiger&apos;, 1024)"/>
            </outline>
          </outline>
          <outline text="6.3 实例9：基本统计值计算 #实例 " collapsed="true">
            <outline text="问题分析" _note="&#10;基本统计值&#10;&#10;需求： 给出一组数， 对它们有个概要理解&#10;&#10;求总个数，求和，平均值，方差，中位数&#10;&#10;- 总个数： len()&#10;&#10;- 求和： for ... in...&#10;&#10;- 平均值： 求和/总个数&#10;&#10;- 方差：各数据与平均数差的平方和的平均数&#10;&#10;- 中位数：排序，然后&#10;&#10;奇数找中间1个，偶数找中间2个取平均&#10;&#10;"/>
            <outline text="实例讲解" _note="```&#10;#CalSatisticsV1.py&#10;&#10;# 获取用户不定长度的输入&#10;def getNum():&#10;    nums = []&#10;    iNumStr = input(&quot;请输入数字（回车退出）: &quot;)&#10;    while iNumStr !=&quot;&quot;:&#10;        nums.append(eval(iNumStr))&#10;        iNumStr = input(&quot;请输入数字（回车退出）： &quot;)&#10;    return nums&#10;&#10;# 计算平均值&#10;def mean(numbers):&#10;    s = 0.0&#10;    for num in numbers:&#10;        s = s +num&#10;    return s /len(numbers)&#10; &#10;&#10;# 计算方差&#10;&#10;def dev(numbers, mean):&#10;    sdev = 0.0&#10;    for num in numbers:&#10;        sdev = sdev +(num-mean)**2&#10;    return pow(sdev/(len(numbers)-1), 0.5)&#10;    &#10;&#10;# 计算中位数&#10;&#10;def median(numbers):&#10;    sorted(numbers)&#10;    size = len(numbers)&#10;    if size %2 ==0:&#10;        med= (numbers[size//2 -1]+ numbers[size//2])/2&#10;    else:&#10;        med= numbers[size//2]&#10;        &#10;    return med&#10;&#10;# 执行函数&#10;n = getNum()&#10;m = mean(n)&#10;print(&quot;平均值：{}，方差：{:.2}，中位数：{}.&quot;.format(m,dev(n,m),median(n)))&#10;```"/>
            <outline text="实例最小功能块">
              <outline text="用户输入不定长度的数字" _note="&#10;输入：用户输入数字或字符&#10;&#10;方法：输入数字或字符，停止输入时，回车退出&#10;&#10;输出：不定长度的字符列表&#10;&#10;&#10;```&#10;def getNum():&#10;    nums = []&#10;    iNumStr = input(&quot;请输入数字（回车退出）: &quot;)&#10;    while iNumStr !=&quot;&quot;:&#10;        nums.append(eval(iNumStr))&#10;        iNumStr = input(&quot;请输入数字（回车退出）： &quot;)&#10;    return nums&#10;&#10;d=getNum()&#10;&#10;print(d)&#10;&#10;```&#10;"/>
              <outline text="输入数字列表，输出数字平均值" _note="&#10;&#10;&#10;```&#10;def mean(numbers):&#10;    s = 0.0&#10;    for num in numbers:&#10;        s = s +num&#10;    return s /len(numbers)&#10;&#10;ls =mean([2,3,4,5,6])&#10; &#10;```"/>
              <outline text="输入数字列表和平均值，计算数字方差" _note="&#10;```&#10;def dev(numbers, mean):&#10;    sdev = 0.0&#10;    for num in numbers:&#10;        sdev = sdev +(num-mean)**2&#10;    return pow(sdev/(len(numbers)-1), 0.5)&#10;&#10;s = dev([2,3,4,5], 7)&#10;&#10;```"/>
              <outline text="输入数字列表，计算中位数" _note="&#10;```&#10;def median(numbers):&#10;    sorted(numbers)&#10;    size = len(numbers)&#10;    if size %2 ==0:&#10;        med= (numbers[size//2 -1]+ numbers[size//2])/2&#10;    else:&#10;        med= numbers[size//2]&#10;        &#10;    return med&#10;&#10;s= median([1,3,0,3,4])&#10;&#10;```"/>
            </outline>
            <outline text="举一反三" _note="&#10;- 获取多个数据： 从控制台获取多个不确定数据的方法&#10;&#10;- 分隔多个函数： 模块化设计方法&#10;&#10;- 充分利用函数： 充分利用Python提供的内置函数"/>
          </outline>
          <outline text="6.4 字典类型及操作" collapsed="true">
            <outline text="字典类型定义">
              <outline text="理解“映射”" _note="&#10;- 映射是一种键（索引）和值（数据）的对应&#10;&#10;"/>
              <outline text="字典类型是“映射”的体现" _note="&#10;- 键值对： 键是数据索引的扩展&#10;&#10;- 字典是键值对的几何，键值对之间无序&#10;&#10;- 采用大括号{}和dict()创建，键值对用冒号: 表示"/>
              <outline text="在字典变量中，通过键获得值" _note="&#10;&lt;字典变量&gt; = {&lt;键1&gt;:&lt;值1&gt;, ...  , &lt;键n&gt;:&lt;值n&gt;}&#10;&#10;&lt;值&gt; =&lt;字典变量&gt;[键]&#10;&#10;&lt;字典变量&gt;[键] = &lt;值&gt;&#10;&#10;[] 用来向字典变量中索引或增加元素&#10;&#10;&#10;e.g.&#10;&#10;&gt;&gt;d = {&quot;中国&quot;:&quot;北京&quot;, &quot;美国&quot;:&quot;华盛顿&quot;, &quot;英国&quot;:&quot;伦敦&quot; }&#10;&gt;&gt;d&#10;{&apos;中国&apos;: &apos;北京&apos;, &apos;美国&apos;: &apos;华盛顿&apos;, &apos;英国&apos;: &apos;伦敦&apos;}&#10;&#10;&gt;&gt;d[&quot;中国&quot;]&#10; &apos;北京&apos;&#10;&#10;&gt;&gt;type(d)&#10;dict&#10;"/>
            </outline>
            <outline text="字典处理函数及方法 #检索练习 #重点 " collapsed="true">
              <outline text="del d[k]" _note="&#10;删除字典d中键k对应的数据值"/>
              <outline text="k in d" _note="&#10;判断键k是否在字典d中，如果在则返回True，否则False"/>
              <outline text="d.keys()" _note="&#10;返回字典d中所有的键信息"/>
              <outline text="d.values()" _note="&#10;返回字典d中所有的值信息"/>
              <outline text="d.items()" _note="&#10;返回字典d中所有的键值对信息&#10;&#10;&#10;e.g.&#10;```&#10;&gt;&gt; d = {&quot;中国&quot;:&quot;北京&quot;, &quot;美国&quot;:&quot;华盛顿&quot;, &quot;英国&quot;:&quot;伦敦&quot; }&#10;&gt;&gt; &quot;中国&quot; in d&#10;True&#10;&#10;&gt;&gt;d.keys()&#10;dict_keys([&apos;中国&apos;, &apos;美国&apos;, &apos;英国&apos;])&#10;&#10;&gt;&gt;d.values()&#10;dict_values([&apos;北京&apos;, &apos;华盛顿&apos;, &apos;伦敦&apos;])&#10;&#10;&gt;&gt;d.items()&#10;dict_items([(&apos;中国&apos;, &apos;北京&apos;), (&apos;美国&apos;, &apos;华盛顿&apos;), (&apos;英国&apos;, &apos;伦敦&apos;)])&#10;&#10;&gt;&gt;del d[&quot;美国&quot;]&#10;&gt;&gt;d&#10;{&apos;中国&apos;: &apos;北京&apos;, &apos;英国&apos;: &apos;伦敦&apos;}&#10;&#10;&gt;&gt; &quot;北京&quot; in d.values()&#10;True&#10;&#10;```"/>
              <outline text="d.get(k, &lt;default&gt;)" _note="&#10;键k存在，则返回相应值，不在则返回&lt;default&gt;值&#10;&#10;```&#10;&#10;In [1]: d={1:&quot;China&quot;, 2:&quot;Amercia&quot;, 3:&quot;Japan&quot;}&#10;&#10;&#10;In [2]: d.get(1)&#10;Out[2]: &apos;China&apos;&#10;&#10;&#10;In [3]: count=2&#10;&#10;&#10;In [4]: d.get(4,count)  # 如果key=4存在，则 返回值；如果不存在，则返回count&#10;Out[4]: 2&#10;&#10;&#10;In [5]: d&#10;Out[5]: {1: &apos;China&apos;, 2: &apos;Amercia&apos;, 3: &apos;Japan&apos;}&#10;&#10;```&#10;"/>
              <outline text="d.pop(k, &lt;default&gt;)" _note="&#10;键k存在，则取出相应值，并在字典d中去除d；不在则返回&lt;default&gt;值&#10;&#10;&#10;```&#10;In [5]: d&#10;Out[5]: {1: &apos;China&apos;, 2: &apos;Amercia&apos;, 3: &apos;Japan&apos;}&#10;&#10;In [6]: d.pop(1)&#10;Out[6]: &apos;China&apos;&#10;```&#10;&#10;&#10;&#10;&#10;"/>
              <outline text="d.popitem()" _note="&#10;随机从字典d中取出一个键值对，以元组形式返回，字典d中去除该键值对&#10;&#10;&#10;&#10;```&#10;In [7]: d&#10;Out[7]: {2: &apos;Amercia&apos;, 3: &apos;Japan&apos;}&#10;&#10;&#10;In [8]: d.popitem()&#10;Out[8]: (3, &apos;Japan&apos;)&#10;&#10;&#10;In [9]: d&#10;Out[9]: {2: &apos;Amercia&apos;}&#10;&#10;```"/>
              <outline text="d.clear()" _note="&#10;删除所有的键值对"/>
              <outline text="len(d)" _note="&#10;返回字典d中元素的个数&#10;&#10;&#10;e.g.&#10;&#10;&gt;&gt;d = {&quot;中国&quot;:&quot;北京&quot;, &quot;美国&quot;:&quot;华盛顿&quot;, &quot;法国&quot;:&quot;巴黎&quot; }&#10;&#10;&gt;&gt;d.get(&quot;中国&quot;,&quot;伊斯兰堡&quot;)&#10; &apos;北京&apos;&#10;&#10;&gt;&gt;d.get(&quot;巴基斯坦&quot;,&quot;伊斯兰堡&quot;)&#10;&apos;伊斯兰堡&apos;&#10;&#10;&gt;&gt;d.popitem()&#10;(&apos;法国&apos;, &apos;巴黎&apos;)"/>
              <outline text="d[keys]=values" _note="&#10;新增一个值&#10;&#10;In [9]: d&#10;Out[9]: {2: &apos;Amercia&apos;}&#10;&#10;In [10]: d[1]=&quot;Canda&quot;&#10;&#10;&#10;In [11]: d&#10;Out[11]: {2: &apos;Amercia&apos;, 1: &apos;Canda&apos;}&#10;&#10;&#10;In [12]: d[2],d[3]=&quot;China&quot;,&quot;Austria&quot;&#10;&#10;&#10;In [13]: d&#10;Out[13]: {2: &apos;China&apos;, 1: &apos;Canda&apos;, 3: &apos;Austria&apos;}"/>
            </outline>
            <outline text=" 字典功能默写 #检索练习 #重点 ">
              <outline text="定义空字典d" _note="&#10;d ={}&#10; &#10;d = dict()"/>
              <outline text="向d新增2个键值对元素" _note="&#10;```&#10;d [&quot;a&quot;] =1&#10;&#10;d[&quot;b&quot;] =2&#10;&#10;```&#10;或&#10;```&#10;&#10;d[&quot;a&quot;],d[&quot;b&quot;]=1,2&#10;&#10;```"/>
              <outline text="修改第二个元素" _note="&#10;d[&quot;b&quot;] = 3"/>
              <outline text="判断字符“c”是否是d的键" _note="&#10;“c” in d"/>
              <outline text="计算d的长度" _note="&#10;len(d)"/>
              <outline text="清空d" _note="&#10;d.clear()"/>
            </outline>
            <outline text="字典类型应用场景">
              <outline text="映射的表达" _note="&#10;- 映射无处不在，键值对无处不在&#10;&#10;- 例如： 统计数据出现的次数，数据是键，次数是值&#10;&#10;- 最主要作用： 表达键值对数据，进而操作它们"/>
              <outline text="元素遍历" _note="&#10;for k in d :&#10; &lt;语句块&gt;&#10;&#10;&#10;&#10;&gt;&gt;d = {&apos;中国&apos;: &apos;北京&apos;, &apos;a&apos;: 1, &apos;b&apos;: 2}&#10;&#10;&gt;&gt;for i in d:&#10;     print(d[i])&#10;    &#10;北京&#10;1&#10;2"/>
            </outline>
          </outline>
          <outline text="6.5 模块：jieba库的使用 #模块 " collapsed="true">
            <outline text="jieba库基本介绍">
              <outline text="jieba库是优秀的中文分词第三方库" _note="&#10;- 中文文本需要通过分词获得单个的词语&#10;&#10;- jieba是优秀的中文分词第三方库，需要额外安装&#10;&#10;- jieba库提供三种分词模式，最简单只需要掌握一个函数&#10;"/>
              <outline text="jieba库的安装" _note="&#10;（cmd命令行）&#10;&#10;pip install jieba "/>
              <outline text="jieba分词依靠中文词库" _note="&#10;- 利用一个中文词库，确定中文字符之间的关联概率&#10;&#10;- 中文字符间概率大的组成词组，形成分词结果&#10;&#10;- 除了分词，用户还可以添加自定义的词组"/>
            </outline>
            <outline text="jieba库使用说明">
              <outline text="jieba分词的三种模式">
                <outline text="精确模式" _note="&#10;把文本精确的切分开，不存在冗余单词"/>
                <outline text="全模式" _note="&#10;把文本中所有可能的词语都扫描出来，有冗余"/>
                <outline text="搜索引擎模式" _note="&#10;在精确模式基础上，对长词再次切分"/>
              </outline>
              <outline text="jieba库常用函数 #重点 ">
                <outline text="jieba.lcut(s)" _note="&#10;精确模式，返回一个列表类型的分词结果&#10;&#10;```&#10;&gt;&gt;&gt;jieba.lcut(&quot;中国是一个伟大的国家&quot;)&#10; [&apos;中国&apos;, &apos;是&apos;, &apos;一个&apos;, &apos;伟大&apos;, &apos;的&apos;, &apos;国家&apos;]&#10;&#10;```"/>
                <outline text="jieba.lcut(s, cut_all=True)" _note="&#10;全模式，返回一个列表类型的分词结果，存在冗余&#10;&#10;```&#10;&#10;&gt;&gt; jieba.lcut(&quot;中国是一个伟大的国家&quot;, cut_all=True)&#10;[&apos;中国&apos;, &apos;国是&apos;, &apos;一个&apos;, &apos;伟大&apos;, &apos;的&apos;, &apos;国家&apos;]&#10;&#10;```"/>
                <outline text="jieba.lcut_for_search(s)" _note="&#10;搜索引擎模式，返回一个列表类型的分词结果，存在冗余&#10;&#10;```&#10;&gt;&gt; jieba.lcut_for_search(&quot;中华人民共和国是伟大的&quot;)&#10;[&apos;中华&apos;, &apos;华人&apos;, &apos;人民&apos;, &apos;共和&apos;, &apos;共和国&apos;, &apos;中华人民共和国&apos;, &apos;是&apos;, &apos;伟大&apos;, &apos;的&apos;]&#10;&#10;```"/>
                <outline text="jieba.add_word(w)" _note="&#10;向分词词典增加新词w&#10;&#10;输入：新词&#10;&#10;输出：在分隔时会将新词做为一个词组。&#10;&#10;eg.1&#10;&#10;```&#10;&#10;&gt;&gt;jieba.add_word(&quot;蟒蛇语言&quot;)&#10;&#10;```&#10;&#10;eg.2&#10;```&#10;In [74]: import jieba&#10;&#10;&#10;In [75]: sentence = &quot;天长地久有时尽，此恨绵绵无绝期&quot;&#10;&#10;&#10;In [76]: jieba.lcut(sentence)&#10;Out[76]: [&apos;天长地久&apos;, &apos;有时&apos;, &apos;尽&apos;, &apos;，&apos;, &apos;此恨绵绵&apos;, &apos;无&apos;, &apos;绝期&apos;]&#10;&#10;&#10;In [77]: jieba.add_word(&quot;有时尽&quot;,999,&apos;nz&apos;)&#10;&#10;&#10;In [78]: print(&quot;添加【有时尽】：&quot;,jieba.lcut(sentence))&#10;添加【有时尽】： [&apos;天长地久&apos;, &apos;有时尽&apos;, &apos;，&apos;, &apos;此恨绵绵&apos;, &apos;无&apos;, &apos;绝期&apos;]&#10;```"/>
                <outline text="jieba.del_word(w)" _note="&#10;向分词词典删除词w&#10;&#10;```&#10;In [74]: import jieba&#10;&#10;&#10;In [75]: sentence = &quot;天长地久有时尽，此恨绵绵无绝期&quot;&#10;&#10;&#10;In [76]: jieba.lcut(sentence)&#10;Out[76]: [&apos;天长地久&apos;, &apos;有时&apos;, &apos;尽&apos;, &apos;，&apos;, &apos;此恨绵绵&apos;, &apos;无&apos;, &apos;绝期&apos;]&#10;&#10;&#10;In [79]: jieba.del_word(&quot;时尽&quot;)&#10;&#10;&#10;In [80]: print(&quot;删除：【时尽】：&quot;,jieba.lcut(sentence))&#10;删除：【时尽】： [&apos;天长地久&apos;, &apos;有时尽&apos;, &apos;，&apos;, &apos;此恨绵绵&apos;, &apos;无&apos;, &apos;绝期&apos;]&#10;&#10;```"/>
              </outline>
            </outline>
          </outline>
          <outline text="6.6 实例10：文本词频统计 #实例 ">
            <outline text="问题分析" _note="&#10;需求： 一篇文章，出现了那些词？那些词出现得最多&#10;&#10;材料：&#10;&#10;英文文本：Hamet 分析词频&#10;&#10;中文文本：《三国演义》 分析人物"/>
            <outline text="英文实例：&quot;Hamlet英文词频统计&quot;实例统计 ">
              <outline text="文本去噪及归一化"/>
              <outline text="使用字典表达词频"/>
              <outline text="代码" _note="&#10;功能块：&#10;&#10;1. 预处理文本&#10;&#10;2. 切割文本&#10;&#10;3. 计算文本词频&#10;&#10;4. 词频排序&#10;&#10;5.输出高频单词&#10;&#10;&#10;&#10;```&#10;#CalHamletV1.py&#10;# 预处理文本&#10;def getText():&#10;    txt = open(&quot;hamlet.txt&quot;, &quot;r&quot;).read()&#10;    txt = txt.lower()&#10;    for ch in &apos;!&quot;#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~&apos;:&#10;        txt = txt.replace(ch, &quot; &quot;)&#10;    return txt&#10;    &#10;hamletTxt = getText()&#10;&#10;# 形成列表，切割文本&#10;words = hamletTxt.split()    &#10;&#10;# 将列表中元素变成字典键值对，计算文本词频     &#10;counts = {}&#10;for word in words:&#10;    counts[word] = counts.get(word, 0) +1&#10;# 将键值对变成一个列表里的元组&#10;items = list(counts.items())&#10;&#10;# 词频排序&#10;items.sort(key=lambda x:x[1],reverse=True)&#10;&#10;# 输出高频词&#10;for i in range(10):&#10;    word, count = items[i]&#10;    print(&quot;{0:&lt;10}{1:&gt;5}&quot;.format(word,count))&#10;```"/>
              <outline text="最小功能块" collapsed="true">
                <outline text="处理英文文本（读取文件，改成小写，去除多余字符!&quot;#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~）" _note="&#10;输入： 文本&#10;&#10;输出：处理后的文本&#10;&#10;      - 不带特殊字符&#10;      - 全部小写&#10;             - 单词之间有空格&#10;&#10;&#10;```&#10;def getText():&#10;    txt = open(&quot;hamlet.txt&quot;, &quot;r&quot;).read()&#10;    txt = txt.lower()&#10;    for ch in &apos;!&quot;#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~&apos;:&#10;        txt = txt.replace(ch, &quot; &quot;)&#10;    return txt&#10; &#10;hamletTxt = getText()&#10;```"/>
                <outline text="字符串变成列表" _note="&#10;输入： 带空格的字符串&#10;&#10;输出：以空格为分隔符，变为列表。&#10;&#10;注意： 不要使用`hameletTxt.split(‘ ’)`，否则会分隔出空格&#10;&#10;```&#10;words = hamletTxt.split()    &#10;```"/>
                <outline text="计算列表里的词频 ☆" _note="&#10;输入：列表&#10;&#10;输出：带有元组的列表。&#10;&#10;&#10;```&#10;# 将列表中元素变成字典键值对        &#10;counts = {}&#10;words = [1, 2, 3, 4, 1, 2, 3,4 ]&#10;for word in words:&#10;    counts[word] = counts.get(word, 0) +1&#10;# 将键值对变成一个列表里的元组&#10;items = list(counts.items())&#10;```&#10;&#10;技能点&#10;&#10;- 计算词频，使用`d.get()`和添加字典功能，单词为键，词频数量为值。如果单词存在，则加1。&#10;&#10;```&#10;for word in words:&#10;  counts[word] = counts.get(word, 0) +1&#10;&#10;```&#10;&#10;- 通过 `d.items() `的形式可以将键值对变成词组放到字典里，如果直接用 `list(counts)`，则只有值，没有键。&#10;&#10;`items = list(counts.items())`"/>
                <outline text="词频排序 ☆" _note="&#10;通过`list.sort()`和`lambda`对词频排序&#10;&#10;lambda用于取出第二个元素。&#10;&#10;list.sort(key)用于对列表的每个元素进行处理。&#10;&#10;```&#10;# 词频排序&#10;items.sort(key=lambda x:x[1],reverse=True)&#10;```&#10;" collapsed="true">
                  <outline text=" list.sort()" _note="&#10;&#10;技能点&#10;&#10;- list.sort(key=None, reverse=False)&#10;&#10;key 主要是用来选择进行比较的元素&#10;&#10;reverse=False为升序，reverse=True为降序，默认是降序&#10;&#10;list.sort()可以迭代对每个元素进行处理。&#10;"/>
                  <outline text="lambda x:x[1]" _note="&#10;&#10;`lambda`用于取出第二个元素。&#10;&#10;```&#10;In [113]: e=[(1, 16), (&apos;wrog&apos;, 4), (&apos;god&apos;, 2), (2, 4)]&#10;&#10;# 取出列表里每个元组的第二个元素&#10;In [115]: for i in e:&#10; ...: print(i[1])&#10; ...: &#10;16&#10;4&#10;2&#10;4&#10;&#10;# 取出列表里每个元组的第一个元素&#10;In [116]: for i in e:&#10; ...: print(i[0])&#10; ...: &#10;1&#10;wrog&#10;god&#10;2&#10;&#10;```&#10;&#10;```&#10;&#10;In [121]: e&#10;Out[121]: [(1, 16), (&apos;wrog&apos;, 4), (&apos;god&apos;, 2), (2, 4)]&#10;&#10;&#10;In [122]: key=lambda x:x[1]&#10;&#10;&#10;In [123]: key(e)&#10;Out[123]: (&apos;wrog&apos;, 4)&#10;```"/>
                </outline>
                <outline text="输出词频" _note="&#10;输出前多少个词频。&#10;&#10;```&#10;In [127]: e&#10;Out[127]: [(&apos;god&apos;, 2), (&apos;wrog&apos;, 4), (2, 4), (1, 16)]&#10;&#10;for i in range(3):&#10;    word, count = e[i]&#10;    print(&quot;{0:&lt;10}{1:&gt;5}&quot;.format(word,count))&#10;&#10;```"/>
              </outline>
            </outline>
            <outline text="中文实例：“《三国演义》人物出场统计”实例讲解">
              <outline text="中文文本分词"/>
              <outline text="使用字典表达词频">
                <outline text="代码" _note="&#10;```&#10;#CalThreeKingdomsV1.py&#10;import jieba&#10;txt = open(&quot;threekingdoms.txt&quot;, &quot;r&quot;, encoding = &quot;utf-8&quot;).read()&#10;words = jieba.lcut(txt)&#10;counts = {}&#10;for word in words:&#10;    if len(word) ==1:&#10;        continue&#10;    else:&#10;        counts[word] = counts.get(word,0) +1&#10;items = list(counts.items())&#10;items.sort(key=lambda x:x[1],reverse=True)&#10;for i in range(15):&#10;    word, count = items[i]&#10;    print(&quot;{0:&lt;10}{1:&gt;5}&quot;.format(word,count))&#10;&#10;```"/>
              </outline>
              <outline text="扩展程序解决问题：《三国演义》人物出场统计" _note="&#10;将词频与人物相关联，面向问题">
                <outline text="代码" _note="&#10;```&#10;#CalThreeKingdomsV2.py&#10;import jieba&#10;&#10;txt = open(&quot;threekingdoms.txt&quot;, &quot;r&quot;, encoding = &quot;utf-8&quot;).read()&#10;excloudes = {&quot;将军&quot;,&quot;却说&quot;,&quot;荆州&quot;,&quot;二人&quot;,&quot;不可&quot;,&quot;不能&quot;,&quot;如此&quot;,&quot;商议&quot;,&quot;如何&quot;,&quot;主公&quot;,&quot;军士&quot;,&quot;左右&quot;,&quot;军马&quot;,&quot;引兵&quot;,&quot;次日&quot;,&quot;大喜&quot;,&quot;天下&quot;,&quot;东吴&quot;,&quot;于是&quot;,&quot;今日&quot;,&quot;不敢&quot;,&quot;魏兵&quot;,&quot;陛下&quot;,&quot;一人&quot;,&quot;都督&quot;,&quot;人马&quot;,&quot;不知&quot;}&#10;words = jieba.lcut(txt)&#10;counts = {}&#10;&#10;for word in words:&#10;    if len(word)==1:&#10;        continue&#10;    elif word == &quot;诸葛亮&quot; or word == &quot;孔明曰&quot;:&#10;        rword =&quot;孔明&quot;&#10;    elif word == &quot;关公&quot; or word == &quot;云长&quot;:&#10;        rword = &quot;关羽&quot;&#10;    elif word == &quot;玄德&quot; or word == &quot;玄德曰&quot;:&#10;        rword = &quot;刘备&quot;&#10;    elif word == &quot;孟德&quot; or word == &quot;丞相&quot;:&#10;        rword = &quot;曹操&quot;&#10;    else:&#10;        rword = word        &#10;    counts[rword]= counts.get(rword,0) + 1&#10;&#10;for word in excloudes:&#10;    del counts[word]&#10;&#10;items = list(counts.items())&#10;items.sort(key=lambda x:x[1],reverse=True)&#10;for i in range(10):&#10;    word, count = items[i]&#10;    print(&quot;{0:&lt;10}{1:&gt;5}&quot;.format(word,count))&#10;```">
                  <outline text="功能块">
                    <outline text="合并重复指代词，生成词频字典" _note="&#10;去除单个字，合并重复指代的词，计算词频，生成字典&#10;&#10;```&#10;for word in words:&#10;    if len(word)==1:&#10;        continue&#10;    elif word == &quot;诸葛亮&quot; or word == &quot;孔明曰&quot;:&#10;        rword =&quot;孔明&quot;&#10;    elif word == &quot;关公&quot; or word == &quot;云长&quot;:&#10;        rword = &quot;关羽&quot;&#10;    elif word == &quot;玄德&quot; or word == &quot;玄德曰&quot;:&#10;        rword = &quot;刘备&quot;&#10;    elif word == &quot;孟德&quot; or word == &quot;丞相&quot;:&#10;        rword = &quot;曹操&quot;&#10;    else:&#10;        rword = word        &#10;    counts[rword]= counts.get(rword,0) + 1&#10;&#10;```&#10;其中`continue`的用法很有意思&#10;&#10;```&#10;&#10;In [129]: e=[1,2,3,4]&#10;&#10;In [130]: for i in e:&#10;     ...:     if i ==1:&#10;     ...:         continue&#10;     ...:     else:&#10;     ...:         print(i)&#10;     ...:     print(i+10)&#10;     ...:     &#10;2&#10;12&#10;3&#10;13&#10;4&#10;14&#10;```&#10;&#10;如果i==1执行的话，是则不执行print(i+10)的情况&#10;"/>
                    <outline text="删除字典里重复词（keys）" _note="&#10;输入：集合，字典&#10;&#10;输出：根据集合里的元素，删除字典里集合元素和键相同的键值对。&#10;&#10;&#10;&#10;```&#10;&#10;excloudes = {&quot;将军&quot;,&quot;却说&quot;}&#10;counts={&quot;将军&quot;:1,  &quot;却说&quot;:2, &quot;关羽&quot;:3}&#10;&#10;for word in excloudes:&#10;    del counts[word]&#10;&#10;```"/>
                  </outline>
                </outline>
              </outline>
              <outline text="根据结果进一步优化"/>
            </outline>
            <outline text="举一反三">
              <outline text="应用问题的扩展" _note="&#10;- 《红楼梦》、《西游记》、《水浒传》....&#10;&#10;-  政府工作报告、科研论文、新闻报道...&#10;&#10;-  进一步呢？未来还有词云..."/>
            </outline>
          </outline>
          <outline text="#实例 ">
            <outline text="数字不同数之和">
              <outline text="要求" _note="&#10;描述&#10;获得用户输入的一个整数N，输出N中所出现不同数字的和。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬&#10;例如：用户输入 123123123，其中所出现的不同数字为：1、2、3，这几个数字和为6。&#10;&#10;来源&#10;&#10;[Python123](https://python123.io/student/courses/3382/groups/39674/problems/programmings/17639#pagetop)"/>
              <outline text="代码" _note="&#10;```&#10;num = input(&quot;&quot;)&#10;setNum = set(num)&#10;listNum = list(setNum)&#10;sum=0&#10;for  i in listNum:&#10;    sum += eval(i)&#10;print(sum)&#10;&#10;# 错误&#10;&#10;# 第6行lt +=sum错误，应为sum +=eval(i)&#10;# 第7行print(lt)输出错误，应为print(sum)&#10;&#10;```&#10;"/>
              <outline text="最小功能块">
                <outline text="去除重复元素" _note="&#10;通过转换成set()去除重复元素，通过list()转换为列表&#10;&#10;```&#10;num = input(&quot;&quot;)&#10;setNum = set(num)&#10;listNum = list(setNum)&#10;&#10;```"/>
              </outline>
            </outline>
            <outline text="人名最多数统计">
              <outline text="要求" _note="&#10;描述&#10;编程模板中给出了一个字符串，其中包含了含有重复的人名，请直接输出出现最多的人名。"/>
              <outline text="代码1" _note="&#10;```&#10;s = &apos;&apos;&apos;双儿 洪七公 赵敏 赵敏 逍遥子 鳌拜 殷天正 金轮法王 乔峰 杨过 洪七公 郭靖 &#10;       杨逍 鳌拜 殷天正 段誉 杨逍 慕容复 阿紫 慕容复 郭芙 乔峰 令狐冲 郭芙 &#10;       金轮法王 小龙女 杨过 慕容复 梅超风 李莫愁 洪七公 张无忌 梅超风 杨逍 &#10;       鳌拜 岳不群 黄药师 黄蓉 段誉 金轮法王 忽必烈 忽必烈 张三丰 乔峰 乔峰 &#10;       阿紫 乔峰 金轮法王 袁冠南 张无忌 郭襄 黄蓉 李莫愁 赵敏 赵敏 郭芙 张三丰 &#10;       乔峰 赵敏 梅超风 双儿 鳌拜 陈家洛 袁冠南 郭芙 郭芙 杨逍 赵敏 金轮法王 &#10;       忽必烈 慕容复 张三丰 赵敏 杨逍 令狐冲 黄药师 袁冠南 杨逍 完颜洪烈 殷天正 &#10;       李莫愁 阿紫 逍遥子 乔峰 逍遥子 完颜洪烈 郭芙 杨逍 张无忌 杨过 慕容复 &#10;       逍遥子 虚竹 双儿 乔峰 郭芙 黄蓉 李莫愁 陈家洛 杨过 忽必烈 鳌拜 王语嫣 &#10;       洪七公 韦小宝 阿朱 梅超风 段誉 岳灵珊 完颜洪烈 乔峰 段誉 杨过 杨过 慕容复 &#10;       黄蓉 杨过 阿紫 杨逍 张三丰 张三丰 赵敏 张三丰 杨逍 黄蓉 金轮法王 郭襄 &#10;       张三丰 令狐冲 赵敏 郭芙 韦小宝 黄药师 阿紫 韦小宝 金轮法王 杨逍 令狐冲 阿紫 &#10;       洪七公 袁冠南 双儿 郭靖 鳌拜 谢逊 阿紫 郭襄 梅超风 张无忌 段誉 忽必烈 &#10;       完颜洪烈 双儿 逍遥子 谢逊 完颜洪烈 殷天正 金轮法王 张三丰 双儿 郭襄 阿朱 &#10;       郭襄 双儿 李莫愁 郭襄 忽必烈 金轮法王 张无忌 鳌拜 忽必烈 郭襄 令狐冲 &#10;       谢逊 梅超风 殷天正 段誉 袁冠南 张三丰 王语嫣 阿紫 谢逊 杨过 郭靖 黄蓉 &#10;       双儿 灭绝师太 段誉 张无忌 陈家洛 黄蓉 鳌拜 黄药师 逍遥子 忽必烈 赵敏 &#10;       逍遥子 完颜洪烈 金轮法王 双儿 鳌拜 洪七公 郭芙 郭襄 赵敏&apos;&apos;&apos;&#10;&#10;listWord=s.split()&#10;count = {}&#10;for word in listWord:&#10;    count[word] = count.get(word,0) +1&#10;items = list(count.items())&#10;items.sort(key=lambda x:x[1],reverse=True)&#10;words,counts = items[0]&#10;print(f&quot;{words}&quot;)&#10;&#10;# 错误集&#10;# 第22行for word in i: 错误，应为for word in listWord:&#10;# 第24行tu = list(tuple(count))错误，应为items = list(count.items())&#10;&#10;&#10;```"/>
              <outline text="代码2" _note="&#10;```&#10;s = &apos;&apos;&apos;双儿 洪七公 赵敏 赵敏 逍遥子 鳌拜 殷天正 金轮法王 乔峰 杨过 洪七公 郭靖 &#10;       杨逍 鳌拜 殷天正 段誉 杨逍 慕容复 阿紫 慕容复 郭芙 乔峰 令狐冲 郭芙 &#10;       金轮法王 小龙女 杨过 慕容复 梅超风 李莫愁 洪七公 张无忌 梅超风 杨逍 &#10;       鳌拜 岳不群 黄药师 黄蓉 段誉 金轮法王 忽必烈 忽必烈 张三丰 乔峰 乔峰 &#10;       阿紫 乔峰 金轮法王 袁冠南 张无忌 郭襄 黄蓉 李莫愁 赵敏 赵敏 郭芙 张三丰 &#10;       乔峰 赵敏 梅超风 双儿 鳌拜 陈家洛 袁冠南 郭芙 郭芙 杨逍 赵敏 金轮法王 &#10;       忽必烈 慕容复 张三丰 赵敏 杨逍 令狐冲 黄药师 袁冠南 杨逍 完颜洪烈 殷天正 &#10;       李莫愁 阿紫 逍遥子 乔峰 逍遥子 完颜洪烈 郭芙 杨逍 张无忌 杨过 慕容复 &#10;       逍遥子 虚竹 双儿 乔峰 郭芙 黄蓉 李莫愁 陈家洛 杨过 忽必烈 鳌拜 王语嫣 &#10;       洪七公 韦小宝 阿朱 梅超风 段誉 岳灵珊 完颜洪烈 乔峰 段誉 杨过 杨过 慕容复 &#10;       黄蓉 杨过 阿紫 杨逍 张三丰 张三丰 赵敏 张三丰 杨逍 黄蓉 金轮法王 郭襄 &#10;       张三丰 令狐冲 赵敏 郭芙 韦小宝 黄药师 阿紫 韦小宝 金轮法王 杨逍 令狐冲 阿紫 &#10;       洪七公 袁冠南 双儿 郭靖 鳌拜 谢逊 阿紫 郭襄 梅超风 张无忌 段誉 忽必烈 &#10;       完颜洪烈 双儿 逍遥子 谢逊 完颜洪烈 殷天正 金轮法王 张三丰 双儿 郭襄 阿朱 &#10;       郭襄 双儿 李莫愁 郭襄 忽必烈 金轮法王 张无忌 鳌拜 忽必烈 郭襄 令狐冲 &#10;       谢逊 梅超风 殷天正 段誉 袁冠南 张三丰 王语嫣 阿紫 谢逊 杨过 郭靖 黄蓉 &#10;       双儿 灭绝师太 段誉 张无忌 陈家洛 黄蓉 鳌拜 黄药师 逍遥子 忽必烈 赵敏 &#10;       逍遥子 完颜洪烈 金轮法王 双儿 鳌拜 洪七公 郭芙 郭襄 赵敏&apos;&apos;&apos;&#10;ls = s.split()&#10;d = {}&#10;for i in ls:&#10;    d[i] = d.get(i, 0) + 1&#10;max_name, max_cnt = &quot;&quot;, 0&#10;for k in d:&#10;    if d[k] &gt; max_cnt:&#10;        max_name, max_cnt = k, d[k]&#10;print(max_name)&#10;&#10;```">
                <outline text="最小功能块">
                  <outline text="比较法求出最大值" _note="&#10;```&#10;lt=[2,4,5,3,1]&#10;max=0&#10;for i in range(len(lt)):&#10;	if lt[i] &gt;max:&#10;		max =lt[i]&#10;print(max)&#10;```"/>
                </outline>
              </outline>
            </outline>
          </outline>
        </outline>
        <outline text="第7周：文件和数据格式化 #基础语法" collapsed="true">
          <outline text="两种格式化" collapsed="true">
            <outline text="字符串格式化" _note="&#10;“{}{}{}”.format()&#10;&#10;将字符串按照一定规格和式样进行规范&#10;&#10;"/>
            <outline text="数据格式化" _note="&#10;将一组数据按照一定规格和式样进行规范：表示、存储、运算等"/>
          </outline>
          <outline text="7.1 文件的使用" collapsed="true">
            <outline text="文件的类型">
              <outline text="文件的理解" collapsed="true">
                <outline text="文件是数据的抽象和集合" _note="&#10;- 文件是存储在辅助存储器上的数据序列&#10;&#10;- 文件是数据存储的一种形式&#10;&#10;- 文件展现形态：文本文件和二进制文件&#10;&#10;"/>
                <outline text="文本文件 VS. 二进制文件" _note="&#10;- 文本文件和二进制文件只是文件的展示方式&#10;&#10;- 本质上， 所有文件都是二进制形式存储&#10;&#10;- 形式上，所有文件采用二种方式展示"/>
                <outline text="文本文件" _note="&#10;- 有单一特定编码组成的文件，如UTF-8编码&#10;&#10;- 由于存在编码，也被看成是存储着的长字符串&#10;&#10;- 适用于例如：.txt文件、.py文件等&#10;&#10;e.g.&#10;&#10;&gt;&gt;tf= open(&quot;D:/ex/f.txt&quot;,&quot;rt&quot;,encoding=&quot;utf-8&quot;)&#10;&#10;&gt;&gt;print(tf.readline())&#10;中国是个伟大的国家！&#10;&#10;&gt;&gt;tf.close()"/>
                <outline text="二进制文件" _note="&#10;- 直接由比特0和1组成，没有统一字符编码&#10;&#10;- 一般存在二进制0和1的组织结构，即文件格式&#10;&#10;- 适用于例如：.png文件、.avi文件等。&#10;&#10;e.g.&#10;&#10;&gt;&gt;bf= open(&quot;D:/ex/f.txt&quot;,&quot;rb&quot;)&#10;&#10;&gt;&gt;print(bf.readline())&#10;b&apos;\xe4\xb8\xad\xe5\x9b\xbd\xe6\x98\xaf\xe4\xb8\xaa\xe4\xbc\x9f\xe5\xa4\xa7\xe7\x9a\x84\xe5\x9b\xbd\xe5\xae\xb6\xef\xbc\x81&apos;&#10;&#10;&gt;&gt;bf.close()"/>
              </outline>
            </outline>
            <outline text="文件的打开和关闭 #检索练习 #重点 ">
              <outline text="文件处理的步骤：打开-操作-关闭"/>
              <outline text="读文件" _note="&#10;a.read(size)&#10;&#10;a.readline(size)&#10;&#10;a.readlines(hint)"/>
              <outline text="写文件" _note="&#10;a.write(s)&#10;&#10;a.writelines(lines)&#10;&#10;a.seek(offset)"/>
              <outline text="文件的打开" _note="&#10;&lt;变量名&gt; = open(&lt;文件名&gt;， &lt;打开模式&gt;)&#10;&#10;&#10;其中&#10;&#10;&lt;变量名&gt; 是文件句柄&#10;&#10;&lt;文件名&gt; 放文件路径和名称，源文件同目录（要读取的文件和py文件）可省路径。&#10;&#10;&lt;打开模式&gt; 一般写 文本 or 二进制 ， 读 or 写"/>
              <outline text="文件路径" _note="&#10;e.g.&#10;&#10;如果文件路径是 D:/PYE/f.txt&#10;&#10;则&lt;文件名&gt;写成&#10;&#10;“D://PYE/f.txt”                   &quot;./PYE/f.txt&quot;&#10;&#10;&quot;D:\\PYE\\f.txt&quot;                &quot;f.txt&quot;&#10;&#10;"/>
              <outline text="打开模式 #检索练习 " collapsed="true">
                <outline text="&apos;r&apos;" _note="&#10;只读模式，默认值，如果文件不存在，返回FileNotFoundError"/>
                <outline text="&apos;w&apos;" _note="&#10;覆盖写模式，文件不存在则创建，存在则完全覆盖"/>
                <outline text="&apos;x&apos;" _note="&#10;创建写模式，文件不存在则创建，存在则返回FileExistError"/>
                <outline text="&apos;a&apos;" _note="&#10;追加写模式，文件不存在则创建，存在则在文件最后追加内容"/>
                <outline text="&apos;b&apos;" _note="&#10;二进制文件模式"/>
                <outline text="&apos;t&apos;" _note="&#10;文本文件模式，默认值"/>
                <outline text="&apos;+&apos;" _note="&#10;与r/w/x/a一同使用，在原功能基础上增加同时读写功能&#10;"/>
                <outline text="举例">
                  <outline text="f = open(&quot;f.txt&quot;)" _note="&#10;- 文本形式、只读模式、默认值"/>
                  <outline text="f = open(&quot;f.txt&quot;, &quot;rt&quot;)" _note="&#10;- 文本形式、只读模式、同默认值"/>
                  <outline text="f = open(&quot;f.txt&quot;, &quot;w&quot;)" _note="&#10;- 文本形式、覆盖写模式"/>
                  <outline text="f = open(&quot;f.txt&quot;, &quot;a+&quot;)" _note="&#10;- 文本形式、追加写模式+读文件"/>
                  <outline text="f = open(&quot;f.txt&quot;, &quot;x&quot;)" _note="&#10;- 文本形式、创建写模式"/>
                  <outline text="f = open(&quot;f.txt&quot;, &quot;b&quot;)" _note="&#10;- 二进制形式、只读模式"/>
                  <outline text="f = open(&quot;f.txt&quot;, &quot;wb&quot;)" _note="&#10;- 二进制形式、覆盖写模式"/>
                </outline>
              </outline>
              <outline text="文件的关闭" _note="&#10;&lt;变量名&gt;.close()&#10;&#10;&#10;其中&lt;变量名&gt;是文件句柄"/>
              <outline text="文件使用">
                <outline text="文本形式打开文件" _note="&#10;e.g.&#10;&#10;tf= open(&quot;D:/ex/f.txt&quot;,&quot;rt&quot;)&#10;print(tf.readline())&#10;tf.close()"/>
                <outline text="二进制形式打开文件" _note="&#10;bf= open(&quot;D:/ex/f.txt&quot;,&quot;rb&quot;)&#10;print(bf.readline())&#10;bf.close()"/>
              </outline>
            </outline>
            <outline text="文件内容的读取  #重点 " collapsed="true">
              <outline text="读取文件内容的操作方法 #检索练习 ">
                <outline text="&lt;f&gt;.read(size=-1)" _note="&#10;读入全部内容， 如果给出参数，读入前size长度&#10;&#10;e.g.&#10;&#10;&gt;&gt; s = f.read(2)&#10;中国"/>
                <outline text="&lt;f&gt;.readline(size=-1)" _note="&#10;读入一行内容， 如果给出参数，读入该行前size长度&#10;&#10;e.g.&#10;&#10;&gt;&gt; s = f.readline()&#10;中国是一个伟大的国家！"/>
                <outline text="&lt;f&gt;.readlines(hint=-1)" _note="&#10;读入文件所有行， 以每行为元素形成列表&#10;&#10;如果给出参数，读入该前hint行&#10;&#10;e.g.&#10;&#10;&gt;&gt; s = f.readlines()&#10;[&apos;中国是一个伟大的国家！&apos;]"/>
              </outline>
              <outline text="文件的全文本操作 #检索练习 ">
                <outline text="遍历全文本： 方法一" _note="&#10;- 一次读入，统一处理&#10;&#10;&#10;e.g.&#10;&#10;```&#10;&#10;fname = input(&quot;请输入要打开的文件名称：&quot;)&#10;fo = open(fname, &quot;r&quot;)&#10;txt = fo.read(2)&#10;# 对全文本txt进行处理&#10;fo.close()&#10;```&#10;&#10;&#10;#  BianLiV1.py&#10;&#10;```&#10;fname = input(&quot;请输入要打开的文件名称：&quot;)&#10;fo = open(fname, &quot;r&quot;, encoding= &quot;utf-8&quot;)&#10;txt = fo.read(2)&#10;# 对全文本txt进行处理&#10;fo.close()&#10;```"/>
                <outline text="遍历全文本： 方法二" _note="&#10;&#10;- 按数量读入，逐步处理&#10;&#10;e.g.1&#10;&#10;```&#10;&#10;fname = input(&quot;请输入要打开的文件名称：&quot;)&#10;fo = open(fname, &quot;r&quot;)&#10;txt = fo.read(2)&#10;while txt != “”:&#10; # 对txt进行处理&#10;	 txt = fo.read(2)&#10;fo.close()&#10;```&#10;&#10;e.g.2&#10;```&#10;&#10;f# BianLiV2.py&#10;&#10;fname = input(&quot;请输入要打开的文件名称：&quot;)&#10;fo = open(fname, &quot;r&quot;, encoding= &quot;utf-8&quot;)&#10;txt = fo.read(2)&#10;while txt != &quot;&quot;:&#10; 	txt = fo.read(2);print(txt)    &#10;fo.close()&#10;&#10;```"/>
                <outline text="逐行遍历文件：方法一" _note="&#10;- 一次读入，分行处理&#10;&#10;```&#10;fname = input(&quot;请输入要打开的文件名称：&quot;)&#10;fo = open(fname, &quot;r&quot;)&#10;for line in fo.readlines():&#10; 	print(line)&#10;fo.close()&#10;```"/>
                <outline text="逐行遍历文件：方法二" _note="&#10;- 分行读入，逐行处理&#10;&#10;```&#10;&#10;name = input(&quot;请输入要打开的文件名称：&quot;)&#10;fo = open(fname,&quot;r&quot;,encoding=&quot;utf-8&quot;)&#10;for line in fo:&#10;    print(line)&#10;fo.close()&#10;```&#10;"/>
              </outline>
            </outline>
            <outline text="数据的文件写入  #重点 " collapsed="true">
              <outline text="&lt;f&gt;.write(s)" _note="&#10;向文件写入一个字符串或字节流&#10;&#10;```&#10;&#10;&gt;&gt; f.write(&quot;中国是一个伟大的国家！&quot;)&#10;&#10;```"/>
              <outline text="&lt;f&gt;.writelines(lines)" _note="&#10;将一个元素全为字符串的列表写入文件&#10;&#10;```&#10;&#10;&gt;&gt;ls=[&quot;中国&quot;,&quot;法国&quot;,&quot;美国&quot;]&#10;&gt;&gt;f.writelines(ls)&#10;中国法国美国&#10;&#10;```"/>
              <outline text="&lt;f&gt;.seek(offset)" _note="&#10;改变当前文件操作指针的位置，offset含义如下：&#10;0   文件开头&#10;1    当前位置&#10;2    文件结尾&#10;&#10;```&#10;&#10;&gt;&gt; f.seek(0)  #回到文件开头&#10;```&#10;e.g.&#10;```&#10;fo = open(&quot;output.txt&quot;,&quot;w+&quot;)&#10;ls =[&quot;中国&quot;,&quot;法国&quot;,&quot;美国&quot;]&#10;fo.writelines(ls)&#10;for line in fo:&#10;	print(line)&#10;fo.close()&#10;```&#10;&#10;结果无任何输出，因为指针到文件结尾&#10;&#10;```&#10;fo = open(&quot;output.txt&quot;,&quot;w+&quot;)&#10;ls =[&quot;中国&quot;,&quot;法国&quot;,&quot;美国&quot;]&#10;fo.writelines(ls)&#10;fo.seek(0)&#10;for line in fo:&#10;	print(line)&#10;fo.close()&#10;&#10;&gt;&gt;&gt;&gt;&#10;中国法国美国&#10;&#10;```"/>
            </outline>
          </outline>
          <outline text="7.2 实例11：自动轨迹绘制 #实例 " _note="&#10;学会根据文件里的数据绘制图形" collapsed="true">
            <outline text="问题分析" _note="&#10; 需求： 根据脚本来绘制图形？&#10;&#10;不通过写代码而通过写数据绘制轨迹&#10;&#10;数据脚本是自动化最重要的第一步&#10;&#10;"/>
            <outline text="基本思路" _note="&#10;步骤1：定义数据文件格式（接口）&#10;&#10;步骤2：编写程序，根据文件接口解析参数绘制图形&#10;&#10;步骤3： 编制数据文件"/>
            <outline text="数据接口定义" _note="&#10;&#10;300, 1, 144, 0, 1, 0&#10;&#10;300   行进距离&#10;&#10;1  转向判断，0是左转，1是右转&#10;&#10;144  转向角度&#10;&#10;0, 1, 0 RGB三个通道颜色 0-1之间浮点数 "/>
            <outline text="代码" _note="&#10;```&#10;#AutoTraceDraw.py&#10;import turtle as t&#10;t.title(&apos;自动轨迹绘制&apos;)&#10;t.setup(800,600,0,0)&#10;t.pencolor(&quot;red&quot;)&#10;t.pensize(5)&#10;# 数据读取&#10;datals = []&#10;f = open(&quot;data.txt&quot;)&#10;for line in f:&#10;	line = line.replace(&quot;\n&quot;,&quot;&quot;)    # 去掉空行&#10;	datals.append(list(map(eval, line.split(&quot;,&quot;))))&#10;f.close()&#10;# 自动绘制&#10;for i in range(len(datals)):&#10; 	t.pencolor(datals[i][3],datals[i][4],datals[i][5])&#10;	t.fd(datals[i][0])&#10; 	if datals[i][1]:&#10; 		t.right(datals[i][2])&#10;	else:&#10;  		t.left(datals[i][2])&#10;&#10;```&#10;  &#10;&#10;data.txt&#10;&#10;300,0,144,1,0,0&#10;300,0,144,0,1,0&#10;300,0,144,0,0,1&#10;300,0,144,1,1,0&#10;300,0,108,0,1,1&#10;184,0,72,1,0,1&#10;184,0,72,0,0,0&#10;184,0,72,0,0,0&#10;184,0,72,0,0,0&#10;184,1,72,1,0,1&#10;184,1,72,0,0,0&#10;184,1,72,0,0,0&#10;184,1,72,0,0,0&#10;184,1,72,0,0,0&#10;184,1,72,0,0,0&#10;184,1,720,0,0,0"/>
            <outline text="最小功能块">
              <outline text="读取txt文件，去空格，以逗号分隔，转化为列表" _note="&#10;&#10;```&#10;&#10;datals = []&#10;f = open(&quot;data.txt&quot;)&#10;for line in f:&#10;	line = line.replace(&quot;\n&quot;,&quot;&quot;) # 去掉空行&#10;	datals.append(list(map(eval, line.split(&quot;,&quot;))))&#10;f.close()&#10;```">
                <outline text=""/>
              </outline>
            </outline>
            <outline text="举一反三">
              <outline text="理解方法思维" _note="&#10;自动化思维： 数据和功能分离，数据驱动的自动运行&#10;&#10;接口化思维： 格式化设计接口，清晰明了&#10;&#10;二维数据应用： 应用维度组织数据，二维数据最常用"/>
              <outline text="应用问题的扩展" _note="&#10;扩展接口设计，增加更多控制接口&#10;&#10;扩展功能设计，增加弧形等更多功能&#10;&#10;扩展应用需求，发展自动轨迹绘制到动画绘制"/>
            </outline>
            <outline text="如何进一步提高python编程能力？" _note="&#10;第一步：学好python语法，即掌握非库功能，练好内功&#10;&#10;第二步：学好python领域，数据分析、Web开发、人工智能，找准了深入学&#10;&#10;第三步：学好计算机专业知识，构建“系统“是本领，需要专业计算机知识&#10;&#10;数据结构、算法、计算机网络、组成原理、操作系统、网络安全、体系结构、软件工程..."/>
          </outline>
          <outline text="7.3 一维数据的格式化和处理 #重点 " collapsed="true">
            <outline text="数据组织的维度">
              <outline text="从一个数据到一组数据" _note="&#10;一个数据表达一个含义&#10;&#10;一组数据表达一个或多个含义"/>
              <outline text="维度：一组数据的组织形式"/>
              <outline text="一维数据：由对等关系的有序或无序数据构成，采用线性方式组织" _note="&#10;对应列表、数据和集合等概念"/>
              <outline text="二维数据：由多个一维数据构成，是一维数据的组合形式" _note="&#10;表格是典型的二维数据，其中，表头是二维数据的一部分"/>
              <outline text="多维数据：由一维或多维数据在新维度上扩展形成" _note="&#10;比如不同年份的相同表格，就构成了多维数据"/>
              <outline text="高维数据：仅利用最基本的二元关系展示数据期间复杂结构" _note="&#10;比如字典里的键值对"/>
              <outline text="数据的操作周期" _note="&#10;数据存储 &lt;-&gt; 数据表示 &lt;-&gt; 数据操作&#10;&#10;存储格式        数据类型         操作方式"/>
            </outline>
            <outline text="一维数据的表示">
              <outline text="如果数据间有序：使用列表类型" _note="&#10;列表类型可以表达一维有序数据&#10;&#10;for循环可以遍历数据，进而对每个数据进行处理"/>
              <outline text="如果数据间无序：使用集合类型" _note="&#10;集合类型可以表达一维无序数据&#10;&#10;for循环可以遍历数据，进而对每个数据进行处理"/>
            </outline>
            <outline text="一维数据的存储">
              <outline text="存储方式一：空格分隔" _note="&#10;使用一个或多个空格分隔进行存储，不换行&#10;&#10;缺点：数据中不能存在空格"/>
              <outline text="存储方式二：逗号分隔" _note="&#10;使用英文半角逗号分隔数据进行存储，不换行&#10;&#10;缺点：数据中不能有英文逗号"/>
              <outline text="存储方式三：其他方式" _note="&#10;使用其他符号或符合组合分隔，建议采用特殊符号&#10;&#10;缺点：需要根据数据特点定义，通用性较差&#10;&#10;举例&#10;&#10;中国$美国$日本$德国$法国$英国$意大利"/>
            </outline>
            <outline text="一维数据的处理">
              <outline text="数据的处理：存储&lt;-&gt;表示" _note="&#10;将存储的数据读入程序&#10;&#10;将程序表示的数据写入文件"/>
              <outline text="一维数据的读入处理">
                <outline text="从空格分隔的文件中读入数据" _note="&#10;e.g.&#10;&#10;```&#10;&#10;中国 美国 日本 德国 法国 英国 意大利&#10;&#10;txt = open(fname).read()&#10;&#10;ls = txt.split()&#10;&#10;f.close()&#10;&#10;&#10;&gt;&gt;&gt;ls&#10;&#10;&#10;[&apos;中国&apos;, &apos;美国&apos;, &apos;日本&apos;, &apos;德国&apos;, &apos;法国&apos;, &apos;英国&apos;, &apos;意大利&apos; ]&#10;&#10;```"/>
                <outline text="从特殊符号分隔的文件中读入数据" _note="&#10;e.g.&#10;&#10;```&#10;&#10;中国$美国$日本$德国$法国$英国$意大利&#10;&#10;txt = open(fname).read()&#10;&#10;ls = txt.split(‘$’)&#10;&#10;f.close()&#10;&#10;&#10;&gt;&gt;&gt;ls&#10;&#10;[&apos;中国&apos;, &apos;美国&apos;, &apos;日本&apos;, &apos;德国&apos;, &apos;法国&apos;, &apos;英国&apos;, &apos;意大利&apos; ]&#10;&#10;```"/>
              </outline>
              <outline text="一维数据的写入处理">
                <outline text="从空格分隔方式将数据写入文件" _note="&#10;e.g.&#10;&#10;```&#10;&#10;ls = [&apos;中国&apos;, &apos;美国&apos;, &apos;日本‘]&#10;&#10;f = open(fname, &apos;w&apos;)&#10;&#10;f.write(&apos; &apos;.join(ls))&#10;&#10;f.close()&#10;```&#10;"/>
                <outline text="从特殊符号分隔的文件中读入数据" _note="&#10;e.g.&#10;&#10;```&#10;&#10;ls = [&apos;中国&apos;, &apos;美国&apos;, &apos;日本‘]&#10;&#10;f = open(fname, &apos;w&apos;)&#10;&#10;f.write(&apos;$&apos;.join(ls))&#10;&#10;f.close()&#10;&#10;```&#10;"/>
              </outline>
            </outline>
          </outline>
          <outline text="7.4 二维数据的格式化和处理 #重点 " collapsed="true">
            <outline text="二维数据的表示">
              <outline text="使用列表类型" _note="&#10;列表类型可以表达二维数据&#10;&#10;使用二维列表&#10;&#10;e.g.&#10;&#10;[[3.1398, 3.1349, 3.1376], &#10;  [3.1413, 3.1404, 3.1401]]&#10;&#10;使用两层for循环遍历每个元素&#10;&#10;外层列表中每个元素可以对应一行，也可以对应一列&#10;"/>
              <outline text="一二维数据的Python表示" _note="&#10;数据维度是数据的组织形式&#10;&#10;&#10;一维数据：列表和集合类型&#10;&#10;[3.1398, 3.1349, 3.1376]  数据间有序&#10;&#10;{3.1398, 3.1349, 3.1376}  数据间无序&#10;&#10;二维数据：列表类型&#10;&#10;e.g.&#10;&#10;[[3.1398, 3.1349, 3.1376], &#10; [3.1413, 3.1404, 3.1401]]"/>
            </outline>
            <outline text="CSV格式和二维数据存储">
              <outline text="CSV数据存储格式" _note="&#10;CSV: Common-Separated Values&#10;&#10;国际通用的一二位数据存储格式，一般.csv扩展名&#10;&#10;每行一个一维数据维度，采用逗号分隔，无空行&#10;&#10;Excel和一般编辑软件都可以读入或另存为csv文件&#10;&#10;如果某个元素缺失，逗号仍然要保留&#10;&#10;二维数据的表头可以作为数据存储，也可以另行存储&#10;&#10;逗号为英文半角逗号，逗号与数据之间无额外空格&#10;&#10;e.g.&#10;&#10;城市,环比,同比,定基&#10;&#10;北京,101.5,120.7,121.4&#10;&#10;上海,101.2,127.3,127.8&#10;&#10;广州,101.3,119.4,120.0"/>
              <outline text="二维数据的存储" _note="&#10;按行存货按列存都可以，具体由程序决定&#10;&#10;一般索引习惯： ls[row][column]，先行后列&#10;&#10;根据一般习惯，外层列表每个元素是一行，按行存"/>
            </outline>
            <outline text="二维数据的处理">
              <outline text="二维数据的读入处理" _note="&#10;从CSV格式的文件中读入数据&#10;&#10;e.g.&#10;&#10;```&#10;&#10;fo = open(fname)&#10;ls = []&#10;for line in fo:&#10;    line = line.replace(&quot;\n&quot;,&quot;&quot;)&#10;    ls.append(line.split(&quot;,&quot;))&#10;fo.close()&#10;&#10;```&#10;&#10;&#10;&#10;"/>
              <outline text="二维数据的写入处理" _note="&#10;将数据写入CSV格式的文件&#10;&#10;```&#10;&#10;ls = [[], [], []]&#10;f = open(&apos;fname.csv&apos;, &apos;w&apos;)&#10;for item in ls:&#10;    f.write(&apos;,&apos;.join(item) + &apos;\n&apos;)&#10;f.close()&#10;```&#10;"/>
              <outline text="二维数据的逐一处理" _note="&#10;采用二层循环&#10;&#10;```&#10;&#10;ls = [[1,2], [3,4], [5,6]]&#10;for row in ls:&#10;    for column in row:&#10;        print(column)&#10;&#10;```"/>
            </outline>
          </outline>
          <outline text="7.5 模块：wordcloud库的使用 #模块 " collapsed="true">
            <outline text="wordcloud库基本介绍">
              <outline text="wordcloud库概述" _note="&#10;wordcloud是优秀的词云展示第三方库&#10;&#10;词云以词语为基本单位，更加直观和艺术地展示文本"/>
              <outline text="wordcloud库的安装" _note="&#10;cmd命令行&#10;&#10;pip install wordcloud"/>
              <outline text="wordcloud库使用说明">
                <outline text="wordcloud库基本使用" _note="&#10;wordcloud库把词云当做一个WordCloud对象&#10;&#10;wordcloud.WordCloud()代表一个文本对应的词云&#10;&#10;可以根据文本中词语出现的频率等参数绘制词云&#10;&#10;词云的绘制形状、尺寸和颜色都可以设定"/>
                <outline text="wordcloud库常规方法 #重点 " _note="&#10;w = wordcloud.WordCloud()&#10;&#10;以WordCloud对象为基础&#10;&#10;配置参数、加载文本、输出文件">
                  <outline text="w.generate(txt) " _note="&#10;向WordCloud对象w中加载文本txt&#10;&#10;```&#10;&#10;&gt;&gt;w.generate(&quot;Python and wordCloud&quot;)&#10;&#10;```"/>
                  <outline text="w.to_file(filename) " _note="&#10;将词云输出为图像文件，.png或.jpg格式&#10;&#10;```&#10;&#10;&gt;&gt;w.to_file(&quot;outfile.png&quot;)&#10;&#10;```"/>
                  <outline text="使用步骤  " _note="&#10;```&#10;import wordcloud&#10;&#10;c = wordcloud.WordCloud()                           # 步骤1：配置对象参数&#10;&#10;c.generate(&quot;wordcloud by Python&quot;)             # 步骤2：加载词云文本&#10;&#10;c.to_file(&quot;pywordcloud.png&quot;)                          # 步骤3：输出词云文件&#10;&#10;````"/>
                  <outline text="具体原理" _note="&#10;1. 分隔：以空格分隔单词&#10;&#10;2. 统计：单词出现次数并过滤&#10;&#10;3. 字体：根据统计配置字号&#10;&#10;4. 布局：颜色环境尺寸"/>
                  <outline text="配置对象参数 #检索练习 " _note="&#10;w = wordcloud.WordCloud(&lt;参数&gt;)" collapsed="true">
                    <outline text="width" _note="&#10;指定词云对象生成图片的宽度，默认400像素&#10;&#10;```&#10;&#10;&gt;&gt;w = wordcloud.WordCloud(width = 600) &#10;&#10;```"/>
                    <outline text="height" _note="&#10;指定词云对象生成图片的高度，默认200像素&#10;&#10;```&#10;&#10;&gt;&gt;w = wordcloud.WordCloud(height = 400) &#10;&#10;```"/>
                    <outline text="min_font_size" _note="&#10;指定词云中字体的最小字号，默认4号&#10;&#10;```&#10;&#10;&gt;&gt;w = wordcloud.WordCloud(min_font_size=10)&#10;&#10;```"/>
                    <outline text="max_font_size" _note="&#10;指定词云中字体的最大字号，根据高度自动调节&#10;&#10;```&#10;&#10;&gt;&gt;w = wordcloud.WordCloud(max_font_size=20)&#10;```"/>
                    <outline text="font_step" _note="&#10;指定词云中字体字号的步进间隔，默认为1&#10;&#10;```&#10;&gt;&gt;w = wordcloud.WordCloud(font_step = 2)&#10;```"/>
                    <outline text="font_path" _note="&#10;指定文体文件的路径，默认None&#10;```&#10;&#10;&gt;&gt;w=wordcloud.WordCloud(font_path = &quot;msyh.ttc&quot;)&#10;```"/>
                    <outline text="max_words" _note="&#10;指定词云显示的最大单词数量，默认200&#10;```&#10;&#10;&gt;&gt;w = wordcloud.WordCloud(max_words=20)&#10;&#10;```"/>
                    <outline text="stop_words" _note="&#10;指定词云的排除词列表，即不显示的单词列表&#10;&#10;```&#10;&#10;&gt;&gt;&gt;w = wordcloud.WordCloud(stop_words={&quot;Python&quot;})&#10;```"/>
                    <outline text="mask" _note="&#10;指定词云形状，默认为长方形，需要引用imread()函数&#10;&#10;```&#10;&#10;&gt;&gt;from scipy.misc import imread&#10;&gt;&gt;mk = imread(&quot;pic.png&quot;)&#10;&gt;&gt;w = wordcloud.WordCloud(mask=mk)&#10;&#10;```"/>
                    <outline text="background_color" _note="&#10;指定词云图片的背景颜色，默认为黑色&#10;```&#10;&#10;&gt;&gt; w= wordcloud.WordCloud(background_color=&quot;white&quot;)&#10;```"/>
                  </outline>
                  <outline text="wordcloud应用实例 #实例 " collapsed="true">
                    <outline text="英文词云实例" _note="&#10;```&#10;import wordcloud&#10;txt = &quot;life is short, you need python.&quot;&#10;w = wordcloud.WordCloud(\&#10;        background_color= &quot;white&quot;)&#10;w.generate(txt)&#10;w.to_file(&quot;pywcloud.png&quot;)&#10;&#10;```"/>
                    <outline text="中文词云实例" _note="&#10;中文需要先分词并组成空格分隔字符串&#10;&#10;```&#10;&#10;import jieba&#10;import wordcloud&#10;txt = &quot;程序设计语言是计算机能够理解和\&#10;    识别用户操作意图的一种交互体系，它按照\&#10;    特定规则组织计算机指令，使计算机能够自\&#10;    动进行各种运算处理。&quot;&#10;w = wordcloud.WordCloud( width = 1000,\&#10;    font_path=&quot;msyh.ttc&quot;, height = 700)&#10;w.generate(&quot; &quot;.join(jieba.lcut(txt)))&#10;w.to_file(&quot;pywcloud.png&quot;)&#10;&#10;```"/>
                  </outline>
                </outline>
              </outline>
            </outline>
          </outline>
          <outline text="7.6实例12：政府工作报告词云 #实例 " collapsed="true">
            <outline text="问题分析" _note="&#10;需求：对于政府工作报告等政策文件，如何直观理解？&#10;&#10;体会直观的价值：生成词云 &amp; 优化词云&#10;&#10;政府工作报告等文件 → 有效展示的词云&#10;&#10;"/>
            <outline text="基本思路" _note="&#10;步骤1：读取文件、分词整理&#10;&#10;步骤2：设置并输出词云&#10;&#10;步骤3：观察结果，优化迭代"/>
            <outline text="实例代码V1" _note="&#10;```&#10;#GovRptWorldCloudv1&#10;import jieba&#10;import wordcloud&#10;f = open(&quot;新时代中国特色社会主义.txt&quot;,&quot;r&quot;,encoding = &quot;utf-8&quot;)&#10;t = f.read()&#10;f.close()&#10;ls = jieba.lcut(t)&#10;txt = &quot; &quot;.join(ls)&#10;w = wordcloud.WordCloud( font_path= &quot;msyh.ttc&quot;,\&#10;    width = 1000, height= 700, background_color= &quot;white&quot;,\&#10;    )&#10;w.generate(txt)&#10;w.to_file(&quot;grworldcloud.png&quot;)&#10; ```   "/>
            <outline text="制作更有形的词云" _note="&#10;比如五角星、树形等png图片形状的词云&#10;&#10;```&#10;&#10;#GovRptWorldCloudv1&#10;import jieba&#10;import wordcloud&#10;from imageio import imread&#10;mask = imread(&quot;tree.png&quot;)&#10;f = open(&quot;关于实施乡村振兴战略的意见.txt&quot;,&quot;r&quot;,encoding = &quot;utf-8&quot;)&#10;t = f.read()&#10;f.close()&#10;ls = jieba.lcut(t)&#10;txt = &quot; &quot;.join(ls)&#10;w = wordcloud.WordCloud( font_path= &quot;msyh.ttc&quot;, mask= mask,\&#10;    width = 1000, height= 700, background_color= &quot;white&quot;,\&#10;    )&#10;w.generate(txt)&#10;w.to_file(&quot;grworldcloud.png&quot;)&#10;&#10;```&#10;&#10;&#10;注意：&#10;&#10;1.QQ截图直接保存就是png图片。&#10;&#10;2. 图片要有轮廓，有轮廓容易形成有形的词云。&#10;&#10;3. 可以在PPT里制作形状，再QQ截图。"/>
            <outline text="举一反三" _note="&#10;扩展能力&#10;&#10;- 了解wordcloud更多参数，扩展词云能力。&#10;&#10;- 特色词云：设计一款属于自己的特色词云风格。&#10;&#10;- 更多文件：用更多文件联系词云生成。"/>
          </outline>
        </outline>
        <outline text="第8周：程序设计方法学 #编程思维" collapsed="true">
          <outline text="8.1 实例13：体育竞技分析 #实例 ">
            <outline text="问题分析" collapsed="true">
              <outline text="需求和输入输出" _note="&#10;&#10;需求：高手过招，胜负只在毫厘之间，那么毫厘是多少？如何科学分析体育竞技比赛？&#10;&#10;输入：球员的水平&#10;&#10;输出：可预测的比赛成绩"/>
              <outline text="模拟N场比赛" _note="&#10;计算思维：抽象 + 自动化&#10;&#10;模拟：抽象比赛过程 + 自动化执行N场比赛&#10;&#10;当N越大时，比赛结果分析会越科学"/>
              <outline text="比赛规则" _note="&#10;双人击球比赛： A &amp; B，回合制， 5局3胜&#10;&#10;开始时一方先发球，直到判分，接下来胜者发球&#10;&#10;球员只能在发球局得分，15分胜一局"/>
            </outline>
            <outline text="自顶向下和自底向上" collapsed="true">
              <outline text="自顶向下" _note="&#10;解决复杂问题的有效方法，适用于设计&#10;&#10;- 将一个总问题表达为若干个小问题里组成的形式&#10;&#10;- 使用同样方法进一步分解为小问题&#10;&#10;- 直至，小问题可以用计算机简单明了的解决&#10;"/>
              <outline text="自底向上" _note="&#10;逐步组建复杂系统的有效测试方法， 适用于执行&#10;&#10;- 分单元测试，逐步组装&#10;&#10;- 按照自顶向下相反的路径操作&#10;&#10;- 直至，系统各部分以组装的思路都经过测试和验证"/>
            </outline>
            <outline text="“体育竞技分析”实例讲解" collapsed="true">
              <outline text="程序总体框架及步骤" _note="&#10;步骤1：打印程序的介绍性信息                                             printinfo()&#10;&#10;步骤2：获得程序运行参数：proA, proB, n                       getinputs()&#10;&#10;步骤3： 利用球员A和B的能力值，模拟n局比赛            simNGames()&#10;&#10;步骤4：输出球员A和B获胜比赛的场次及概率               printSummary()">
                <outline text="第一阶段 步骤1 和步骤2">
                  <outline text="main()" _note="&#10;def main():&#10;&#10; printIntro()&#10;&#10; probA, probB, n = getInputs()&#10;&#10; winsA, winsB = simNGames(n, probA, probB)&#10;&#10; printSummary(winsA, winsB)"/>
                  <outline text="printIntro()" _note="&#10;def printIntro():&#10; &#10; print(&quot;这个程序模拟两个选手A和B的某种竞技比赛&quot;)&#10;&#10; print(&quot;程序运行需要A和B的能力值（以0到1之间的小数表示）&quot;)"/>
                  <outline text="getInputs()" _note="&#10;def getInputs():&#10; a = eval(input(&quot;请输入选手A的能力值（0-1）：&quot;))&#10; &#10; b = eval(input(&quot;请输入选手B的能力值（0-1）：&quot;))&#10; &#10; n = eval(input(&quot;模拟比赛的场次：&quot;))&#10;&#10; return a, b, n"/>
                  <outline text="printSummary()" _note="&#10;def printSummary(winsA, winsB):&#10; &#10; n = winsA + winsB&#10;&#10; print(&quot;竞技分析开始，并模拟{}场比赛&quot;.format(n))&#10;&#10; print(&quot;选手A获胜{}场比赛， 占比{:0.1%}&quot;.format(winsA, winsA/n))&#10;&#10; print(&quot;选手B获胜{}场比赛，占比{: 0.1%}&quot;.format(winsB, winsB/n))"/>
                </outline>
                <outline text="第二阶段 步骤3 模拟N场比赛" _note="&#10;&#10;def simNGames(n, proA, proB):&#10; &#10; winsA, winsB = 0, 0&#10;&#10; for i in range(n):&#10;  &#10;  scoresA, scoresB = simOneGame(proA, proB)&#10;&#10;  if scoresA &gt; scoresB:&#10;   &#10;   winsA +=1&#10;  &#10;  else:&#10;   winsB +=1&#10;&#10; return winsA, winsB"/>
                <outline text="第三阶段  根据分数判断局的结束" _note="&#10;def simOneGame(proA, proB):&#10; &#10; scoresA, scoresB = 0, 0&#10;&#10; serving = &quot;A&quot;&#10;&#10; while not gameOver(scoresA, scoresB):&#10;  &#10;  if serving == &quot;A&quot;:&#10;   &#10;   if random() &lt; proA:&#10;&#10;    scoresA += 1&#10;&#10;   else:&#10;    serving = &quot;B&quot;&#10;&#10;  else:&#10;&#10;   if random() &lt; proB:&#10;&#10;    scoresB += 1&#10;   &#10;   else: &#10;&#10;    serving = &quot;A&quot;&#10;&#10; return scoresA, scoresB"/>
              </outline>
              <outline text="所有代码" _note="&#10;#MatchAnalysis.py&#10;&#10;from random import random&#10;&#10;def printIntro():&#10;    &#10;    print(&quot;这个程序模拟两个选手A和B的某种竞技比赛&quot;)&#10;&#10;    print(&quot;程序运行需要A和B的能力值（以0到1之间的小数表示）&quot;)&#10;&#10;&#10;def getInputs():&#10;    a = eval(input(&quot;请输入选手A的能力值（0-1）：&quot;))&#10;    &#10;    b = eval(input(&quot;请输入选手B的能力值（0-1）：&quot;))&#10;    &#10;    n = eval(input(&quot;模拟比赛的场次：&quot;))&#10;&#10;    return a, b, n&#10;&#10;def simNGames(n, proA, proB):&#10;    &#10;    winsA, winsB = 0, 0&#10;&#10;    for i in range(n):&#10;        &#10;        scoresA, scoresB = simOneGame(proA, proB)&#10;&#10;        if scoresA &gt; scoresB:&#10;            &#10;            winsA +=1&#10;        &#10;        else:&#10;            winsB +=1&#10;&#10;    return winsA, winsB&#10;&#10;def gameOver(a, b):&#10;    return a == 15 or b == 15&#10;&#10;&#10;def simOneGame(proA, proB):&#10;    &#10;    scoresA, scoresB = 0, 0&#10;&#10;    serving = &quot;A&quot;&#10;&#10;    while not gameOver(scoresA, scoresB):&#10;        &#10;        if serving == &quot;A&quot;:&#10;            &#10;            if random() &lt; proA:&#10;&#10;                scoresA += 1&#10;&#10;            else:&#10;                serving = &quot;B&quot;&#10;&#10;        else:&#10;&#10;            if random() &lt; proB:&#10;&#10;                scoresB += 1&#10;            &#10;            else: &#10;&#10;                serving = &quot;A&quot;&#10;&#10;    return scoresA, scoresB&#10;&#10;&#10;&#10;def printSummary(winsA, winsB):&#10;    &#10;    n = winsA + winsB&#10;&#10;    print(&quot;竞技分析开始，并模拟{}场比赛&quot;.format(n))&#10;&#10;    print(&quot;选手A获胜{}场比赛， 占比{:0.1%}&quot;.format(winsA, winsA/n))&#10;&#10;    print(&quot;选手B获胜{}场比赛，占比{: 0.1%}&quot;.format(winsB, winsB/n))&#10;&#10;def main():&#10;&#10;    printIntro()&#10;&#10;    probA, probB, n = getInputs()&#10;&#10;    winsA, winsB = simNGames(n, probA, probB)&#10;&#10;    printSummary(winsA, winsB)&#10;&#10;main()&#10;&#10;"/>
              <outline text="举一反三">
                <outline text="理解自顶向下和自底向上" _note="&#10;理解自顶向下的设计思维：分而治之&#10;&#10;理解自底向上的执行思维：模块化集成&#10;&#10;自顶向下是“系统”思维的简化"/>
                <outline text="应用问题的扩展" _note="&#10;- 扩展比赛参数，增加对更多能力对比情况的判断&#10;&#10;- 扩展比赛设计，增加对真实比赛结果的预测&#10;&#10;- 扩展分析逻辑，反向推理，用胜率推算能力？"/>
              </outline>
            </outline>
          </outline>
          <outline text="8.2 Python程序设计思想" collapsed="true">
            <outline text="计算思维与程序设计" collapsed="true">
              <outline text="计算思维：第3种人类思维特征" _note="&#10;逻辑思维： 推理和演绎，数学为代表， A -&gt; B  B-&gt;C → A -&gt; C&#10;&#10;实证思维： 实验和验证，物理为代表，引力波&lt;- 实验&#10;&#10;计算思维：设计和构造，计算机为代表，汉诺塔递归"/>
              <outline text="计算思维：抽象和自动化" _note="&#10;计算思维： Computational Thinking&#10;&#10;抽象问题的计算过程， 利用计算机自动化求解&#10;&#10;计算思维是基于计算机的思维方式"/>
              <outline text="计算思维举例" _note="&#10;计数求和： 计算0-100的计数和&#10;&#10;逻辑思维： S = （a1 + an)*n/2&#10;&#10;计算思维： &#10;&#10;s = 0&#10;&#10;for i in range(1, 101):&#10; s += i"/>
              <outline text="计算思维：抽象问题的计算过程，利用计算机自动化求解" _note="&#10;计算思维基于计算机强大的算力及海量数据&#10;&#10;抽象计算过程， 关注设计和构造，而非因果&#10;&#10;以计算机程序设计为实现的主要手段"/>
              <outline text="计算思维与程序设计：编程是将计算思维变成现实的手段" _note="&#10;"/>
            </outline>
            <outline text="计算生态与Python语言" collapsed="true">
              <outline text="开源思想深入演化和发展，形成了计算生态"/>
              <outline text="计算生态没有顶层设计，以功能为单位，有三个特点" _note="&#10;- 竞争发展&#10;&#10;- 相互依存&#10;&#10;- 迅速更迭"/>
              <outline text="计算生态的运用" _note="&#10;从刀耕火种到站在巨人肩膀上&#10;&#10;- 编程的起点不是算法而是系统&#10;&#10;- 编程如同搭积木，利用计算生态为主要模式&#10;&#10;- 编程的目标是快速解决问题"/>
            </outline>
            <outline text="用户体验与软件产品" collapsed="true">
              <outline text="用户体验" _note="&#10;实现功能 -&gt; 关注体验&#10;&#10;- 用户体验是指用户对产品建立的主观感受和认识&#10;&#10;- 关心功能实现，更要关心用户体验，才能做出好产品&#10;&#10;- 编程只是手段， 不是目的，程序最终为人类服务"/>
              <outline text="提高用户体验的方法" collapsed="true">
                <outline text="方法1： 进度展示" _note="&#10;- 如果程序需要计算时间，可能产生等待，请增加进度展示&#10;&#10;- 如果程序有若干步骤，需要提示用户，请增加进度展示&#10;&#10;- 如果程序可能存在大量次数的循环，请增加进度展示"/>
                <outline text="方法2：异常处理" _note="&#10;- 当获得用户输入，对合规性需要检查，需要异常处理&#10;&#10;- 当读写文件时，对结果进行判断，需要异常处理&#10;&#10;- 当进行输入输出时，对运算结果进行判断，需要异常处理"/>
                <outline text="其他类方法" _note="&#10;- 打印输出： 特定位置，输出程序运行的过程信息&#10;&#10;- 日志文件：对程序异常及用户使用进行定期记录&#10;&#10;- 帮助信息：给用户多种方式提供帮助信息"/>
              </outline>
              <outline text="软件程序 -&gt; 软件产品" _note="&#10;用户体验是程序到产品的关键环节"/>
            </outline>
            <outline text="基本的程序设计模式">
              <outline text="从IPO开始" _note="&#10;I ：Input输入，程序的输入&#10;&#10;P ：Process处理，程序的主要逻辑&#10;&#10;O：Output输出，程序的输出&#10;&#10;&#10;确定IPO：明确计算部分及功能边界&#10;&#10;编写程序：将计算求解的设计变成现实&#10;&#10;调试程序：确定程序按照正确逻辑能够正确运行"/>
              <outline text="自顶向下设计"/>
              <outline text="模块化设计" _note="&#10;通过函数或对象封装将程序划分为模块及模块间的表达&#10;&#10;具体包括：主程序、子程序和子程序间关系&#10;&#10;分而治之：一种分而治之、分层抽象、体系化的设计思想&#10;&#10;&#10;紧耦合：两个部分之间交流很多，无法独立存在&#10;&#10;松耦合：两个部分之间交流很少，可以独立存在&#10;&#10;模块内部紧耦合，模块之间松耦合"/>
              <outline text="配置化设计" _note="&#10;程序引擎 + 配置文件&#10;&#10;引擎 + 配置： 程序执行和配置分离，将可选参数配置化&#10;&#10;将程序开发变成配置文件编写，扩展功能而不能修改程序&#10;&#10;关键在于接口设计，清晰明了，灵活可扩展"/>
              <outline text="应用开发">
                <outline text="应用开发的四个步骤" _note="&#10;从应用需求到软件产品">
                  <outline text="产品定义" _note="&#10;对应用需求充分理解和明确定义&#10;&#10;产品定义，而不仅是功能定义，要考虑商业模式&#10;"/>
                  <outline text="系统架构" _note="&#10;以系统方式思考产品的技术实现&#10;&#10;系统架构，关注数据流、模块化、体系架构"/>
                  <outline text="设计与实现" _note="&#10;结合架构完成关键设计及系统实现&#10;&#10;结合扩展性、灵活性等进行设计优化"/>
                  <outline text="用户体验" _note="&#10;从用户角度思考应用效果&#10;&#10;用户至上，体验优先，以用户为中心"/>
                </outline>
              </outline>
            </outline>
          </outline>
          <outline text="8.3 Python第三方库安装" collapsed="true">
            <outline text="看见更大的Python世界" collapsed="true">
              <outline text="第三方库  pypi.org/" _note="&#10;13万个第三方库&#10;&#10;PyPI： Python Package Index&#10;&#10;PSF维护的展示全球Python计算生态的主战&#10;&#10;学习检索并应用PyPI，找到合适的第三方库开放程序&#10;&#10;实例： 开放与区块链相关的程序&#10;&#10;第1步：在pypi.org搜索blockchain&#10;&#10;第2步：挑选适合开放目标的第三方库作为基础&#10;&#10;第3步：完成自己需要的功能&#10;&#10;&#10;"/>
            </outline>
            <outline text="第三方库的pip安装方法" _note="&#10;&#10;安装第三方库的主要方法，适合99%的情况&#10;&#10;需要联网安装" collapsed="true">
              <outline text="pip -h   " _note="&#10; 打开pip的帮助命令&#10;&#10;使用pip安装工具（命令行下执行）"/>
              <outline text="pip install &lt;第三方库名&gt;" _note="&#10;安装指定的第三方库"/>
              <outline text="pip install -U &lt;第三方库名&gt;" _note="&#10;使用-U标签更新已安装的指定第三方库"/>
              <outline text="pip uninstall &lt;第三方库名&gt;" _note="&#10;卸载指定的第三方库"/>
              <outline text="pip download &lt;第三方库名&gt;" _note="&#10;下载但不安装指定的第三方库"/>
              <outline text="pip show &lt;第三方库名&gt;" _note="&#10;列出某个指定第三方库的详细信息"/>
              <outline text="pip search &lt;第三方库名&gt;" _note="&#10;根据关键词在名称和介绍中搜索第三方库"/>
              <outline text="pip list" _note="&#10;列出当前系统已经安装的第三方库"/>
            </outline>
            <outline text="第三方库的集成安装方法" collapsed="true">
              <outline text="集成安装：结合特定Python开发工具的批量安装"/>
              <outline text="Anaconda" _note="&#10;www.continuum.io&#10;&#10;支持近800个第三方库&#10;&#10;包含多个主流工具&#10;&#10;适合数据计算领域开放&#10;&#10;&#10;"/>
            </outline>
            <outline text="第三方库的文件安装方法" collapsed="true">
              <outline text="为什么有些第三方库用pip可以下载，但无法安装？" _note="&#10;某些第三方库pip下载后，需要编译再安装&#10;&#10;如果操作系统没有编译环境，则能下载但不能安装&#10;&#10;可以直接下载编译后的版本用于安装吗？"/>
              <outline text="网站" _note="&#10;www.lfd.uci.edu/~gohlke/pythonlibs/&#10;&#10;打开的是UCI界面"/>
              <outline text="文件安装方法" _note="&#10;实例： 安装wordcloud库&#10;&#10;步骤1：在UCI页面上搜索wordcloud (在网页上ctrl +F，输入wordcloud)&#10;&#10;步骤2：下载对应版本的文件&#10;&#10;步骤3： 使用pip install &lt;文件名&gt; 安装&#10;&#10;"/>
            </outline>
          </outline>
          <outline text="8.4 模块：os库的基本使用 #模块 ">
            <outline text="os库基本介绍" _note="&#10;os库提供通用的、基本的操作系统交互功能&#10;&#10;os库是Python标准库，包含几百个函数&#10;&#10;常用路径操作、进程管理、环境参数等几类&#10;&#10;&#10;"/>
            <outline text="路径操作" _note="&#10;os.path字库，处理文件路径及信息" collapsed="true">
              <outline text="os.path字库以path为入口，用于操作和处理文件路径" _note="&#10;import os.path&#10;&#10;&#10;import os.path as op"/>
              <outline text="os.path.abspath(path)" _note="&#10;返回path在当前系统中的绝对路径&#10;&#10;```&#10;&#10;&gt;&gt;os.path.abspath(&quot;file.txt&quot;)&#10;&apos;C:\\Users\\23645\\file.txt&apos;&#10;```"/>
              <outline text="os.path.normpath(path)" _note="&#10;归一化path的表示形式，统一用\\分隔路径&#10;&#10;```&#10;&#10;&gt;&gt;os.path.normpath(&quot;D://ex//file.txt&quot;)&#10;&apos;D:\\ex\\file.txt&apos;&#10;```"/>
              <outline text="os.path.relpath(path)" _note="&#10;返回当前程序与文件之间的相对路径（relative path）&#10;&#10;```&#10;&#10;&gt;&gt;os.path.relpath(&quot;C://ex//file.txt&quot;)             #必须从C盘开始&#10;&apos;..\\..\\ex\\file.txt&apos;&#10;```"/>
              <outline text="os.path.dirname(path)" _note="&#10;返回path中的目录名称&#10;&#10;```&#10;&#10;&gt;&gt;os.path.dirname(&quot;D://ex//file.txt&quot;)&#10;&apos;D://ex&apos;&#10;&#10;```"/>
              <outline text="os.path.basename(path)" _note="&#10;返回文件中最后的文件名称&#10;&#10;```&#10;&#10;&gt;&gt;os.path.basename(&quot;D://ex//file.txt&quot;)&#10;&apos;file.txt&apos;&#10;&#10;```"/>
              <outline text="os.path.join(path, *paths)" _note="&#10;组合path与paths，返回一个路径字符串&#10;&#10;```&#10;&#10;&gt;&gt;os.path.join(&quot;D:/&quot;, &quot;ex/file.txt&quot;)&#10;&apos;D:/ex/file.txt&apos;&#10;```"/>
              <outline text="os.path.exists(path)" _note="&#10;判断path对应文件或目录是否存在，返回True或False&#10;&#10;```&#10;&#10;&gt;&gt;os.path.exists(&quot;D://ex//file.txt&quot;)&#10;True&#10;```"/>
              <outline text="os.path.isfile(path)" _note="&#10;判断path所对应是否为已存在的文件，返回True或False&#10;&#10;```&#10;&#10;&gt;&gt;os.path.isfile(&quot;D://ex//file.txt&quot;)&#10;True&#10;```"/>
              <outline text="os.path.isdir(path)" _note="&#10;判断path所对应是否为已存在的目录，返回True或False&#10;&#10;```&#10;&#10;&gt;&gt;os.path.isdir(&quot;D://ex//file.txt&quot;)&#10;False&#10;&#10;&gt;&gt;os.path.isdir(&quot;D://ex//&quot;)&#10;True&#10;```"/>
              <outline text="os.path.getatime(path)" _note="&#10;返回path对应文件或目录上一次的访问时间&#10;&#10;```&#10;&#10;&gt;&gt;os.path.getatime(&quot;D://ex//file.txt&quot;)&#10;1602309935.6704652&#10;&#10;```"/>
              <outline text="os.path.getmtime(path)" _note="&#10;返回path对应文件或目录最近一次的修改时间&#10;&#10;```&#10;&#10;&gt;&gt;os.path.getmtime(&quot;D://ex//file.txt&quot;)&#10;1602309935.6704652&#10;```"/>
              <outline text="os.path.getctime(path)" _note="&#10;返回path对应文件或目录的创建时间&#10;&#10;```&#10;&#10;&gt;&gt;time.ctime(os.path.getctime(&quot;D://ex//file.txt&quot;))&#10;&apos;Sat Oct 10 14:05:35 2020&apos;&#10;```"/>
              <outline text="os.path.getsize(path)" _note="&#10;返回path对应文件的大小，以字节为单位&#10;&#10;```&#10;&#10;&gt;&gt;os.path.getsize(&quot;D://ex//file.txt&quot;)&#10;0&#10;&#10;&gt;&gt;os.path.getsize(&quot;D://ex//threekingdoms.txt&quot;)&#10;1767825&#10;&#10;```&#10;"/>
              <outline text="os.listdir(dir)" _note="&#10;获取指定目录下的所有子目录和文件名&#10;"/>
              <outline text="os.rename(原文件名，新文件名)" _note="&#10;对文件或目录改名"/>
            </outline>
            <outline text="进程管理：启动系统中其他程序" _note="&#10;os.system(command)&#10;&#10;执行程序或命令command&#10;&#10;在Windows系统中，返回值为cmd的调用返回信息">
              <outline text="实例：打开程序 #实例 " _note="&#10;import os&#10;&#10;os.system(&quot;D:\\soft\\typora\\typora.exe&quot;)&#10;&#10;&gt;&gt;&gt;&#10;0"/>
              <outline text="实例：打开图片 #实例 " _note="&#10;import os&#10;&#10;os.system(&quot;D:\\ex\\fivestar.jpg&quot;)"/>
              <outline text="os库之环境参数">
                <outline text="os.chdir(path)" _note="&#10;修改某些当前程序操作的路径&#10;&#10;&gt;&gt;os.chdir(&quot;D:&quot;)"/>
                <outline text="os.getcwd()" _note="&#10;返回程序的当前路径&#10;&#10;&gt;&gt;os.getcwd()&#10; &apos;D:\\&apos;"/>
                <outline text="os.getlogin()" _note="&#10;获得当前系统登录用户名称&#10;&#10;&gt;&gt;os.getlogin()&#10;&apos;23645&apos;&#10;"/>
                <outline text="os.cpu_count()" _note="&#10;获得当前系统的CPU数量&#10;&#10;&gt;&gt;os.cpu_count()&#10;8"/>
                <outline text="os.urandom(n)" _note="&#10;获得n个字符长度的随机字符串，通常用于加解密运算&#10;&#10;&gt;&gt;os.urandom(10)&#10;b&apos; J\x8b\x8d\x9c\xeb\xb4E\x12_&apos;&#10;"/>
              </outline>
            </outline>
            <outline text="环境参数：获得系统软硬件信息等环境参数"/>
          </outline>
          <outline text="8.5 实例14：第三方库自动安装脚本 #实例 " collapsed="true">
            <outline text="问题分析" _note="&#10;需求：批量安装第三方库需要人工干预，能否自动安装？&#10;&#10;自动执行pip逐一根据安装需求安装" collapsed="true">
              <outline text="Numpy" _note="&#10;N维数据表示和运算&#10;&#10;pip install numpy"/>
              <outline text="Matplotlib" _note="&#10;二维数据可视化&#10;&#10;pip install matplotlib"/>
              <outline text="PIL" _note="&#10;图像处理&#10;&#10;pip install pillow"/>
              <outline text="Scikit-Learn" _note="&#10;机器学习和数据挖掘&#10;&#10;pip install sklearn"/>
              <outline text="Requests" _note="&#10;HTTP协议访问及网络爬虫&#10;&#10;pip install requests"/>
              <outline text="Jieba" _note="&#10;中文分词&#10;&#10;pip install jieba"/>
              <outline text="Beautiful Soup" _note="&#10;HTML和XML解析器&#10;&#10;pip install beautifulsoup4"/>
              <outline text="Wheel" _note="&#10;Python第三方库文件打包工具&#10;&#10;pip install wheel"/>
              <outline text="PyInstaller" _note="&#10;打包Python源文件为可执行文件&#10;&#10;pip insatll pyinstaller"/>
              <outline text="Django" _note="&#10;Python最流行的Web开放工具&#10;&#10;pip install django"/>
              <outline text="Flask" _note="&#10;轻量级Web开放框架&#10;&#10;pip install flask"/>
              <outline text="WeRoBot" _note="&#10;微信机器人开发框架&#10;&#10;pip install werobot"/>
              <outline text="SymPy" _note="&#10;数学符号计算工具&#10;&#10;pip install sympy&#10;&#10;"/>
              <outline text="Pandas" _note="&#10;高效数据分析和计算&#10;&#10;pip install pandas"/>
              <outline text="Networkx" _note="&#10;复杂网络和图形结构的建模和分析&#10;&#10;pip install networkx"/>
              <outline text="PyQt5" _note="&#10;基于Qt的专业级GUI开放框架&#10;&#10;pip install pyqt5"/>
              <outline text="PyOpenGL" _note="&#10;多平台OpenGL开发接口&#10;&#10;pip install pyopengl"/>
              <outline text="PyPDF2" _note="&#10;PDF文件内容提取及处理&#10;&#10;pip install pypdf2"/>
              <outline text="docopt" _note="&#10;Python命令行解析&#10;&#10;pip install docopt"/>
              <outline text="PyGame" _note="&#10;简单小游戏开放框架&#10;&#10;pip install pygame"/>
            </outline>
            <outline text="代码" _note="&#10;#BatchInstall.py&#10;import os&#10;&#10;libs = {&quot;numpy&quot;,&quot;matplotlib&quot;,&quot;pillow&quot;,&quot;sklearn&quot;}&#10;&#10;try:&#10;    for lib in libs:&#10;        os.system(&quot;pip install &quot; + lib)&#10;    print(&quot;Successful&quot;)&#10;except:&#10;    print(&quot;Failed Somehow&quot;)"/>
            <outline text="举一反三">
              <outline text="自动化脚本 +" _note="&#10;编写各类自动化运行程序的脚本，调用已有程序&#10;&#10;扩展应用：安装更多第三方库， 增加配置文件&#10;&#10;扩展异常检测：捕获更多异常类型，程序更稳定友好&#10;&#10;CZ应用：&#10;&#10;和pyinstaller结合，把脚本软件变成点击即可执行的程序。"/>
            </outline>
          </outline>
        </outline>
        <outline text="第9周：Python计算生态概览 #编程思维" collapsed="true">
          <outline text="9.1 从数据处理到人工智能" _note="&#10;数据表示 -&gt; 数据清洗-&gt;数据统计-&gt;数据可视化-&gt;数据挖掘-&gt;人工智能&#10;&#10;&#10;&#10;数据可视化：直观展示数据内涵的方式&#10;&#10;数据挖掘：从数据分析获得知识，产生数据外的价值&#10;&#10;人工智能：数据/语言/图像/视觉等方面深度分析与决策" collapsed="true">
            <outline text="Python库之数据分析" collapsed="true">
              <outline text="Numpy：表达N维数组的最基础库" collapsed="true">
                <outline text="功能" _note="&#10;Python接口使用，C语言实现，计算速度优异&#10;&#10;Python数据分析及科学计算的基础库，支撑Pandas等&#10;&#10;提供直接的矩阵运算、广播函数、线性代数等"/>
                <outline text="网站" _note="&#10;网站： www.numpy.org"/>
                <outline text="实例" _note="&#10;实例：常见 VS Numpy&#10;&#10;#exNormal.py&#10;def pySum():&#10; a = [0,1,2,3,4]&#10; b = [5,6,7,8,9]&#10; c = []&#10;&#10; for i in range(len(a)):&#10; c.append(a[i]**2 + b[i]**3)&#10;&#10; return c&#10;&#10;print(pySum())&#10;&#10;&#10;使用Numpy的程序&#10;&#10;#exNumpy.py&#10;&#10;import numpy as np&#10;&#10;def pySum():&#10; a = np.array([0,1,2,3,4])&#10; b = np.array([5,6,7,8,9])&#10; &#10; c = a**2 + b**3&#10;&#10; return c&#10;&#10;print(pySum())&#10;&#10;&#10;&#10;&#10;&#10;"/>
              </outline>
              <outline text="Pandas：Python数据分析高层次应用库" collapsed="true">
                <outline text="功能" _note="&#10;提供了简单易用的数据结构和数据分析工具&#10;&#10;理解数据类型与索引的关系，操作索引即操作数据&#10;&#10;Python最主要的数据分析功能库，基于Numpy开放"/>
                <outline text="网站" _note="&#10;Series = 索引 + 一维数据&#10;&#10;DataFrame = 行列索引 + 二维数据&#10;&#10;pandas.pydata.org"/>
              </outline>
              <outline text="Scipy：数学、科学和工程计算功能库" collapsed="true">
                <outline text="功能" _note="&#10;提供了一批数学算法及工程数据运算功能&#10;&#10;类似Matlab，可用于如傅里叶变换、信号处理等应用&#10;&#10;Python最主要的科学计算功能库，基于Numpy开发&#10;&#10;"/>
                <outline text="网站" _note="&#10;包含 稀疏图压缩类、稀疏运算类、优化算法类、傅里叶变换类、信号处理类、线性代数类、图像处理类&#10;&#10;www.scipy.org"/>
              </outline>
            </outline>
            <outline text="Python库之数据可视化" collapsed="true">
              <outline text="Matplotlib：高质量的二维数据可视化功能库" _note="&#10;提供了超过100种数据可视化效果&#10;&#10;通过matplotlib.pyplot子库调用各可视化效果&#10;&#10;Python最主要的数据可视化功能库，基于Numpy开发&#10;&#10;matplotlib.org"/>
              <outline text="Seaborn： 统计类数据可视化功能库" _note="&#10;提供了一批高层次的统计类数据可视化展示效果&#10;&#10;主要展示数据间分布、分类和线性关系等内容&#10;&#10;基于Matplotli开发，支持Numpy和Pandas&#10;&#10;seaborn.pydata.org/"/>
              <outline text="Mayavi：三维科学数据可视化功能库" _note="&#10;提供了一批简单易用的3D科学计算数据可视化展示效果&#10;&#10;目前版本是Mayavi2，三维数据化最主要的第三方库&#10;&#10;支持Numpy、TVTK、Traits、Envisage等第三方库&#10;&#10;docs.enthought.com/mayavi/mayavi/"/>
            </outline>
            <outline text="Python库之文本处理" collapsed="true">
              <outline text="PyPDF2：用来处理pdf文件的工具集" _note="&#10;提供了一批处理PDF文件的计算功能&#10;&#10;支持获取信息、分隔/整合文件、加密解密等&#10;&#10;完全Python语言实现，不需要额外依赖，功能稳定&#10;&#10;mstamy2.github.io/PyPDF2&#10;&#10;实例：&#10;&#10;#exPyPDF.py&#10;&#10;# 打开一个pdf文件1，在文件1的第二页插入文件2的第一页，输出一个新文件&#10;&#10;from PyPDF2 import PdfFileReader, PdfFileMerger&#10;&#10;merger = PdfFileMerger()&#10;input1 = open(&quot;document1.pdf&quot;,&quot;rb&quot;)&#10;input2 = open(&quot;document2.pdf&quot;,&quot;rb&quot;)&#10;merger.append(fileobj = input1, pages = (0,3))&#10;merger.merge(position = 2, fileobj = input2, pages = (0,1))&#10;output = open(&quot;document-output.pdf&quot;,&quot;wb&quot;)&#10;merger.write(output)&#10;&#10;&#10;"/>
              <outline text="NLTK：自然语言文本处理第三方库" _note="&#10;提供了一批简单易用的自然语言文本处理功能&#10;&#10;支持语言文本分类、标记、语法句法、语义分析等&#10;&#10;最优秀的Python自然语言处理库&#10;&#10;www.nltk.org/&#10;&#10;实例&#10;&#10;#nltkEx.py&#10;from nltk.corpus import treebank&#10;&#10;t = treebank.parsed_sents(&apos;wsj_0001.mrg&apos;)[0]&#10;t.draw()&#10;&#10;&#10;&#10;"/>
              <outline text="Python-docx：创建或更新Microsoft Word文件的第三方库" _note="&#10;提供创建或更新.doc，.docx等文件的计算功能&#10;&#10;增加并配置段落、图片、表格、文字等，功能全面&#10;&#10;python-docx.readthedocs.io/en/latest/index.html&#10;&#10;实例&#10;&#10;#docxEx.py&#10;from docx import Document&#10;document = Document()&#10;document.add_heading(&quot;Document Title&quot;,0)&#10;p = document.add_paragraph(&quot;A plain paragraph having some&quot;)&#10;document.add_page_break()&#10;document.save(&quot;demo.docx&quot;)"/>
            </outline>
            <outline text="Python库之机器学习" collapsed="true">
              <outline text="Scikit-learn：机器学习方法工具集，与数据处理相关的第三方库" _note="&#10;提供一批统一化的机器学习方法功能接口&#10;&#10;提供聚类、分类、回归、强化学习等计算功能&#10;&#10;机器学习最基本且最优秀的Python第三方库&#10;&#10;sickit-learn.org/"/>
              <outline text="TensorFlow：AlphaGo背后的机器学习计算框架" _note="&#10;谷歌公司推动的开源机器学习框架&#10;&#10;将数据流图作为基础，图节点代表运算，边代表张量&#10;&#10;应用机器学习方法的一种方式，支撑谷歌人工智能应用&#10;&#10;www.tensorflow.org/&#10;&#10;实例&#10;&#10;#ExTensorflow.py&#10;&#10;import tensorflow as tf&#10;init = tf.global_variables_initializer()&#10;sess = tf.Session()&#10;sess.run(init)&#10;res = sess.run(result)&#10;print(&apos;result:&apos;, res)&#10;&#10;&#10;"/>
              <outline text="MXNet：基于神经网络的深度学习计算框架" _note="&#10;提供可扩展的神经网络及深度学习计算功能&#10;&#10;可用于自动驾驶、机器翻译、语音识别等众多领域&#10;&#10;Python最重要的深度学习计算框架&#10;&#10;mxnet.incubator.apache.org/"/>
            </outline>
          </outline>
          <outline text="9.2 实例15：霍兰德人格分析雷达图 #实例 " collapsed="true">
            <outline text="问题分析" _note="&#10;需求：雷达图方式验证霍兰德人格分析&#10;&#10;输入：各职业人群结合兴趣的调研数据&#10;&#10;输出：雷达图&#10;&#10;&#10;通用雷达图绘制：matplotlib库&#10;&#10;专业的多维数据表示：numpy库&#10;&#10;&#10;"/>
            <outline text="实例展示" _note="&#10;#HollandRadarDraw.py&#10;import numpy as np&#10;import matplotlib.pyplot as plt &#10;import matplotlib&#10;&#10;matplotlib.rcParams[&apos;font.family&apos;]=&quot;SimHei&quot;&#10;radar_labels = np.array([&apos;研究型（I）&apos;,&apos;艺术型（A）&apos;,&apos;社会型（S）&apos;,\&#10;                        &apos;企业型（E）&apos;,&apos;常规型（C）&apos;,&apos;现实型（R）&apos;])&#10;data = np.array([[0.40, 0.32, 0.35, 0.30, 0.30, 0.88],&#10;                 [0.85, 0.35, 0.30, 0.40, 0.40, 0.30],&#10;                 [0.43, 0.89, 0.30, 0.28, 0.22, 0.30],&#10;                 [0.30, 0.25, 0.48, 0.85, 0.45, 0.40],&#10;                 [0.20, 0.38, 0.87, 0.45, 0.32, 0.28],&#10;                 [0.34, 0.31, 0.38, 0.40, 0.92, 0.28]])&#10;data_labels =(&apos;艺术家&apos;,&apos;实验员&apos;,&apos;工程师&apos;,&apos;推销员&apos;,&apos;社会工作者&apos;,&apos;记事员&apos;)&#10;&#10;&#10;angles = np.linspace(0, 2*np.pi, 6, endpoint=False)&#10;fig = plt.figure(facecolor = &quot;white&quot;)&#10;plt.subplot(111, polar = True)&#10;plt.plot(angles, data,&apos;o-&apos;,linewidth=1, alpha=0.2)&#10;plt.fill(angles, data, alpha=0.25)&#10;plt.thetagrids(angles*180/np.pi, radar_labels)&#10;plt.figtext(0.52, 0.95, &apos;霍兰德人格分析&apos;, ha=&apos;center&apos;, size=20)&#10;legend = plt.legend(data_labels, loc = (0.94, 0.80), labelspacing = 0.1)&#10;plt.setp(legend.get_texts(), fontsize=&apos;large&apos;)&#10;plt.grid(True)&#10;plt.savefig(&apos;holland_radar.jpg&apos;)&#10;plt.show()"/>
            <outline text="举一反三" _note="&#10;目标 + 沉浸 + 熟练&#10;&#10;编程的目标感： 寻找感兴趣的目标，寻觅挖掘之&#10;&#10;编程的沉浸感： 寻找可实现的方法，思考琢磨之&#10;&#10;编程的熟练度： 练习、练习、再练习，熟练之&#10;"/>
          </outline>
          <outline text="9.3 从web解析到网络空间" collapsed="true">
            <outline text="Python库之网络爬虫" collapsed="true">
              <outline text="Requests：最友好的网络爬虫功能库" _note="&#10;提供了简单易用的类HTTP协议网络爬虫功能&#10;&#10;支持连接池、SSL、Cookies、HTTP(S)代理等&#10;&#10;Python最主要的页面级网络爬虫功能库&#10;&#10;www.python-requests.org/&#10;&#10;实例&#10;&#10;#ExRequests.py&#10;import requests&#10;r = requests.get(&quot;https://api.github.com/user&quot;,\&#10;                auth = (&apos;user&apos;,&apos;pass&apos;))&#10;r.status_code&#10;r.headers[&apos;content-type&apos;]&#10;r.encoding&#10;r.text&#10;&#10;"/>
              <outline text="Scrapy：优秀的网络爬虫框架" _note="&#10;提供了构建网络爬虫系统的框架功能，功能半成品&#10;&#10;支持批量和定时网页爬取、提供数据处理流程等&#10;&#10;Python最主要且最专业的网络爬虫框架&#10;&#10;Python数据分析高层次应用库&#10;&#10;scrapy.org"/>
              <outline text="pyspider：强大的Web页面爬取系统" _note="&#10;提供了完整的网页爬取系统构建功能&#10;&#10;支持数据库后端、消息队列、优先级、分布式架构等&#10;&#10;Python重要的网络爬虫类第三方库&#10;&#10;docs.pyspider.org"/>
            </outline>
            <outline text="Python库之Web信息获取" collapsed="true">
              <outline text="Beautiful Soup：HTML和XML的解析库" _note="&#10;提供了解析HTML和XML等Web信息的功能&#10;&#10;又名beautifulsoup4或bs4，可以加载多种解析引擎&#10;&#10;常与网络爬虫库搭配使用，如Scrapy、requests等&#10;&#10;www.crummy.com/software/BeautifulSoup/bs4"/>
              <outline text="Re：正则表达式解析和处理功能库" _note="&#10;提供了定义和解析正则表达式的一批通用功能&#10;&#10;可用于各类场景，包括定点的Web信息提取&#10;&#10;Python最主要的标准库之一，无需安装&#10;&#10;docs.python.org/3.6/library/re.html" collapsed="true">
                <outline text="re.search()"/>
                <outline text="re.match()"/>
                <outline text="re.findall()"/>
                <outline text="re.split()"/>
                <outline text="re.finditer()"/>
                <outline text="re.sub()"/>
              </outline>
              <outline text="Python-Goose：提取文章类型Web页面的功能库" _note="&#10;提供了对Web页面中文章信息/视频等元数据的提取功能&#10;&#10;针对特定类型Web页面，应用覆盖面较广&#10;&#10;Python最主要的Web信息提取库&#10;&#10;github.com/grangier/python-gooose&#10;&#10;实例&#10;&#10;#ExPythonGoose.py&#10;from goose import Goose&#10;url = &apos;http://www.elmundo.es/elmundo/2012/10/28/espanan/1351388909.html&apos;&#10;g = Goose({&apos;use_meta_language&apos;:False, &apos;target_language&apos;:&apos;es&apos;})&#10;article = g.extract(url=url)&#10;article.cleaned_text[:150]"/>
            </outline>
            <outline text="Python库之Web网站开发" collapsed="true">
              <outline text="Django：最流行的Web应用框架" _note="&#10;提供了构建Web系统的基本应用框架&#10;&#10;MTV模式：模型（model）、模板（Template）、视图（Views）&#10;&#10;Python最重要的Web应用框架，略微复杂的应用框架&#10;&#10;www.djangoproject.com"/>
              <outline text="Pyramid：规模适中的Web应用框架" _note="&#10;提供了简单方便构建Web系统的应用框架&#10;&#10;不大不小，规模适中，适合快速构建并适度扩展类应用&#10;&#10;Python产品级Web应用框架，起步简单扩展性好&#10;&#10;trypyramid.com/&#10;&#10;&#10;实例&#10;&#10;#Expyramid.py&#10;from wsgiref.simple_server import make_server&#10;from pyramid.config import Configurator&#10;from pyramid.response import Response&#10;&#10;def hello_world():&#10;    return Response(&apos;Hello World!&apos;)&#10;if __name__ == &apos;__main__&apos;:&#10;    with Configurator() as config:&#10;        config.add_route(&apos;hello&apos;,&apos;/&apos;)&#10;        config.add_view(hello_world, route_name = &apos;hello&apos;)&#10;        app = config.make_wsgi_app()&#10;    server = make_server(&apos;0.0.0.0&apos;, 6543, app)&#10;    server.serve_forever()&#10;&#10;"/>
              <outline text="Flask：Web应用开发微框架" _note="&#10;提供了最简单构建Web系统的应用框架&#10;&#10;特点是：简单、规模小、快速&#10;&#10;Django &gt; Pyramid &gt; Flask&#10;&#10;&#10;flask. pocoo.org&#10;&#10;实例&#10;&#10;#ExFlask.py&#10;from flask import Flask&#10;app = Flask(__name__)&#10;@app.route(&apos;/&apos;)&#10;def hello_world():&#10;    return &apos;Hello, World!&apos;&#10;&#10;"/>
            </outline>
            <outline text="Python库之网络应用开发" collapsed="true">
              <outline text="WeRoBot：微信公众号开发框架" _note="&#10;提供了解析微信服务器消息及反馈消息的功能&#10;&#10;建立微信机器人的重要技术手段&#10;&#10;github.com/offu/WeRoBot&#10;&#10;实例&#10;&#10;import werobot&#10;&#10;robot = werobot.WeRoBot(token = &apos;tokenhere&apos;)&#10;&#10;@robot.handler&#10;&#10;def hello(message):&#10;    return &apos;Hello World!&apos;"/>
              <outline text="aip： 百度AI开放平台接口" _note="&#10;提供了访问百度AI服务的Python功能接口&#10;&#10;语音、人脸、OCR、NLP、知识图谱、图像搜索等领域&#10;&#10;Python百度AI应用的最主要方式&#10;&#10;github.com/Baidu-AIP/python-sdk"/>
              <outline text="MyQR：二维码生成第三方库" _note="&#10;提供了生成二维码的系列功能&#10;&#10;基本二维码、艺术二维码和动态二维码&#10;&#10;https://github.com/sylnsfar/qrcode"/>
            </outline>
          </outline>
          <outline text="9.4 从人机交互到艺术设计" collapsed="true">
            <outline text="Python库之图形用户界面" collapsed="true">
              <outline text="PyQt5：Qt开发框架的Python接口" _note="&#10;提供了创建Qt5程序的Python API接口&#10;&#10;Qt是非常成熟的跨平台桌面应用开发系统，完备GUI&#10;&#10;推荐的Python GUI开发第三方库&#10;&#10;www.riverbankcomputing.com/software/pyqt"/>
              <outline text="wxPython：跨平台GUI开发框架" _note="&#10;提供了专用于Python的跨平台GUI开发框架&#10;&#10;理解数据类型与索引的关系，操作索引即操作数据&#10;&#10;Python最主要的数据分析功能库，基于Numpy开发&#10;&#10;www.wxpython.org&#10;&#10;实例&#10;&#10;import wx&#10;app = wx.APP(False)&#10;frame = wx.Frame(None, wx.ID_ANY, &quot;Hello World&quot;)&#10;frame.Show(True)&#10;app.MainLoop()"/>
              <outline text="PyGObject：使用GTK+开发GUI的功能库" _note="&#10;提供了整合GTK+、WebKitGTK+等库的功能&#10;&#10;GTK+：跨平台的一种用户图形界面GUI框架&#10;&#10;实例：Anaconda 采用该库构建GUI&#10;&#10;pygobject.readthedocs.io"/>
            </outline>
            <outline text="Python库之游戏开发" collapsed="true">
              <outline text="PyGame：简单的游戏开发功能库" _note="&#10;提供了基于SDL的简单游戏开发功能及实现引擎&#10;&#10;理解游戏对外输入的响应机制及角色构建和交互机制&#10;&#10;Python游戏入门最主要的第三方库&#10;&#10;www.pygame.org"/>
              <outline text="Panda3D：开源、跨平台的3D渲染和游戏开发库" _note="&#10;一个3D游戏引擎，提供Python和C++两种接口&#10;&#10;支持很多先进特性：法线贴图、光泽贴图、卡图渲染等&#10;&#10;由迪士尼和卡内基梅隆大学共同开发&#10;&#10;www.panda3d.org"/>
              <outline text="cocos2d：构建2D游戏和图形界面交互式应用的框架" _note="&#10;提供了基于OpenGL的游戏开发图形渲染功能&#10;&#10;支持GPU加速，采用树形结构分层管理游戏对象类型&#10;&#10;适用于2D专业级游戏开发&#10;&#10;python.cocos2d.org/"/>
            </outline>
            <outline text="Python库之虚拟现实" collapsed="true">
              <outline text="VR Zero：在树莓派上开发VR应用的Python库" _note="&#10;提供大量与VR开发相关的功能&#10;&#10;针对树莓派的VR开发库，支持设备小型化，配置简单化&#10;&#10;非常适合初学者实践VR开发及应用&#10;&#10;github.com/WayneKeenan/python-vrzero"/>
              <outline text="pyovr：Oculus Rift的Python开发接口" _note="&#10;针对Oculus VR设备的Python开发库&#10;&#10;基于成熟的VR设备，提供全套文档，工业级应用设备&#10;&#10;Python+虚拟现实领域探索的一种思路&#10;&#10;github.com/cmbruns/pyovr"/>
              <outline text="Vizard：基于Python的通用VR开发引擎" _note="&#10;专业的企业级虚拟现实开发引擎&#10;&#10;提供详细的官方文档&#10;&#10;支持多种主流的VR硬件设备，具有一定通用性&#10;&#10;www.worldviz.com/vizard-virtual-reality-software"/>
            </outline>
            <outline text="Python库之图形艺术" collapsed="true">
              <outline text="Quads：迭代的艺术" _note="&#10;对图片进行四分迭代，形成像素风&#10;&#10;可以生成动画或静图图像&#10;&#10;简单易用，具有很高展示度&#10;&#10;github.com/fogleman/Quads"/>
              <outline text="ascii_art：ASCII艺术库" _note="&#10;将普通图片转化为ASCII艺术风格&#10;&#10;输出可以是纯文本或彩色文本&#10;&#10;可采用图片格式输出&#10;&#10;github.com/jontonsoup4/ascii_art"/>
              <outline text="turtle：海龟绘图体系" _note="&#10;docs.python.org/3/library/turtle.html"/>
            </outline>
          </outline>
          <outline text="9.5 实例16：玫瑰花绘制  #实例 " collapsed="true">
            <outline text="问题分析" _note="&#10;需求： Python绘制一朵玫瑰花&#10;&#10;输入： 你的想象力&#10;&#10;输出：玫瑰花"/>
            <outline text="绘制" _note="&#10;绘制机理：turtle基本图形绘制&#10;&#10;绘制思想：因人而异&#10;&#10;思想有多大、世界就有多大&#10;&#10;"/>
            <outline text="实例代码" _note="&#10;#RoseDraw.py&#10;import turtle as t &#10;&#10;# 定义一个曲线绘制函数&#10;def DegreeCurve(n, r, d=1):&#10;    for i in range(n):&#10;        t.left(d)&#10;        t.circle(r,abs(d))&#10;&#10;# 初始位置设定&#10;s = 0.2 #size&#10;t.setup(450*5*s, 750*5*s)&#10;t.pencolor(&quot;black&quot;)&#10;t.fillcolor(&quot;red&quot;)&#10;t.speed(100)&#10;t.penup()&#10;t.goto(0, 900*s)&#10;t.pendown()&#10;&#10;# 绘制花朵形状&#10;t.begin_fill()&#10;t.circle(200*s, 30)&#10;DegreeCurve(60, 50*s)&#10;t.circle(200*s, 30)&#10;DegreeCurve(4,100*s)&#10;t.circle(200*s, 50)&#10;DegreeCurve(50, 50*s)&#10;t.circle(350*s,65)&#10;DegreeCurve(40, 70*s)&#10;t.circle(150*s, 50)&#10;DegreeCurve(20, 50*s, -1)&#10;t.circle(400*s, 60)&#10;DegreeCurve(18, 50*s)&#10;t.fd(250*s)&#10;t.right(150)&#10;t.circle(-500*s, 12)&#10;t.left(140)&#10;t.circle(550*s, 110)&#10;t.left(27)&#10;t.circle(650*s, 100)&#10;t.left(130)&#10;t.circle(-300*s, 20)&#10;t.right(123)&#10;t.circle(220*s, 57)&#10;t.end_fill()&#10;&#10;# 绘制花枝形状&#10;t.left(120)&#10;t.fd(280*s)&#10;t.left(115)&#10;t.circle(300*s, 33)&#10;t.left(180)&#10;t.circle(-300*s,33)&#10;DegreeCurve(70, 225*s, -1)&#10;t.circle(350*s, 104)&#10;t.left(90)&#10;t.circle(200*s, 105)&#10;t.circle(-500*s,63)&#10;t.penup()&#10;t.goto(170*s, -30*s)&#10;t.pendown()&#10;t.left(160)&#10;DegreeCurve(20, 2500*s)&#10;DegreeCurve(220, 250*s, -1)&#10;&#10;#绘制一个绿色叶子&#10;t.fillcolor(&apos;green&apos;)&#10;t.penup()&#10;t.goto(670*s, -180*s)&#10;t.pendown()&#10;t.right(140)&#10;t.begin_fill()&#10;t.circle(300*s,120)&#10;t.left(60)&#10;t.circle(300*s, 120)&#10;t.end_fill()&#10;t.penup()&#10;t.goto(180*s, -550*s)&#10;t.pendown()&#10;t.right(85)&#10;t.circle(600*s, 40)&#10;&#10;# 绘制另一个绿色叶子&#10;t.penup()&#10;t.goto(-150*s, -1000*s)&#10;t.pendown()&#10;t.begin_fill()&#10;t.rt(120)&#10;t.circle(300*s, 115)&#10;t.left(75)&#10;t.circle(300*s, 100)&#10;t.end_fill()&#10;t.penup()&#10;t.goto(430*s, -1070*s)&#10;t.pendown()&#10;t.right(30)&#10;t.circle(-600*s, 35)&#10;t.done()&#10;&#10;&#10;&#10;"/>
            <outline text="举一反三" _note="&#10;艺术之于编程，设计之余编程&#10;&#10;艺术：思想优先，编程是手段&#10;&#10;设计：思想和编程同等重要&#10;&#10;工程：编程优先，思想次之">
              <outline text="编程不重要，思想才重要" _note="&#10;认识自己：明确自己的目标，有自己的想法&#10;&#10;方式方法：编程只是手段，熟练之，未雨绸缪为思想服务&#10;&#10;为谁编程：将自身发展与祖国发展结合，创造真正价值"/>
            </outline>
          </outline>
        </outline>
        <outline text="第9+周：Python学习展望" collapsed="true">
          <outline text="9.1 Python语法的三个阶段" _note="&#10;Python基础语法（函数式编程）→Python进阶语法（面向对象编程）→Python高级语法（Pythonic编程）"/>
          <outline text="9.2 Python基础语法的计算生态" collapsed="true">
            <outline text="Python网络爬虫与信息提取"/>
            <outline text="Python数据分析与展示"/>
            <outline text="Python机器学习应用"/>
            <outline text="Python科学计算三维可视化"/>
            <outline text="Pyhon游戏开发入门"/>
            <outline text="Pyhon云端系统开发入门"/>
          </outline>
          <outline text="9.3 Python进阶语法和高级语法的计算生态" collapsed="true">
            <outline text="Python + 大数据 + 人工智能"/>
            <outline text="Python + 嵌入式 +可编程硬件"/>
          </outline>
        </outline>
        <outline text="问题清单"/>
      </outline>
      <outline text="Python基础语法精讲" _note="北京理工大学 ，嵩天，网易公开课，通过BiliBili学习，学习时间：202011"/>
      <outline text="Python面向对象语法精讲" _note="北京理工大学 ，嵩天，网易公开课，通过BiliBili学习，学习时间：202011" collapsed="true">
        <outline text="第1周  Python面向对象基础">
          <outline text="1.1 面向对象的编程模式" collapsed="true">
            <outline text="万物皆对象" collapsed="true">
              <outline text="对象：独立的存在 或 作为目标的事物" _note="&#10;· 独立性：对象都存在清晰的边界，重点在于划分边界&#10;&#10;· 功能性：对象都能表现出一些功能、操作或行为&#10;&#10;· 交互性： 对象之间存在交互，如运算和继承"/>
              <outline text="Python语言的“万物皆对象”" _note="&#10;· Python语言中所有数据类型都是对象，函数是对象，模块是对象&#10;&#10;· Python所有类都继承于最基础类object&#10;&#10;· Python语言中数据类型的操作功能都是类方法的体现"/>
            </outline>
            <outline text="面向对象编程思想" collapsed="true">
              <outline text="OOP：Object-Oriented Programming" _note="&#10;· OOP：面向对象编程，一种编程思想，重点在于高抽象的复用代码&#10;&#10;· OOP把对象当做程序的基本单元，对象包含数据和操作数据的函数&#10;&#10;· OOP的本质是把问题解决抽象为以对象为中心的计算机程序&#10;&#10;· OOP在较大规模或复杂项目中十分有用，OOP可以提高协作产量&#10;&#10;· OOP最主要价值在于代码复用&#10;&#10;· OOP只是一种编程模式，并非解决问题的高级方法"/>
              <outline text="面向对象 VS 面向过程" _note="&#10;· 面向过程：以解决问题的过程步骤为核心编写程序的方式&#10;&#10;· 面向过程：以问题对象构建和应用为核心编程程序的方式&#10;&#10;· 所有OOP能解决的问题，面向过程都能解决"/>
              <outline text="面向对象编程概念实例">
                <outline text="要求" _note="&#10;· 有3个商品：电脑、打印机和投影仪&#10;&#10;· 每个商品有1个原始售价和1个折扣售价&#10;&#10;· 求3个商品原始售价的和以及折扣售价的和"/>
                <outline text="面向过程的程序解法" _note="&#10;列表1， 存商品：电脑、打印机、投影仪&#10;&#10;列表2， 存原价：电脑原价、打印机原价、投影仪原价&#10;&#10;列表3，存实价：电脑实价、打印机实价、投影仪实价&#10;&#10;根据列表1、列表2和列表3进行计算，列表1/2/3功能需要文档标记"/>
                <outline text="面向对象的程序解法" _note="&#10;设计“商品”类，属性包括：商品名、原价和实价&#10;&#10;从“商品”类产生3个对象：电脑、打印机、投影仪&#10;&#10;这三个对象中保存商品名、原价、实价等于商品相关的信息&#10;&#10;使用对象1、对象2和对象3进行计算&#10;"/>
              </outline>
            </outline>
            <outline text="面向对象的三个特征">
              <outline text="封装 Encapsulation" _note="&#10;属性和方法的抽象，用数据和操作数据的方法来形成对象逻辑&#10;&#10;· 属性的抽象：对象的属性（变量）进行定义、隔离及保护&#10;&#10;· 属性的方法：对象的方法（函数）进行定义、隔离及保护&#10;&#10;· 目标是形成一个类对外可操作属性和方法的接口"/>
              <outline text="继承 Inheritance" _note="&#10;代码复用的高级抽象，用对象之间的继承关系来形成代码复用&#10;&#10;· 继承是面向对象程序设计的精髓之一&#10;&#10;· 实现了以类为单位的高抽象级别代码复用&#10;&#10;· 继承是新定义类能够几乎完全使用原有类属性与方法的过程"/>
              <outline text="多态 Polymorphism" _note="&#10;仅针对方法，方法灵活性的抽象，让对象的操作更加灵活、更多复用代码&#10;&#10;· 参数类型的多态：一个方法能够处理多个类型的能力&#10;&#10;· 参数形式的多态：一个方法能够接受多个参数的能力&#10;&#10;· 多态是OOP的一个传统概念，Python天然支持多态，不需要特殊语法"/>
            </outline>
            <outline text="Python面向对象术语概述" collapsed="true">
              <outline text="类 Class" _note="&#10;逻辑对象和产生对象的模板，一组变量和函数的特定编排"/>
              <outline text="对象 Object" _note="&#10;具体表达数据及操作的实体，相对于程序中的“变量”&#10;&#10;· 类对象&#10;&#10;· 实例对象&#10;&#10;类对象和实例对象是一组概念，类对象全局只有一个，实例对象可以生成多个" collapsed="true">
                <outline text="类对象 Class Object" _note="&#10;Class Object，维护每个Python类基本信息的数据结构"/>
                <outline text="实例对象 Class Attribute" _note="&#10;Instance Object，Python类实例后产生的对象，简称：对象&#10;&#10;__init__()"/>
              </outline>
              <outline text="实例化" _note="&#10;从类到对象的过程，所有“对象”都源于某个“类”"/>
              <outline text="属性" _note="&#10;存储数据的“变量”，包括类属性、实例属性(Instance Attributes)"/>
              <outline text="方法" _note="&#10;操作数据的“函数”&#10;&#10;包括：&#10;&#10;类方法 Class Method                         @classmethod&#10;&#10;实例方法 Instance Method               def  - self&#10;&#10;自由方法  Namespace Method        def&#10;&#10;静态方法 Static Method                      @staticmethod    &#10;&#10;保留方法 Special Method                  __XX__"/>
              <outline text="继承" _note="&#10;基类、派生类、子类、父类、超类、重载"/>
              <outline text="命名空间" _note="&#10;程序元素作用域的表达"/>
              <outline text="构造和析构" _note="&#10;生成对象和删除对象的过程"/>
              <outline text="对象引用 Object Reference"/>
            </outline>
            <outline text="Python面向对象实例入门">
              <outline text="商品价格统计" _note="&#10;· 有3个商品：电脑、打印机和投影仪&#10;&#10;· 每个商品有1个原始售价和1个折扣售价&#10;&#10;· 求3个商品原始售价的和以及折扣售价的和">
                <outline text="代码" _note="```&#10;class Product():                         # 定义了抽象的Product类，保存了名字和价格等信息&#10;    def __init__(self,name):&#10;        self.name = name     &#10;        self.label_price = 0           # 初始化价格为0&#10;        self.real_price = 0  &#10;&#10;c = Product(&quot;电脑&quot;)                # 产生3个对象，分别对应3个具体商品&#10;d = Product(&quot;打印机&quot;) &#10;e = Product(&quot;投影仪&quot;) &#10;&#10;c.label_price,c.real_price = 10000, 8000     # 为3个对象商品赋予价格&#10;d.label_price, d.label_price = 2000, 1000&#10;e.label_price, e.label_price = 1500, 900&#10;s1,s2=0,0&#10;&#10;for i in [c ,d ,e]:                                                      # 求和并输出价格&#10;    s1 += i.real_price                                                #  价格由label_price和real_price表示&#10;    s2 += i.label_price&#10;print(s1,s2)&#10;&#10;```"/>
              </outline>
            </outline>
          </outline>
          <outline text="1.2 Python类的构建 #语法">
            <outline text="类的基本构建">
              <outline text="类（class）的构建" collapsed="true">
                <outline text="默认" _note="&#10;类对象 Class Object&#10;&#10;类属性 Class Attributes"/>
                <outline text="`@classmethod `" _note="&#10;类方法 Class Method"/>
                <outline text="def - self" _note="&#10;实例方法 Instance Method"/>
                <outline text="def" _note="&#10;自由方法 Namespace Method"/>
                <outline text="`@staticmethod`" _note="&#10;静态方法 Static Method"/>
                <outline text="`__XX__`" _note="&#10;保留方法 Reserved Method"/>
                <outline text="`__del__()`" _note="&#10;对象引用 Object  Reference"/>
                <outline text="`__init__()`" _note="&#10;实例对象 Instance Object&#10;&#10;实例属性 Instance Attributes"/>
              </outline>
              <outline text="类的基本构建方法" collapsed="true">
                <outline text="使用class 保留字定义类" _note="&#10;class &lt;类名&gt;：&#10; [类描述 “documentation string”]&#10; &lt;语句块&gt;&#10;&#10;类定义不限位置，可以包含在分支或其他从属语句块中，执行时存在即可&#10;&#10;· 类的名字：可以是任何有效标识符，建议采用大写单词的组合&#10;&#10;   如： ClassName, BasicAuto, BasicCreature&#10;&#10;· 类的描述：在类定义后首行，以独立字符串形式定义&#10;&#10;   定义后通过 `&lt;类名&gt;.__doc__`属性来访问" collapsed="true">
                  <outline text="实例" _note="&#10;```&#10;class DemoClass:&#10; &quot;This is a demo for Python class&quot;&#10; pass&#10;&#10;print(DemoClass.__doc__)&#10;&#10;```"/>
                </outline>
                <outline text="类对象： Class Object" _note="&#10;· 类定义后完成后，默认生成一个类对象&#10;&#10;· 每个类唯一对应一个类对象，用于存储这个类的基本信息&#10;&#10;· 类对象是type类的实例，表达为type类型">
                  <outline text="实例" _note="&#10;```&#10;[In]&#10;class DemoClass:&#10; &quot;This is a demo for Python class&quot;&#10; print(&quot;Hello Demo Class&quot;)&#10;&#10;[In]&#10;print(DemoClass.__doc__)&#10;&#10;[Out]&#10;Hello Demo Class&#10;This is a demo for Python class&#10;&#10;[In]&#10;print(type(DemoClass))&#10;&#10;[Out]&#10;Hello Demo Class&#10;&lt;class &apos;type&apos;&gt;&#10;&#10;&#10;[In]&#10;print(DemoClass.__doc__)&#10;print(type(DemoClass))&#10;&#10;[Out]&#10;Hello Demo Class&#10;This is a demo for Python class&#10;&lt;class &apos;type&apos;&gt;&#10;&#10;```&#10;&#10;类对象内直接包含的语句会被执行，因此，一般不在类定义中直接包含语句。"/>
                </outline>
              </outline>
              <outline text="类的使用方法" _note="&#10;通过创建实例对象（Instance Object）使用类的功能&#10;&#10;&lt;对象名&gt; = &lt;类名&gt;([参数])&#10;&#10;&#10;进一步采用&lt;对象名&gt;.&lt;属性名&gt; 和&lt;对象名&gt;.&lt;方法名&gt;()体现类的功能" collapsed="true">
                <outline text="实例" _note="&#10;```&#10;class DemoClass:&#10; &quot;This is a demo for Python class&quot;&#10; print(&quot;Hello Demo Class&quot;)&#10;print(type(DemoClass))&#10;cn = DemoClass()&#10;print(type(cn))&#10;&#10;[Out]:&#10;&#10;Hello Demo Class&#10;&lt;class &apos;type&apos;&gt;&#10;&lt;class &apos;__main__.DemoClass&apos;&gt;&#10;```&#10;&#10;实例对象是Python类的最常用方式"/>
              </outline>
              <outline text="了解Python类的构造函数" _note="&#10;· 类的构造函数用于从类创建实例对象的过程&#10;&#10;· 类的构造函数为实例对象创建提供了参数输入方式&#10;&#10;· 类的构造函数为实例对象的定义和赋值提供了支持"/>
              <outline text="了解Python类的属性和方法" _note="&#10;· 类的属性：类中定义的变量， 用来描述类的一些特性参数&#10;&#10;· 类的方法：类中定义且与类相关的函数，用来给出类的操作功能&#10;&#10;· 属性和方法是类对外交互所提供的两种接口方式"/>
              <outline text="类对象 vs. 实例对象" _note="&#10;· 类对象：Class Object，维护每个Python类基本信息的数据结构&#10;&#10;· 实例对象：Instance Object，Python类实例后产生的对象，简称：对象&#10;&#10;这是一组概念，类对象全局只有一个，实例对象可以生成多个"/>
            </outline>
            <outline text="类的构造函数"/>
            <outline text="类的属性"/>
            <outline text="类的方法"/>
            <outline text="类的析构函数"/>
          </outline>
          <outline text="1.3 实例1：银行ATM等待时间分析" collapsed="true">
            <outline text="对象的设计和构建"/>
            <outline text="生活现象的程序分析"/>
          </outline>
          <outline text="1.4 Python类的封装 #语法" collapsed="true">
            <outline text="私有属性和公开属性"/>
            <outline text="私有方法和公开方法"/>
            <outline text="保留属性和保留方法"/>
          </outline>
          <outline text="1.5 Python类的继承 #语法" collapsed="true">
            <outline text="子类、父类和超类"/>
            <outline text="类的方法重载和属性重载"/>
            <outline text="类的多继承"/>
          </outline>
          <outline text="1.6 Python语法实践" collapsed="true">
            <outline text="一小时类构建操作实践"/>
          </outline>
        </outline>
        <outline text="第2周 Python面向对象进阶">
          <outline text="2.1 Python类的运算  #语法" collapsed="true">
            <outline text="运算符的理解"/>
            <outline text="各类运算符的重载"/>
          </outline>
          <outline text="2.2 Python类的多态 #语法" collapsed="true">
            <outline text="多态的理解"/>
            <outline text="参数类型的多态"/>
            <outline text="参数形式的多态"/>
          </outline>
          <outline text="2.3 实例2：图像的四则运算" collapsed="true">
            <outline text="PIL库和numpy库实践"/>
            <outline text="图像的加减乘除操作"/>
          </outline>
          <outline text="2.4 Python对象的引用">
            <outline text="引用的理解"/>
            <outline text="浅拷贝和深拷贝"/>
          </outline>
          <outline text="2.5 Python类的高级话题 #语法" collapsed="true">
            <outline text="类的特殊装饰器"/>
            <outline text="命名空间的解释"/>
            <outline text="类的名称修饰"/>
          </outline>
          <outline text="2.6 Python语法实践" collapsed="true">
            <outline text="一小时类运算操作实践"/>
          </outline>
        </outline>
      </outline>
      <outline text="Python 数据分析与展示" _note="&#10;北京理工大学 ，嵩天，202009&#10;&#10;掌握表示、清洗、统计和展示数据的能力" collapsed="true">
        <outline text="如何使用numpy的数组对象？" _note="&#10;使用np.array()&#10;&#10;实例&#10;&#10;import numpy as np&#10;&#10;def npSum():&#10;    a = np.array([0, 1, 2, 3, 4])&#10;    b = np.array([9, 8, 7, 6, 5])&#10;    &#10;    c = a**2 + b**3&#10;    &#10;    return c&#10;&#10;print(npSum())"/>
        <outline text="第O周：前奏（工具）" collapsed="true">
          <outline text="编程工具" collapsed="true">
            <outline text="Anaconda IDE集成开发工具"/>
            <outline text="conda"/>
            <outline text="Spyder"/>
            <outline text="IPython"/>
          </outline>
          <outline text="Anaconda IDE的基本使用" collapsed="true">
            <outline text="www.continuum.io"/>
            <outline text="一个集成各类Python工具的集成平台"/>
          </outline>
          <outline text="包管理和环境管理工具：conda" collapsed="true">
            <outline text="conda和anaconda" _note="&#10;&#10;conda：一个工具，用于包管理和环境管理，其中：&#10;  &#10;  包管理与pip类似，管理Python第三方库&#10;&#10;  环境管理能够允许用户使用不同版本Python，并能灵活切换&#10;&#10;anaconda：一个集合，包括conda、某版本Python、一批第三方库等&#10;&#10;conda将工具、第三方库、Python版本、conda都当作包，同等对待"/>
            <outline text="win平台使用" _note="&#10;cmd，执行conda -version     获取conda版本&#10;&#10;       执行conda update conda 升级conda"/>
          </outline>
          <outline text="编程工具：Spyder" collapsed="true">
            <outline text="安装spyder" _note="&#10;[安装spyder_t11383的博客-CSDN博客](https://blog.csdn.net/t11383/article/details/88647686)&#10;&#10;[Windows10 安装spyder_qq_34488177的博客-CSDN博客](https://blog.csdn.net/qq_34488177/article/details/84774478?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param)&#10;&#10;&#10;"/>
            <outline text="如何打开spyder" _note="&#10;在cmd里输入 spyder3"/>
            <outline text="如何设置spyder" _note="&#10;Tools—Preferences—Syntax coloring—Manage color schemes，在Scheme中选择Monokai"/>
          </outline>
          <outline text="交互式编程环境：IPython" _note="&#10;一个功能强大的交互式shell&#10;&#10;适合进行交互式数据可视化和GUI相关应用&#10;&#10;IPython是打开Spyder之后，位于窗口的右下方的区域。" collapsed="true">
            <outline text="变量前或后加？将显示一些通用信息，包括函数对应的源代码" _note="&#10;实例&#10;&#10;In [1]: import numpy as np&#10;&#10;&#10;In [2]: a =np.arange(10)&#10;&#10;&#10;In [3]: a&#10;Out[3]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])&#10;&#10;&#10;In [4]: a?&#10;Type: ndarray&#10;String form: [0 1 2 3 4 5 6 7 8 9]&#10;Length: 10&#10;File: c:\users\23645\appdata\local\programs\python\python38\lib\site-packages\numpy\__init__.py&#10;Docstring: &lt;no docstring&gt;&#10;Class docstring:&#10;ndarray(shape, dtype=float, buffer=None, offset=0,&#10; strides=None, order=None)&#10;&#10;&#10;An array object represents a multidimensional, homogeneous array&#10;of fixed-size items. An associated data-type object describes the&#10;format of each element in the array (its byte-order, how many bytes it&#10;occupies in memory, whether it is an integer, a floating point number,&#10;or something else, etc.)&#10;&#10;&#10;Arrays should be constructed using `array`, `zeros` or `empty` (refer&#10;to the See Also section below). The parameters given here refer to&#10;a low-level method (`ndarray(...)`) for instantiating an array.&#10;&#10;&#10;For more information, refer to the `numpy` module and examine the&#10;methods and attributes of an array.&#10;&#10;&#10;Parameters&#10;----------&#10;(for the __new__ method; see Notes below)&#10;&#10;&#10;shape : tuple of ints&#10; Shape of created array.&#10;dtype : data-type, optional&#10; Any object that can be interpreted as a numpy data type.&#10;buffer : object exposing buffer interface, optional&#10; Used to fill the array with data.&#10;offset : int, optional&#10; Offset of array data in buffer.&#10;strides : tuple of ints, optional&#10; Strides of data in memory.&#10;order : {&apos;C&apos;, &apos;F&apos;}, optional&#10; Row-major (C-style) or column-major (Fortran-style) order.&#10;&#10;&#10;Attributes&#10;----------&#10;T : ndarray&#10; Transpose of the array.&#10;data : buffer&#10; The array&apos;s elements, in memory.&#10;dtype : dtype object&#10; Describes the format of the elements in the array.&#10;flags : dict&#10; Dictionary containing information related to memory use, e.g.,&#10; &apos;C_CONTIGUOUS&apos;, &apos;OWNDATA&apos;, &apos;WRITEABLE&apos;, etc.&#10;flat : numpy.flatiter object&#10; Flattened version of the array as an iterator. The iterator&#10; allows assignments, e.g., ``x.flat = 3`` (See `ndarray.flat` for&#10; assignment examples; TODO).&#10;imag : ndarray&#10; Imaginary part of the array.&#10;real : ndarray&#10; Real part of the array.&#10;size : int&#10; Number of elements in the array.&#10;itemsize : int&#10; The memory use of each array element in bytes.&#10;nbytes : int&#10; The total number of bytes required to store the array data,&#10; i.e., ``itemsize * size``.&#10;ndim : int&#10; The array&apos;s number of dimensions.&#10;shape : tuple of ints&#10; Shape of the array.&#10;strides : tuple of ints&#10; The step-size required to move from one element to the next in&#10; memory. For example, a contiguous ``(3, 4)`` array of type&#10; ``int16`` in C-order has strides ``(8, 2)``. This implies that&#10; to move from element to element in memory requires jumps of 2 bytes.&#10; To move from row-to-row, one needs to jump 8 bytes at a time&#10; (``2 * 4``).&#10;ctypes : ctypes object&#10; Class containing properties of the array needed for interaction&#10; with ctypes.&#10;base : ndarray&#10; If the array is a view into another array, that array is its `base`&#10; (unless that array is also a view). The `base` array is where the&#10; array data is actually stored.&#10;&#10;&#10;See Also&#10;--------&#10;array : Construct an array.&#10;zeros : Create an array, each element of which is zero.&#10;empty : Create an array, but leave its allocated memory unchanged (i.e.,&#10; it contains &quot;garbage&quot;).&#10;dtype : Create a data-type.&#10;&#10;&#10;Notes&#10;-----&#10;There are two modes of creating an array using ``__new__``:&#10;&#10;&#10;1. If `buffer` is None, then only `shape`, `dtype`, and `order`&#10; are used.&#10;2. If `buffer` is an object exposing the buffer interface, then&#10; all keywords are interpreted.&#10;&#10;&#10;No ``__init__`` method is needed because the array is fully initialized&#10;after the ``__new__`` method.&#10;&#10;&#10;Examples&#10;--------&#10;These examples illustrate the low-level `ndarray` constructor. Refer&#10;to the `See Also` section above for easier ways of constructing an&#10;ndarray.&#10;&#10;&#10;First mode, `buffer` is None:&#10;&#10;&#10;&gt;&gt;&gt; np.ndarray(shape=(2,2), dtype=float, order=&apos;F&apos;)&#10;array([[0.0e+000, 0.0e+000], # random&#10; [ nan, 2.5e-323]])&#10;&#10;&#10;Second mode:&#10;&#10;&#10;&gt;&gt;&gt; np.ndarray((2,), buffer=np.array([1,2,3]),&#10;... offset=np.int_().itemsize,&#10;... dtype=int) # offset = 1*itemsize, i.e. skip first element&#10;array([2, 3])"/>
            <outline text="%run命令" _note="&#10;%run名利用于运行.py程序&#10;&#10;注意：%run在一个空的命名空间执行%&#10;&#10;实例：&#10;&#10;%run d:/ex/TangentCirclesDraw.py"/>
            <outline text="%魔术命令" _note="&#10;实例：&#10;&#10;In [1]: import numpy as np&#10;&#10;&#10;In [2]: a = np.random.randn(1000,1000)&#10;&#10;&#10;In [3]: %time np.dot(a,a)&#10;Wall time: 71 ms&#10;Out[3]: &#10;array([[-33.54578289, -2.51038795, 48.0966667 , ..., -21.55361141,&#10; -25.83783995, -36.74416111],&#10; [-29.5521849 , 27.06607668, 68.68032171, ..., -24.78763329,&#10; 36.87645997, -70.1089174 ],&#10; [ 31.40152116, -47.41966321, 27.16951125, ..., 33.41176693,&#10; -28.29506949, 22.40105769],&#10; ...,&#10; [-21.55090637, 20.62161789, -38.91325937, ..., 2.8757449 ,&#10; 18.51831565, 25.20748402],&#10; [ 38.17495603, -1.45917593, 52.01885599, ..., 24.37585955,&#10; -71.65919448, 17.85910477],&#10; [ -1.44951635, 30.54213957, 16.16589434, ..., -14.86857895,&#10; 14.52591691, 20.50514609]])&#10;&#10;&#10;In [4]: %timeit np.dot(a,a)&#10;38.6 ms ± 1.02 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)&#10;&#10;&#10;In [5]: %who&#10;a  np  &#10;&#10;&#10;In [6]: %reset&#10;&#10;&#10;Once deleted, variables cannot be recovered. Proceed (y/[n])? y&#10;&#10;&#10;In [7]: %hist&#10;import numpy as np&#10;a = np.random.randn(1000,1000)&#10;%time np.dot(a,a)&#10;%timeit np.dot(a,a)&#10;%who&#10;%reset&#10;%hist">
              <outline text="%magic" _note="&#10;显示所有魔术命令"/>
              <outline text="%hist" _note="&#10;IPython命令的输入历史"/>
              <outline text="%pdb" _note="&#10;异常发生后自动进入调试器"/>
              <outline text="%reset" _note="&#10;删除当前命名空间中的全部变量或名称"/>
              <outline text="%who" _note="&#10;显示IPython当前命名空间中已经定义的变量"/>
              <outline text="%time statement" _note="&#10;给出代码执行的时间，statement表示一段代码"/>
              <outline text="%timeit statement" _note="&#10;多次执行代码，计算综合平均执行时间"/>
            </outline>
          </outline>
        </outline>
        <outline text="第1周：数据分析之表示" collapsed="true">
          <outline text="单元1：NumPy库入门" collapsed="true">
            <outline text="数据的维度" collapsed="true">
              <outline text="从一个数据到一组数据" _note="&#10;一个数据表达一个含义&#10;&#10;一组数据表达一个或多个含义"/>
              <outline text="维度：一组数据的组织形式"/>
              <outline text="一维数据：由对等关系的有序或无序数据构成，采用线性方式组织" _note="&#10;对应列表、数据和集合等概念">
                <outline text="列表和数据：一组数据的有序结构" _note="&#10;区别：&#10;&#10;列表：数据类型可以不同&#10;&#10;数组：数据类型相同&#10;"/>
              </outline>
              <outline text="二维数据：由多个一维数据构成，是一维数据的组合形式" _note="&#10;表格是典型的二维数据，其中，表头是二维数据的一部分"/>
              <outline text="多维数据：由一维或多维数据在新维度上扩展形成" _note="&#10;比如不同年份的相同表格，就构成了多维数据"/>
              <outline text="高维数据：仅利用最基本的二元关系展示数据期间复杂结构" _note="&#10;比如字典里的键值对"/>
              <outline text="数据维度的Python表示" _note="&#10;数据维度是数据的组织方式&#10;&#10;一维数据：列表和集合类型&#10;&#10;二维数据：列表类型&#10;&#10;多维数据：列表类型&#10;&#10;高维数据：字典类型或数据表示格式        JSON、XML和YAML格式"/>
            </outline>
            <outline text="NumPy的数组对象：ndarray" collapsed="true">
              <outline text="NumPy">
                <outline text="NumPy是一个开源的Python科学计算基础库" _note="&#10;包括：&#10;&#10;一个强大的N维数组对象 ndarray&#10;&#10;广播功能函数&#10;&#10;整合C/C++/Fortrant代码的工具&#10;&#10;线性代数、傅里叶变换、随机数生成等功能&#10;&#10;NumPy是SciPy、Pandas等数据处理或科学计算库的基础"/>
              </outline>
              <outline text="NumPy的引用" _note="&#10;import numpy as np&#10;&#10;"/>
              <outline text="NumPy的数组对象：ndarray" _note="&#10;数据对象可以去掉元素间运算所需要的循环，使一位向量更像单个数据&#10;&#10;设置专门的数据对象，经过优化、可以提升这类应用的运算速度&#10;&#10;">
                <outline text="ndarray构成" _note="&#10;ndarray是一个多维数组对象，由两部分构成：&#10;&#10;· 实际的数据&#10;&#10;· 描述这些数据的元数据（数据维度、数据类型等）&#10;&#10;ndarray数据一般要求所有元素类型相同（同质），数据下标从0开始&#10;&#10;"/>
                <outline text="ndarray实例" _note="&#10;ndarray在程序中的别名是：array&#10;&#10;np.array()生成一个ndarray数组&#10;&#10;np.array()输出成[]形式，元素由空格分隔&#10;&#10;轴（axis）：保存数据的维度&#10;&#10;秩（rank）：轴的数量&#10;&#10;&#10;&#10;In [2]: a = np.array([[0,1,2,3,4],[9,8,7,6,5]])&#10;&#10;&#10;In [3]: a&#10;Out[3]: &#10;array([[0, 1, 2, 3, 4],&#10; [9, 8, 7, 6, 5]])&#10;&#10;&#10;In [4]: print(a)&#10;[[0 1 2 3 4]&#10; [9 8 7 6 5]]"/>
                <outline text="ndarray对象的属性 #重点" _note="&#10;实例：&#10;&#10;&#10;a = np.array([[0,1,2,3,4],[9,8,7,6,5]])&#10;&#10;a.ndim&#10;Out[6]: 2&#10;&#10;a.shape&#10;Out[7]: (2, 5)&#10;&#10;a.size&#10;Out[8]: 10&#10;&#10;a.dtype&#10;Out[10]: dtype(&apos;int32&apos;)&#10;&#10;a.itemsize&#10;Out[11]: 4" collapsed="true">
                  <outline text=".ndim" _note="&#10;秩，即轴的数量或维度的数量"/>
                  <outline text=".shape" _note="&#10;ndarray对象的尺度，对于矩阵，n行m列"/>
                  <outline text=".size" _note="&#10;ndarray对象元素的个数，相当于.shape中n*m的值"/>
                  <outline text=".dtype" _note="&#10;ndarray对象的元素类型"/>
                  <outline text=".itemsize" _note="&#10;ndarray对象中每个元素的大小，以字节为单位"/>
                </outline>
                <outline text="理解轴（axis）" _note="&#10;一维数组中axis=0是沿着行的轴。&#10;&#10;二维数组中axis=0是沿着列向下的轴。axis=1是沿着行向右的轴。&#10;&#10;多维数组中 axis=0是维度，axis=1是沿着列向下的轴，axis=2是沿着行向右的轴。&#10;&#10;&#10;&#10;[对Numpy中轴（axes）的解释（汉化版） - 简书](https://www.jianshu.com/p/f4e9407f9f9d)"/>
              </outline>
            </outline>
            <outline text="ndarray数组的元素类型" collapsed="true">
              <outline text="ndarray的元素类型" collapsed="true">
                <outline text="bool" _note="&#10;布尔类型，True或False"/>
                <outline text="int" collapsed="true">
                  <outline text="intc" _note="&#10;与C语言中的int类型一致，一般是int32或int64"/>
                  <outline text="intp" _note="&#10;用于索引的整数，与C语言中ssize_t一致，int32或int64"/>
                  <outline text="int8" _note="&#10;字节长度的整数，取值：[-128,127]"/>
                  <outline text="int16" _note="&#10;16位长度的整数，取值：[-32768,32767]"/>
                  <outline text="int32" _note="&#10;32位长度的整数，取值[-2的31次幂，2的31次幂-1]"/>
                  <outline text="int64" _note="&#10;64位长度的整数，取值：[-2的63次幂，2的63次幂-1]"/>
                </outline>
                <outline text="uint">
                  <outline text="uint8" _note="&#10;8位无符号整数，取值：[0,255]"/>
                  <outline text="uint16" _note="&#10;16位无符号整数，取值：[0,65535]"/>
                  <outline text="uint32" _note="&#10;32位无符号整数，取值：[0, 2的32次方-1]"/>
                  <outline text="uint64" _note="&#10;64位无符号整数，取值：[0, 2的64次幂-1]"/>
                </outline>
                <outline text="float">
                  <outline text="float16" _note="&#10;16位半精度浮点数：1位符号位，5位指数，10位尾数&#10;&#10;（符号）尾数*10的指数次幂"/>
                  <outline text="float32" _note="&#10;32位半精度浮点数：1位符号位，8位指数，23位尾数"/>
                  <outline text="float64" _note="&#10;64位半精度浮点数：1位符号位，11位指数，52位尾数"/>
                </outline>
                <outline text="comlex">
                  <outline text="complex64" _note="&#10;复数类型，实部和虚部都是32位浮点数&#10;&#10;实部（.real）+j虚部（.img）"/>
                  <outline text="complex128" _note="&#10;复数类型，实部和虚部都是64位浮点数"/>
                </outline>
              </outline>
              <outline text="非同质的ndarray对象" _note="&#10;ndarray数组可以由非同质对象构成&#10;&#10;非同质ndarray元素为对象类型&#10;&#10;非同质ndarray对象无法有效发挥NumPy优势，尽量避免&#10;&#10;实例&#10;&#10;In [13]: x = np.array([[0,1,2,3,4],[9,8,7,6]])&#10;&#10;In [14]: x.shape&#10;Out[14]: (2,)&#10;&#10;&#10;IIn [16]: x.dtype&#10;Out[16]: dtype(&apos;O&apos;)&#10;&#10;&#10;In [17]: x&#10;Out[17]: array([list([0, 1, 2, 3, 4]), list([9, 8, 7, 6])], dtype=object)&#10;&#10;&#10;In [18]: x.itemsize&#10;Out[18]: 8&#10;&#10;&#10;In [19]: x.size&#10;Out[19]: 2&#10;&#10;&#10;In [20]: x.ndim&#10;Out[20]: 1"/>
            </outline>
            <outline text="ndarray数组创建 #重点 " collapsed="true">
              <outline text="从Python中的列表、元组等类型创建ndarray数据" _note="&#10;&#10;x = np.array(list/touple)&#10;&#10;x = np.array(list/touple, dtype = np.float32)&#10;&#10;当np.array()不指定dtype时，NumPy将根据数据情况关联一个dtype类型&#10;&#10;&#10;实例&#10;&#10;```&#10;&#10;In [2]: import numpy as np&#10;&#10;&#10;In [3]: x = np.array([0,1,2,3])      # 从列表类型创建&#10;&#10;&#10;In [4]: print(x)&#10;[0 1 2 3]&#10;&#10;&#10;In [5]: x = np.array((4,5,6,7))  # 从元组类型创建&#10;&#10;&#10;In [6]: print(x)&#10;[4 5 6 7]&#10;&#10;&#10;In [10]: x = np.array([[1,2],[9,8],(0.1,0.2)])  # 从列表和元组混合类型创建&#10;&#10;&#10;In [11]: print(x)&#10;[[1. 2. ]&#10; [9. 8. ]&#10; [0.1 0.2]]&#10;```&#10;&#10;&#10;&#10;"/>
              <outline text="使用NumPy中函数创建ndarray数组，如：arange，ones，zeros等 #重点" _note="&#10;" collapsed="true">
                <outline text="np.arange(n)" _note="&#10;类似range()函数，返回ndarray类型，元素从0到n-1&#10;&#10;```&#10;&#10;In [12]: x = np.arange(10)   # 一个数&#10;&#10;In [13]: print(x)&#10;[0 1 2 3 4 5 6 7 8 9]&#10;&#10;&#10;In [15]: x = np.arange(10,12)  # 两个数取个范围&#10;&#10;In [16]: print(x)&#10;[10 11]&#10;&#10;&#10;In [17]: x = np.arange(10,20,2)  # 三个数取个步长&#10;&#10;In [18]: print(x)&#10;[10 12 14 16 18]&#10;&#10;&#10;In [21]: x = np.arange(20,10,-2)  #步长可以是负数&#10;&#10;In [22]: print(x)&#10;[20 18 16 14 12]&#10;&#10;```"/>
                <outline text="np.ones(shapes)" _note="&#10;根据shape生成一个全1数组，shape是元组类型&#10;&#10;实例&#10;&#10;```&#10;&#10;In [25]: x = np.ones(10) # 一个数字是一维列表&#10;&#10;In [26]: print(x)&#10;[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]&#10;&#10;&#10;&#10;In [28]: x = np.ones((10,10))  # 两个数字是几行几列，这里是元组形式&#10;&#10;In [29]: print(x)&#10;[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]&#10; [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]&#10; [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]&#10; [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]&#10; [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]&#10; [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]&#10; [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]&#10; [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]&#10; [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]&#10; [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]&#10;&#10;In [30]: x = np.ones([10,10])  # 两个数字是几行几列，这里是列表形式&#10;&#10;In [31]: print(x)&#10;[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]&#10; [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]&#10; [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]&#10; [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]&#10; [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]&#10; [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]&#10; [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]&#10; [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]&#10; [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]&#10; [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]&#10;&#10;&#10;&#10;x = np.ones([2,10,2])  # 三个数字是几维几行几列，元组/列表都可以&#10;&#10;print(x)&#10;[[[1. 1.]&#10;  [1. 1.]&#10;  [1. 1.]&#10;  [1. 1.]&#10;  [1. 1.]&#10;  [1. 1.]&#10;  [1. 1.]&#10;  [1. 1.]&#10;  [1. 1.]&#10;  [1. 1.]]&#10;&#10; [[1. 1.]&#10;  [1. 1.]&#10;  [1. 1.]&#10;  [1. 1.]&#10;  [1. 1.]&#10;  [1. 1.]&#10;  [1. 1.]&#10;  [1. 1.]&#10;  [1. 1.]&#10;  [1. 1.]]]&#10;&#10;```"/>
                <outline text="np.zeros(shape)" _note="&#10;根据shpe生成一个全0数组，shape是元组类型&#10;&#10;实例&#10;&#10;```&#10;&#10;In [36]: x = np.zeros([2,10,2])&#10;&#10;&#10;In [37]: print(x)&#10;[[[0. 0.]&#10; [0. 0.]&#10; [0. 0.]&#10; [0. 0.]&#10; [0. 0.]&#10; [0. 0.]&#10; [0. 0.]&#10; [0. 0.]&#10; [0. 0.]&#10; [0. 0.]]&#10;&#10;&#10; [[0. 0.]&#10; [0. 0.]&#10; [0. 0.]&#10; [0. 0.]&#10; [0. 0.]&#10; [0. 0.]&#10; [0. 0.]&#10; [0. 0.]&#10; [0. 0.]&#10; [0. 0.]]]&#10;&#10;&#10;In [43]: x = np.zeros((3,6),dtype=np.int32)&#10;&#10;In [44]: print(x)&#10;[[0 0 0 0 0 0]&#10; [0 0 0 0 0 0]&#10; [0 0 0 0 0 0]]&#10;&#10;```"/>
                <outline text="np.full(shape, val)" _note="&#10;根据shape生成一个数组，每个元素都是val&#10;&#10;实例&#10;&#10;```&#10;&#10;In [39]: x = np.full([2,10,2],2)&#10;&#10;&#10;In [40]: print(x)&#10;[[[2 2]&#10; [2 2]&#10; [2 2]&#10; [2 2]&#10; [2 2]&#10; [2 2]&#10; [2 2]&#10; [2 2]&#10; [2 2]&#10; [2 2]]&#10;&#10;&#10; [[2 2]&#10; [2 2]&#10; [2 2]&#10; [2 2]&#10; [2 2]&#10; [2 2]&#10; [2 2]&#10; [2 2]&#10; [2 2]&#10; [2 2]]]&#10;&#10;```"/>
                <outline text="np.eye(n) #难点" _note="&#10;创建一个正方的n*n单位矩阵，对角线为1，其余为0&#10;&#10;&#10;实例&#10;&#10;```&#10;&#10;In [41]: x = np.eye(5)&#10;&#10;In [42]: print(x)&#10;[[1. 0. 0. 0. 0.]&#10; [0. 1. 0. 0. 0.]&#10; [0. 0. 1. 0. 0.]&#10; [0. 0. 0. 1. 0.]&#10; [0. 0. 0. 0. 1.]]&#10;&#10;&#10;In [46]: x = np.eye(5,dtype=np.int32)&#10;&#10;In [47]: print(x)&#10;[[1 0 0 0 0]&#10; [0 1 0 0 0]&#10; [0 0 1 0 0]&#10; [0 0 0 1 0]&#10; [0 0 0 0 1]]&#10;&#10;```"/>
                <outline text="np.ones_like(a)" _note="&#10;根据数组a的形状生成一个全1数组&#10;&#10;"/>
                <outline text="np.zeros_like(a)" _note="&#10;根据数据a的形状生成一个全0的数组&#10;&#10;实例&#10;&#10;In [3]: a = np.arange(3,10)&#10;&#10;&#10;In [4]: print(a)&#10;[3 4 5 6 7 8 9]&#10;&#10;&#10;In [5]: b = np.zeros_like(a)&#10;&#10;&#10;In [6]: print(b)&#10;[0 0 0 0 0 0 0]&#10;&#10;&#10;In [7]: b&#10;Out[7]: array([0, 0, 0, 0, 0, 0, 0])&#10;&#10;"/>
                <outline text="np.full_like(a, val)" _note="&#10;根据数组a的形状生成一个数组，每个元素值都是val&#10;&#10;实例&#10;&#10;In [11]: a = np.ones((2,3,4))&#10;&#10;&#10;In [12]: a&#10;Out[12]: &#10;array([[[1., 1., 1., 1.],&#10; [1., 1., 1., 1.],&#10; [1., 1., 1., 1.]],&#10;&#10;&#10; [[1., 1., 1., 1.],&#10; [1., 1., 1., 1.],&#10; [1., 1., 1., 1.]]])&#10;&#10;&#10;In [13]: c = np.full_like(a,8)&#10;&#10;&#10;In [14]: c&#10;Out[14]: &#10;array([[[8., 8., 8., 8.],&#10; [8., 8., 8., 8.],&#10; [8., 8., 8., 8.]],&#10;&#10;&#10; [[8., 8., 8., 8.],&#10; [8., 8., 8., 8.],&#10; [8., 8., 8., 8.]]])&#10;&#10;&#10;"/>
                <outline text="np.linspace() #难点" _note="&#10;根据起止数据等间距地填充数据，形成数组&#10;&#10;输入：起始数，终止数，等间距分隔的个数&#10;&#10;输出：等间距填充数据&#10;&#10;注意：没有 endpoint，默认为endpoint=True终止数为输出的最后一个数字；有endpoint=False，则最后输出的数字不包括终止数&#10;&#10;实例&#10;&#10;```&#10;&#10;In [73]: a = np.linspace(1,10,4)   # 4是个数，将1到10等间距分成4个数。&#10;&#10;&#10;In [74]: a&#10;Out[74]: array([ 1., 4., 7., 10.])&#10;&#10;&#10;In [75]: a = np.linspace(1,10,3)&#10;&#10;&#10;In [76]: a&#10;Out[76]: array([ 1. , 5.5, 10. ])&#10;&#10;&#10;In [77]: a = np.linspace(1,10,8)&#10;&#10;&#10;In [78]: a&#10;Out[78]: &#10;array([ 1. , 2.28571429, 3.57142857, 4.85714286, 6.14285714,&#10; 7.42857143, 8.71428571, 10. ])&#10;&#10;&#10;In [19]: d = np.linspace(2,18) #没有个数的时候，默认分成50个数。&#10;&#10;&#10;In [20]: d&#10;Out[20]: &#10;array([ 2. , 2.32653061, 2.65306122, 2.97959184, 3.30612245,&#10; 3.63265306, 3.95918367, 4.28571429, 4.6122449 , 4.93877551,&#10; 5.26530612, 5.59183673, 5.91836735, 6.24489796, 6.57142857,&#10; 6.89795918, 7.2244898 , 7.55102041, 7.87755102, 8.20408163,&#10; 8.53061224, 8.85714286, 9.18367347, 9.51020408, 9.83673469,&#10; 10.16326531, 10.48979592, 10.81632653, 11.14285714, 11.46938776,&#10; 11.79591837, 12.12244898, 12.44897959, 12.7755102 , 13.10204082,&#10; 13.42857143, 13.75510204, 14.08163265, 14.40816327, 14.73469388,&#10; 15.06122449, 15.3877551 , 15.71428571, 16.04081633, 16.36734694,&#10; 16.69387755, 17.02040816, 17.34693878, 17.67346939, 18. ])&#10;&#10;&#10;&#10;In [23]: d = np.linspace(2,18,dtype=np.int32)&#10;&#10;&#10;In [24]: d&#10;Out[24]: &#10;array([ 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7,&#10; 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12,&#10; 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18])&#10;&#10;&#10;&#10;In [84]: b = np.linspace(1,10,4,endpoint= False)  #  endpoint= False是指不包括10&#10;&#10;&#10;In [85]: b&#10;Out[85]: array([1. , 3.25, 5.5 , 7.75])&#10;&#10;```"/>
                <outline text="np.concatenate() #难点" _note="&#10;将两个或多个数组合并成一个新的数组&#10;&#10;输入：一维数组，或同维度有相同数量行和列的多维数组&#10;&#10;输出：不改变原数组，生成新数组&#10;&#10;实例&#10;&#10;```&#10;&#10;In [58]: d&#10;Out[58]: &#10;array([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,&#10; 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,&#10; 4, 4, 4, 4, 4, 5])&#10;&#10;&#10;In [59]: a&#10;Out[59]: array([2, 3, 4])&#10;&#10;&#10;In [60]: e = np.concatenate((a,d))&#10;&#10;&#10;In [61]: e&#10;Out[61]: &#10;array([2, 3, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3,&#10; 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,&#10; 4, 4, 4, 4, 4, 4, 4, 4, 5])&#10;&#10;&#10;In [62]: e = np.concatenate((d,a))&#10;&#10;&#10;In [63]: e&#10;Out[63]: &#10;array([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,&#10; 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,&#10; 4, 4, 4, 4, 4, 5, 2, 3, 4])&#10;&#10;&#10;&#10;&#10;In [68]: b = np.full((2,3,4),5)&#10;&#10;&#10;In [69]: b&#10;Out[69]: &#10;array([[[5, 5, 5, 5],&#10; [5, 5, 5, 5],&#10; [5, 5, 5, 5]],&#10;&#10;&#10; [[5, 5, 5, 5],&#10; [5, 5, 5, 5],&#10; [5, 5, 5, 5]]])&#10;&#10;&#10;In [70]: e = np.concatenate((c,b))&#10;&#10;&#10;In [71]: e&#10;Out[71]: &#10;array([[[8., 8., 8., 8.],&#10; [8., 8., 8., 8.],&#10; [8., 8., 8., 8.]],&#10;&#10;&#10; [[8., 8., 8., 8.],&#10; [8., 8., 8., 8.],&#10; [8., 8., 8., 8.]],&#10;&#10;&#10; [[5., 5., 5., 5.],&#10; [5., 5., 5., 5.],&#10; [5., 5., 5., 5.]],&#10;&#10;&#10; [[5., 5., 5., 5.],&#10; [5., 5., 5., 5.],&#10; [5., 5., 5., 5.]]])&#10;&#10;&#10;&#10;In [82]: a = np.linspace(1,10,4)&#10;&#10;&#10;In [83]: a&#10;Out[83]: array([ 1., 4., 7., 10.])&#10;&#10;&#10;In [84]: b = np.linspace(1,10,4,endpoint= False)&#10;&#10;&#10;In [85]: b&#10;Out[85]: array([1. , 3.25, 5.5 , 7.75])&#10;&#10;&#10;In [86]: c= np.concatenate((a,b))&#10;&#10;&#10;In [87]: c&#10;Out[87]: array([ 1. , 4. , 7. , 10. , 1. , 3.25, 5.5 , 7.75])&#10;```&#10;"/>
              </outline>
              <outline text="从字节流（raw bytes）中创建ndarray数组"/>
              <outline text="从文件中读取特定格式，创建ndarray数组"/>
            </outline>
            <outline text="ndarray数组的变换 #重点 " _note="&#10;对于创建后 的ndarray数组，可以对其进行维度变换和元素类型变换&#10;&#10;" collapsed="true">
              <outline text="ndarray数组的维度变换 #难点 " collapsed="true">
                <outline text=".reshape(shape)" _note="&#10;不改变数组元素，返回一个shape形状的的数组，原数组不变&#10;&#10;```&#10;&#10;a = np.ones((2, 3, 4), dtype = np.int32)&#10;&#10;b= a.reshape(4,6)&#10;&#10;b&#10;Out[92]: &#10;array([[1, 1, 1, 1, 1, 1],&#10;       [1, 1, 1, 1, 1, 1],&#10;       [1, 1, 1, 1, 1, 1],&#10;       [1, 1, 1, 1, 1, 1]])&#10;&#10;```"/>
                <outline text=".resize(shape)" _note="&#10;与.reshape()功能一致，但修改原数组&#10;&#10;实例&#10;&#10;```&#10;&#10;a.resize(4,6)&#10;&#10;a&#10;Out[95]: &#10;array([[1, 1, 1, 1, 1, 1],&#10;       [1, 1, 1, 1, 1, 1],&#10;       [1, 1, 1, 1, 1, 1],&#10;       [1, 1, 1, 1, 1, 1]])&#10;&#10;```"/>
                <outline text=".swapaxes(ax1, ax2)" _note="&#10;将数组n个维度中两个维度进行调换&#10;&#10;```&#10;&#10;a = np.ones((2, 3, 4), dtype = np.int32) &#10;&#10;a&#10;Out[109]: &#10;array([[[1, 1, 1, 1],&#10;        [1, 1, 1, 1],&#10;        [1, 1, 1, 1]],&#10;&#10;       [[1, 1, 1, 1],&#10;        [1, 1, 1, 1],&#10;        [1, 1, 1, 1]]])&#10;&#10;a.swapaxes(2,1)    #参数为2个，每个数值不能超过3，将行和列转换。&#10;Out[110]: &#10;array([[[1, 1, 1],&#10;        [1, 1, 1],&#10;        [1, 1, 1],&#10;        [1, 1, 1]],&#10;&#10;       [[1, 1, 1],&#10;        [1, 1, 1],&#10;        [1, 1, 1],&#10;        [1, 1, 1]]])&#10;&#10;```"/>
                <outline text=".flatten()" _note="&#10;对数组进行降维，返回折叠后的一维数组，原数组不变。&#10;&#10;```&#10;&#10;&#10;In [119]: a = np.ones((2, 3, 4), dtype = np.int32)  #只能变成一维数组&#10;&#10;&#10;In [120]: a.flatten()&#10;Out[120]: &#10;array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,&#10; 1, 1])&#10;&#10;```"/>
              </outline>
              <outline text="ndarray数组的类型变换 #难点 " collapsed="true">
                <outline text="new_a = a.astype(new_type)" _note="&#10;astype()方法一定会创建新的数组（原始数据的一个拷贝），即使两个类型一致&#10;&#10;输入：np数组，要变成的数组类型&#10;&#10;输出：新的数组，原数组不变&#10;&#10;&#10;```&#10;In [126]: a = np.ones((2,3,4),dtype=np.int)&#10;&#10;&#10;In [127]: a&#10;Out[127]: &#10;array([[[1, 1, 1, 1],&#10; [1, 1, 1, 1],&#10; [1, 1, 1, 1]],&#10;&#10;&#10; [[1, 1, 1, 1],&#10; [1, 1, 1, 1],&#10; [1, 1, 1, 1]]])&#10;&#10;&#10;In [128]: b= a.astype(np.float)&#10;&#10;&#10;In [129]: b&#10;Out[129]: &#10;array([[[1., 1., 1., 1.],&#10; [1., 1., 1., 1.],&#10; [1., 1., 1., 1.]],&#10;&#10;&#10; [[1., 1., 1., 1.],&#10; [1., 1., 1., 1.],&#10; [1., 1., 1., 1.]]])&#10;&#10;In [130]: c = a.astype(np.complex)&#10;&#10;&#10;In [131]: c&#10;Out[131]: &#10;array([[[1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j],&#10; [1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j],&#10; [1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j]],&#10;&#10;&#10; [[1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j],&#10; [1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j],&#10; [1.+0.j, 1.+0.j, 1.+0.j, 1.+0.j]]])&#10;&#10;&#10;# 可以加多少位的浮点数&#10;c= a.astype(np.float32)&#10;&#10;c&#10;Out[126]: &#10;array([[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.],&#10;       [ 9., 10., 11., 12., 13., 14., 15., 16.],&#10;       [17., 18., 19., 20., 21., 22., 23., 24.]], dtype=float32)&#10;&#10;```"/>
              </outline>
              <outline text="ndarray数组向列表的转换 #难点 " collapsed="true">
                <outline text="ls = a.tolist()" _note="&#10;把一个数组变成列表&#10;&#10;```&#10;In [133]: a = np.ones((2,3,4),dtype=np.int)&#10;&#10;&#10;In [134]: a&#10;Out[134]: &#10;array([[[1, 1, 1, 1],&#10; [1, 1, 1, 1],&#10; [1, 1, 1, 1]],&#10;&#10;&#10; [[1, 1, 1, 1],&#10; [1, 1, 1, 1],&#10; [1, 1, 1, 1]]])&#10;&#10;&#10;In [135]: a.tolist()&#10;Out[135]: &#10;[[[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],&#10; [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]]&#10;```"/>
              </outline>
            </outline>
            <outline text="ndarray数组的操作 #重点" _note="&#10;数组的索引和切片" collapsed="true">
              <outline text="索引：获取数组中特定位置元素的过程"/>
              <outline text="切片：获取数组元素子集的过程"/>
              <outline text="一维数组的索引和切片：和Python的列表类似" _note="&#10;```&#10;In [138]: a = np.array([9,8,7,6,5])&#10;&#10;&#10;In [139]: a&#10;Out[139]: array([9, 8, 7, 6, 5])&#10;&#10;&#10;In [140]: a[2]&#10;Out[140]: 7&#10;&#10;&#10;In [141]: a[1:4:2]&#10;Out[141]: array([8, 6])&#10;&#10;```"/>
              <outline text="多维数组的索引 #难点" _note="&#10;&#10;```&#10;In [142]: a = np.arange(24).reshape((2,3,4))  # 将arange产生的一维数据变成多维数据&#10;&#10;&#10;In [143]: a&#10;Out[143]: &#10;array([[[ 0, 1, 2, 3],&#10; [ 4, 5, 6, 7],&#10; [ 8, 9, 10, 11]],&#10;&#10;&#10; [[12, 13, 14, 15],&#10; [16, 17, 18, 19],&#10; [20, 21, 22, 23]]])&#10;&#10;&#10;In [144]: a[1,2,3]    &#10;Out[144]: 23&#10;&#10;&#10;In [145]: a[0,1,2]&#10;Out[145]: 6&#10;&#10;&#10;In [146]: a[-1,-2,-3]          # 每个维度一个索引值，逗号分隔，              &#10;Out[146]: 17&#10;```"/>
              <outline text="多维数组的切片 #难点" _note="&#10;```&#10;In [147]: a = np.arange(24).reshape((2,3,4))&#10;&#10;&#10;In [148]: a&#10;Out[148]: &#10;array([[[ 0, 1, 2, 3],&#10; [ 4, 5, 6, 7],&#10; [ 8, 9, 10, 11]],&#10;&#10;&#10; [[12, 13, 14, 15],&#10; [16, 17, 18, 19],&#10; [20, 21, 22, 23]]])&#10;&#10;&#10;In [149]: a[:,1,-3]                       #选取一个维度用:   这是选取每个维度第二行倒数第三个数&#10;Out[149]: array([ 5, 17])&#10;&#10;&#10;In [150]: a[:,1:3,:]     #每个维度切片方法与一维数组相同，这是选取第2行和第3行&#10;Out[150]: &#10;array([[[ 4, 5, 6, 7],&#10; [ 8, 9, 10, 11]],&#10;&#10;&#10; [[16, 17, 18, 19],&#10; [20, 21, 22, 23]]])&#10;&#10;&#10;In [151]: a[:,:,::2]    #每个维度可以使用步长跳跃切片&#10;Out[151]: &#10;array([[[ 0, 2],&#10; [ 4, 6],&#10; [ 8, 10]],&#10;&#10;&#10; [[12, 14],&#10; [16, 18],&#10; [20, 22]]])&#10;```"/>
            </outline>
            <outline text="naarray数组的运算" collapsed="true">
              <outline text="数组与标量之间的运算" _note="&#10;数组与标量之间的运算作用于数组的每一个元素&#10;&#10;```&#10;In [152]: a = np.arange(24).reshape((2,3,4))&#10;&#10;&#10;In [153]: a&#10;Out[153]: &#10;array([[[ 0, 1, 2, 3],&#10; [ 4, 5, 6, 7],&#10; [ 8, 9, 10, 11]],&#10;&#10;&#10; [[12, 13, 14, 15],&#10; [16, 17, 18, 19],&#10; [20, 21, 22, 23]]])&#10;&#10;&#10;In [154]: a.mean()&#10;Out[154]: 11.5&#10;&#10;&#10;In [155]: a= a/a.mean()&#10;&#10;&#10;In [156]: a&#10;Out[156]: &#10;array([[[0. , 0.08695652, 0.17391304, 0.26086957],&#10; [0.34782609, 0.43478261, 0.52173913, 0.60869565],&#10; [0.69565217, 0.7826087 , 0.86956522, 0.95652174]],&#10;&#10;&#10; [[1.04347826, 1.13043478, 1.2173913 , 1.30434783],&#10; [1.39130435, 1.47826087, 1.56521739, 1.65217391],&#10; [1.73913043, 1.82608696, 1.91304348, 2. ]]])&#10;&#10;```"/>
              <outline text="NumPy一元函数 #重点  #难点 " _note="&#10;对ndarray中的数据执行元素级运算的函数&#10;&#10;" collapsed="true">
                <outline text="np.abs(x) " _note="&#10;计算数组各元素的绝对值&#10;&#10;```&#10;&#10;In [199]: a = np.array([9,-8.4])&#10;&#10;&#10;In [200]: a&#10;Out[200]: array([ 9. , -8.4])&#10;&#10;&#10;In [201]: b=np.abs(a)&#10;&#10;&#10;In [202]: b&#10;Out[202]: array([9. , 8.4])&#10;```&#10;&#10;"/>
                <outline text="np.fabs(x)" _note="&#10;计算数组各元素的绝对值，返回浮点数&#10;&#10;&#10;实例&#10;&#10;```&#10;&#10;In [191]: a =np.array([-2,4,-5])&#10;&#10;In [196]: b =np.fabs(a)&#10;&#10;&#10;In [197]: b&#10;Out[197]: array([2., 4., 5.])&#10;&#10;```"/>
                <outline text="np.sqrt(x)" _note="&#10;计算数组各元素的平方根&#10;&#10;实例&#10;```&#10;&#10;In [202]: b&#10;Out[202]: array([9. , 8.4])&#10;&#10;&#10;In [203]: c = np.sqrt(b)&#10;&#10;&#10;In [204]: c&#10;Out[204]: array([3. , 2.89827535])&#10;&#10;```"/>
                <outline text="np.square(x)" _note="&#10;计算数组各元素的平方&#10;&#10;实例&#10;&#10;```&#10;&#10;In [204]: c&#10;Out[204]: array([3. , 2.89827535])&#10;&#10;&#10;In [205]: c= np.square(c)&#10;&#10;&#10;In [206]: c&#10;Out[206]: array([9. , 8.4])&#10;```"/>
                <outline text="np.log(x)" _note="&#10;计算数组各元素的自然对数&#10;&#10;实例&#10;&#10;```&#10;&#10;In [206]: c&#10;Out[206]: array([9. , 8.4])&#10;&#10;&#10;In [207]: d = np.log(c)&#10;&#10;&#10;In [208]: d&#10;Out[208]: array([2.19722458, 2.12823171])&#10;```&#10;&#10;"/>
                <outline text="np.log2(x)" _note="&#10;&#10;计算数组各元素的2底对数&#10;&#10;实例&#10;```&#10;&#10;In [212]: c&#10;Out[212]: array([9. , 8.4])&#10;&#10;&#10;In [213]: d = np.log2(c)&#10;&#10;&#10;In [214]: d&#10;Out[214]: array([3.169925 , 3.07038933])&#10;&#10;```&#10;"/>
                <outline text="np.log10(x)" _note="&#10;&#10;计算数组各元素的10底对数&#10;&#10;实例&#10;```&#10;&#10;In [209]: c&#10;Out[209]: array([9. , 8.4])&#10;&#10;&#10;In [210]: d = np.log10(c)&#10;&#10;&#10;In [211]: d&#10;Out[211]: array([0.95424251, 0.92427929])&#10;&#10;```"/>
                <outline text="np.ceil(x)" _note="&#10;计算数组各元素的ceiling值&#10;&#10;实例&#10;&#10;```&#10;&#10;In [221]: d&#10;Out[221]: array([3.169925 , 3.07038933])&#10;&#10;&#10;In [222]: e = np.ceil(d)&#10;&#10;&#10;In [223]: e&#10;Out[223]: array([4., 4.])&#10;&#10;```"/>
                <outline text="np.floor(x)" _note="&#10;计算数组各元素的floor值&#10;&#10;实例&#10;&#10;```&#10;&#10;In [224]: d &#10;Out[224]: array([3.169925 , 3.07038933])&#10;&#10;&#10;In [225]: e = np.floor(d)&#10;&#10;&#10;In [226]: e&#10;Out[226]: array([3., 3.])&#10;&#10;```"/>
                <outline text="np.rint(x)" _note="&#10;计算各数组各元素的四舍五入值&#10;&#10;实例&#10;&#10;```&#10;&#10;In [229]: d&#10;Out[229]: array([3.169925 , 3.07038933])&#10;&#10;&#10;In [230]: e = np.rint(d)&#10;&#10;&#10;In [231]: e&#10;Out[231]: array([3., 3.])&#10;&#10;```"/>
                <outline text="np.modf(x)" _note="&#10;将数组各元素的小数和整数部分已两个独立数组形式返回&#10;&#10;```&#10;&#10;In [234]: d&#10;Out[234]: array([3.169925 , 3.07038933])&#10;&#10;&#10;In [235]: e = np.modf(e)&#10;&#10;&#10;In [236]: e&#10;Out[236]: (array([0., 0.]), array([3., 3.]))&#10;&#10;```"/>
                <outline text="np.cos(x)   np.cosh(x)   np.sin(x)    np.sinh(x)  np.tan(x)   np.tanh(x)" _note="&#10;计算数组各元素的普通型和双曲线型三角函数&#10;&#10;&#10;实例&#10;&#10;```&#10;&#10;In [243]: d&#10;Out[243]: array([3.169925 , 3.07038933])&#10;&#10;&#10;In [244]: e = np.sin(d)&#10;&#10;&#10;In [245]: e&#10;Out[245]: array([-0.02832856, 0.07114318])&#10;&#10;&#10;In [246]: e= np.sinh(d)&#10;&#10;&#10;In [247]: e&#10;Out[247]: array([11.88184607, 10.75194404])&#10;&#10;&#10;In [248]: e =np.cos(d)&#10;&#10;&#10;In [249]: e&#10;Out[249]: array([-0.99959867, -0.99746611])&#10;&#10;&#10;In [250]: e = np.cosh(d)&#10;&#10;&#10;In [251]: e&#10;Out[251]: array([11.92385282, 10.79834713])&#10;&#10;&#10;In [254]: e = np.tan(d)&#10;&#10;&#10;In [255]: e&#10;Out[255]: array([ 0.02833993, -0.0713239 ])&#10;&#10;&#10;In [256]: e = np.tanh(d)&#10;&#10;&#10;In [257]: e&#10;Out[257]: array([0.99647708, 0.99570276])&#10;&#10;```"/>
                <outline text="np.exp(x)" _note="&#10;计算数组各元素的指数值&#10;&#10;```&#10;&#10;In [260]: d&#10;Out[260]: array([3.169925 , 3.07038933])&#10;&#10;&#10;In [261]: e = np.exp(d)&#10;&#10;&#10;In [262]: e&#10;Out[262]: array([23.8056989 , 21.55029117])&#10;&#10;```"/>
                <outline text="np.sign(x)" _note="&#10;计算数组各元素的符号值，1（+），0，-1（-）&#10;&#10;```&#10;&#10;In [270]: d&#10;Out[270]: array([ 14, 0, -45])&#10;&#10;&#10;In [271]: e =np.sign(d)&#10;&#10;&#10;In [272]: e&#10;Out[272]: array([ 1, 0, -1])  # 1代表正值，0代表0，-1代表负值&#10;&#10;```&#10;&#10;"/>
              </outline>
              <outline text="NumPy二元函数 #重点  #难点 ">
                <outline text="+   -   *   /   **  %" _note="&#10;两个数组各元素进行对应运算&#10;&#10;&#10;实例&#10;&#10;```&#10;&#10;In [275]: a = np.arange(1,12,2).reshape(2,3)&#10;&#10;&#10;In [276]: a&#10;Out[276]: &#10;array([[ 1, 3, 5],&#10; [ 7, 9, 11]])&#10;&#10;&#10;In [277]: b = np.arange(1,7).reshape(2,3)&#10;&#10;&#10;In [278]: b&#10;Out[278]: &#10;array([[1, 2, 3],&#10; [4, 5, 6]])&#10;&#10;&#10;In [279]: a+b&#10;Out[279]: &#10;array([[ 2, 5, 8],&#10; [11, 14, 17]])&#10;&#10;&#10;In [280]: a -b&#10;Out[280]: &#10;array([[0, 1, 2],&#10; [3, 4, 5]])&#10;&#10;&#10;In [281]: a *b&#10;Out[281]: &#10;array([[ 1, 6, 15],&#10; [28, 45, 66]])&#10;&#10;&#10;In [282]: a/b&#10;Out[282]: &#10;array([[1. , 1.5 , 1.66666667],&#10; [1.75 , 1.8 , 1.83333333]])&#10;&#10;&#10;In [283]: a**b&#10;Out[283]: &#10;array([[ 1, 9, 125],&#10; [ 2401, 59049, 1771561]], dtype=int32)&#10;&#10;```"/>
                <outline text="np.maximum(x,y)   np.fmax()    np.minimun(x,y)   np.fmin()" _note="&#10;元素级的最大值/最小值计算，&#10;&#10;```&#10;&#10;In [290]: b&#10;Out[290]: &#10;array([[ 7, 8, 9],&#10; [10, 11, 12]])&#10;&#10;&#10;In [291]: a&#10;Out[291]: &#10;array([[ 1, 3, 5],&#10; [ 7, 9, 11]])&#10;&#10;&#10;In [292]: np.minimum(a,b)&#10;Out[292]: &#10;array([[ 1, 3, 5],&#10; [ 7, 9, 11]])&#10;&#10;&#10;In [293]: np.maximum(a,b)&#10;Out[293]: &#10;array([[ 7, 8, 9],&#10; [10, 11, 12]])&#10;&#10;&#10;In [294]: np.fmax(a,b)&#10;Out[294]: &#10;array([[ 7, 8, 9],&#10; [10, 11, 12]])&#10;&#10;&#10;In [295]: np.fmin(a,b)&#10;Out[295]: &#10;array([[ 1, 3, 5],&#10; [ 7, 9, 11]])&#10;&#10;```"/>
                <outline text="np.mod(x,y)" _note="&#10;元素级的模运算，即求x/y的余数&#10;&#10;```&#10;&#10;In [14]: a&#10;Out[14]: &#10;array([[ 2, 3, 4, 5, 6, 7],&#10; [ 8, 9, 10, 11, 12, 13],&#10; [14, 15, 16, 17, 18, 19],&#10; [20, 21, 22, 23, 24, 25]])&#10;&#10;&#10;In [15]: b&#10;Out[15]: &#10;array([[ 0, 1, 2, 3, 4, 5],&#10; [ 6, 7, 8, 9, 10, 11],&#10; [12, 13, 14, 15, 16, 17],&#10; [18, 19, 20, 21, 22, 23]])&#10;&#10;&#10;In [16]: np.mod(a,b)&#10;&lt;ipython-input-16-2a4695c40758&gt;:1: RuntimeWarning: divide by zero encountered in remainder&#10; np.mod(a,b)&#10;Out[16]: &#10;array([[0, 0, 0, 2, 2, 2],&#10; [2, 2, 2, 2, 2, 2],&#10; [2, 2, 2, 2, 2, 2],&#10; [2, 2, 2, 2, 2, 2]], dtype=int32)&#10;&#10;```&#10;&#10;"/>
                <outline text="np.copysign(x,y)" _note="&#10;将数组y中各元素之的符号值赋值给数组x对应元素&#10;&#10;```&#10;&#10;In [297]: a = np.array([-1,2,4])&#10;&#10;&#10;In [298]: b= np.array([1,2,3])&#10;&#10;&#10;In [299]: np.copysign(a,b)&#10;Out[299]: array([1., 2., 4.])&#10;&#10;&#10;In [300]: np.copysign(b,a)&#10;Out[300]: array([-1., 2., 3.])&#10;```"/>
                <outline text="&gt;  &lt;   &gt;=  &lt;=  ==   !=" _note="&#10;算术比较，产生布尔型数组&#10;&#10;```&#10;&#10;In [297]: a = np.array([-1,2,4])&#10;&#10;&#10;In [298]: b= np.array([1,2,3])&#10;&#10;&#10;In [301]: a &gt; b&#10;Out[301]: array([False, False, True])&#10;&#10;&#10;In [302]: a &lt; b&#10;Out[302]: array([ True, False, False])&#10;&#10;&#10;In [303]: a &gt;= b&#10;Out[303]: array([False, True, True])&#10;&#10;&#10;In [304]: a &lt;= b&#10;Out[304]: array([ True, True, False])&#10;&#10;&#10;In [305]: a == b&#10;Out[305]: array([False, True, False])&#10;&#10;&#10;In [306]: a != b&#10;Out[306]: array([ True, False, True])&#10;```"/>
              </outline>
            </outline>
          </outline>
          <outline text="单元2：Numpy数据存取与函数" collapsed="true">
            <outline text="数据的CSV文件存取" collapsed="true">
              <outline text="CSV文件" _note="&#10;CSV(Comma-Separated Value，逗号分隔值)&#10;&#10;CSV是一种比较常见的文件格式，用来存储批量数据"/>
              <outline text="np.savetxt(frame, array, fmt = &apos;%.18e&apos;, delimiter=None)" _note="&#10;生成一个a.csv文件，可以通过notepad或excel打开&#10;&#10;frame ：文件、字符串或产生器，可以是.gz或.bz2的压缩文件&#10;&#10;array：存入文件的数组&#10;&#10;fmt：写入文件的格式，例如：%d %.2f   %.18e&#10;&#10;delimiter：分隔字符串，默认是任何空格&#10;&#10;&#10;实例&#10;&#10;```&#10;&#10;In [8]: a = np.arange(100).reshape(5,20)&#10;&#10;&#10;In [9]: np.savetxt(&apos;a.csv&apos;, a, fmt=&apos;%d&apos;, delimiter=&apos;,&apos;)&#10;&#10;&#10;&#10;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19&#10;20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39&#10;40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59&#10;60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79&#10;80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99&#10;&#10;&#10;&#10;In [10]: a = np.arange(100).reshape(5,20)&#10;&#10;In [11]: np.savetxt(&apos;a.csv&apos;, a, fmt=&apos;%.1f&apos;, delimiter=&apos;,&apos;)&#10;&#10;&#10;0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0,18.0,19.0&#10;20.0,21.0,22.0,23.0,24.0,25.0,26.0,27.0,28.0,29.0,30.0,31.0,32.0,33.0,34.0,35.0,36.0,37.0,38.0,39.0&#10;40.0,41.0,42.0,43.0,44.0,45.0,46.0,47.0,48.0,49.0,50.0,51.0,52.0,53.0,54.0,55.0,56.0,57.0,58.0,59.0&#10;60.0,61.0,62.0,63.0,64.0,65.0,66.0,67.0,68.0,69.0,70.0,71.0,72.0,73.0,74.0,75.0,76.0,77.0,78.0,79.0&#10;80.0,81.0,82.0,83.0,84.0,85.0,86.0,87.0,88.0,89.0,90.0,91.0,92.0,93.0,94.0,95.0,96.0,97.0,98.0,99.0&#10;&#10;```"/>
              <outline text="np.loadtxt(frame, dtype=np.float,  delimiter=None, unpack=False )" _note="&#10;读取一个csv文件&#10;&#10;frame ：文件、字符串或产生器，可以是.gz或.bz2的压缩文件&#10;&#10;dtype：数据类型，可选&#10;&#10;delimiter：分隔字符串，默认是任何空格&#10;&#10;unpack ：如果True，读入属性将分别写入不同变量&#10;&#10;```&#10;&#10;In [16]: a = np.arange(100).reshape(5,20)&#10;&#10;In [17]: np.savetxt(&apos;a.csv&apos;,a ,fmt=&apos;%.1f&apos;,delimiter=&apos;,&apos;)&#10;&#10;In [18]: b = np.loadtxt(&apos;a.csv&apos;,delimiter = &apos;,&apos;)&#10;&#10;In [19]: b&#10;Out[19]: &#10;array([[ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12.,&#10;        13., 14., 15., 16., 17., 18., 19.],&#10;       [20., 21., 22., 23., 24., 25., 26., 27., 28., 29., 30., 31., 32.,&#10;        33., 34., 35., 36., 37., 38., 39.],&#10;       [40., 41., 42., 43., 44., 45., 46., 47., 48., 49., 50., 51., 52.,&#10;        53., 54., 55., 56., 57., 58., 59.],&#10;       [60., 61., 62., 63., 64., 65., 66., 67., 68., 69., 70., 71., 72.,&#10;        73., 74., 75., 76., 77., 78., 79.],&#10;       [80., 81., 82., 83., 84., 85., 86., 87., 88., 89., 90., 91., 92.,&#10;        93., 94., 95., 96., 97., 98., 99.]])&#10;&#10;In [20]: b = np.loadtxt(&apos;a.csv&apos;,dtype=np.int,delimiter = &apos;,&apos;)&#10;&#10;&#10;In [21]: b&#10;Out[21]: &#10;array([[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,&#10; 16, 17, 18, 19],&#10; [20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,&#10; 36, 37, 38, 39],&#10; [40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,&#10; 56, 57, 58, 59],&#10; [60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,&#10; 76, 77, 78, 79],&#10; [80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,&#10; 96, 97, 98, 99]])&#10;```&#10;"/>
              <outline text="CSV文件的局限性" _note="&#10;csv只能有效存储一维和二维数组&#10;&#10;np.savetxt()和np.loadtxt()只能有效存取一维和二维数组"/>
            </outline>
            <outline text="多维数据的存取" _note="&#10;存取任意维度的数据" collapsed="true">
              <outline text="a.tofile(frame, sep=&apos; &apos;, format=&apos;%s&apos;)" _note="&#10;存成一个文件，如果是.dat文件，可以用notepad打开。&#10;&#10;frame：文件、字符串&#10;&#10;sep：数据分割字符串，如果是空串，写入文件为二进制&#10;&#10;format：写入数据的格式&#10;&#10;```&#10;&#10;In [24]: a = np.arange(100).reshape(5,10,2)&#10;&#10;&#10;In [25]: a.tofile(&quot;b.dat&quot;,sep=&quot;,&quot;, format=&apos;%d&apos;)   #可以用noetpad打开，打开后为0到99的数字&#10;&#10;a.tofile(&quot;b.dat&quot;, format=&apos;%d&apos;)  # 可以用notepada打开，打开后为字符&#10;&#10;```&#10;"/>
              <outline text="np.fromfile(frame, dtype = float, count = -1, seq=&apos;&apos;)" _note="&#10;读取一个文件&#10;&#10;frame：文件、字符串&#10;&#10;dtype：读取的数据类型&#10;&#10;count：读入元素个数，-1表示读入整个文件&#10;&#10;sep：数据分割字符串，如果是空串，写入文件为二进制&#10;&#10;```&#10;&#10;In [29]: a = np.arange(100).reshape(5,10,2)&#10;&#10;&#10;In [30]: a.tofile(&quot;b.dat&quot;,sep=&quot;,&quot;,format=&apos;%d&apos;)&#10;&#10;&#10;In [31]: c= np.fromfile(&quot;b.dat&quot;,dtype=np.int,sep=&quot;,&quot;)&#10;&#10;&#10;In [32]: c&#10;Out[32]: &#10;array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,&#10; 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,&#10; 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,&#10; 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67,&#10; 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,&#10; 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99])&#10;&#10;&#10;In [33]: c= np.fromfile(&quot;b.dat&quot;,dtype=np.int,sep=&quot;,&quot;).reshape(5,10,2)&#10;&#10;&#10;In [34]: c&#10;Out[34]: &#10;array([[[ 0, 1],&#10; [ 2, 3],&#10; [ 4, 5],&#10; [ 6, 7],&#10; [ 8, 9],&#10; [10, 11],&#10; [12, 13],&#10; [14, 15],&#10; [16, 17],&#10; [18, 19]],&#10;&#10;&#10; [[20, 21],&#10; [22, 23],&#10; [24, 25],&#10; [26, 27],&#10; [28, 29],&#10; [30, 31],&#10; [32, 33],&#10; [34, 35],&#10; [36, 37],&#10; [38, 39]],&#10;&#10;&#10; [[40, 41],&#10; [42, 43],&#10; [44, 45],&#10; [46, 47],&#10; [48, 49],&#10; [50, 51],&#10; [52, 53],&#10; [54, 55],&#10; [56, 57],&#10; [58, 59]],&#10;&#10;&#10; [[60, 61],&#10; [62, 63],&#10; [64, 65],&#10; [66, 67],&#10; [68, 69],&#10; [70, 71],&#10; [72, 73],&#10; [74, 75],&#10; [76, 77],&#10; [78, 79]],&#10;&#10;&#10; [[80, 81],&#10; [82, 83],&#10; [84, 85],&#10; [86, 87],&#10; [88, 89],&#10; [90, 91],&#10; [92, 93],&#10; [94, 95],&#10; [96, 97],&#10; [98, 99]]])&#10;&#10;&#10;&#10;&#10;&#10;In [37]: a.tofile(&quot;b.dat&quot;,format=&quot;%d&quot;)&#10;&#10;In [38]: c =np.fromfile(&quot;b.dat&quot;,dtype = np.int).reshape(5,10,2)&#10;&#10;In [39]: c&#10;Out[39]: &#10;array([[[ 0,  1],&#10;        [ 2,  3],&#10;        [ 4,  5],&#10;        [ 6,  7],&#10;        [ 8,  9],&#10;        [10, 11],&#10;        [12, 13],&#10;        [14, 15],&#10;        [16, 17],&#10;        [18, 19]],&#10;&#10;       [[20, 21],&#10;        [22, 23],&#10;        [24, 25],&#10;        [26, 27],&#10;        [28, 29],&#10;        [30, 31],&#10;        [32, 33],&#10;        [34, 35],&#10;        [36, 37],&#10;        [38, 39]],&#10;&#10;       [[40, 41],&#10;        [42, 43],&#10;        [44, 45],&#10;        [46, 47],&#10;        [48, 49],&#10;        [50, 51],&#10;        [52, 53],&#10;        [54, 55],&#10;        [56, 57],&#10;        [58, 59]],&#10;&#10;       [[60, 61],&#10;        [62, 63],&#10;        [64, 65],&#10;        [66, 67],&#10;        [68, 69],&#10;        [70, 71],&#10;        [72, 73],&#10;        [74, 75],&#10;        [76, 77],&#10;        [78, 79]],&#10;&#10;       [[80, 81],&#10;        [82, 83],&#10;        [84, 85],&#10;        [86, 87],&#10;        [88, 89],&#10;        [90, 91],&#10;        [92, 93],&#10;        [94, 95],&#10;        [96, 97],&#10;        [98, 99]]])&#10;```"/>
              <outline text="注意事项" _note="&#10;该方法需要读取时知道存入文件时数组的维度和元素类型&#10;&#10;a.tofile()和np.fromfile()需要配合使用&#10;&#10;可以通过元数据文件来存储额外信息"/>
            </outline>
            <outline text="NumPy的便捷文件存取" collapsed="true">
              <outline text="np.save(fname, array)  或  np.savez(fname,array)" _note="&#10;fname：文件名，以.npy为扩展名，压缩扩展名为.npz&#10;&#10;array：数组变量"/>
              <outline text="np.load(fname)" _note="&#10;fname：文件名，以.npy为扩展名，压缩扩展名为.npz&#10;&#10;&#10;In [40]: a = np.arange(100).reshape(5,10,2)&#10;&#10;&#10;In [41]: np.save(&quot;a.npy&quot;,a)&#10;&#10;&#10;In [42]: b=np.load(&quot;a.npy&quot;)"/>
            </outline>
            <outline text="NumPy的随机数函数 #难点 " _note="&#10;NumPy的random子库&#10;&#10;np.random.*" collapsed="true">
              <outline text="np.random.rand(d0, d1, .. , dn)" _note="&#10;根据d0-dn创建随机数数组，浮点数，[0,1)，均匀分布&#10;&#10;```&#10;&#10;In [2]: a = np.random.rand(5)  #一维随机数&#10;&#10;&#10;In [3]: a&#10;Out[3]: array([0.73556183, 0.41384045, 0.58390666, 0.6067164 , 0.12760113])&#10;&#10;&#10;In [15]: a = np.random.rand(2,4)  # 两行四列随机数&#10;&#10;&#10;In [16]: a&#10;Out[16]: &#10;array([[0.95423339, 0.35700094, 0.88174802, 0.29117233],&#10; [0.87241826, 0.92325898, 0.42653596, 0.38871003]])&#10;&#10;&#10;&#10;&#10;In [11]: a = np.random.rand(2,4,3)   #多维随机数，二维四行三列&#10;&#10;&#10;In [12]: a&#10;Out[12]: &#10;array([[[0.40509833, 0.56012992, 0.26951981],&#10; [0.6611002 , 0.78071706, 0.3744698 ],&#10; [0.35113548, 0.97126009, 0.48233713],&#10; [0.3571612 , 0.69465467, 0.00323061]],&#10;&#10;&#10; [[0.94934023, 0.82912316, 0.5331818 ],&#10; [0.07524135, 0.4692268 , 0.71572548],&#10; [0.81783364, 0.03391836, 0.95522762],&#10; [0.73346621, 0.23913754, 0.30301077]]])&#10;```&#10;&#10;"/>
              <outline text="np.random.randn(d0, d1, .. , dn)" _note="&#10;根据d0-dn创建随机数数组，标准正态分布&#10;&#10;```&#10;&#10;In [17]: a = np.random.randn(6)  #一维随机数 &#10;&#10;&#10;In [18]: a&#10;Out[18]: &#10;array([-0.8724723 , 0.99699145, -0.54832432, -0.29925695, -0.73971977,&#10; 1.60003654])&#10;&#10;&#10;In [19]: a = np.random.randn(2,3) #二维随机数，两行三列&#10;&#10;&#10;In [20]: a&#10;Out[20]: &#10;array([[ 0.28939251, 1.26905066, 0.10616405],&#10; [ 1.51273003, -0.5008565 , -0.29497143]])&#10;&#10;&#10;In [21]: a = np.random.randn(2,3,2)  #多维随机数，二维三行二列 &#10;&#10;&#10;In [22]: a&#10;Out[22]: &#10;array([[[-0.4460864 , -2.23561098],&#10; [-0.45232211, 0.59131531],&#10; [ 0.11007086, -0.09303964]],&#10;&#10;&#10; [[ 0.62137231, -0.12599499],&#10; [-1.89951454, -0.84359488],&#10; [-0.24472114, -0.62491263]]])&#10;&#10;```"/>
              <outline text="np.random.randint(low[,high,shape])" _note="&#10;根据shape创建随机整数或整数数组，范围是[low, high)&#10;&#10;```&#10;&#10;In [23]: a= np.random.randint(5)  # 小于5的随机整数&#10;&#10;&#10;In [24]: a&#10;Out[24]: 3&#10;&#10;&#10;In [25]: a=np.random.randint(5,8,2) #5和8之间2个随机整数&#10;&#10;&#10;In [26]: a&#10;Out[26]: array([7, 5])&#10;&#10;&#10;In [27]: a=np.random.randint(5,15,(2,3)) #5和15之间的随机整数，形成2行3列&#10;&#10;&#10;In [28]: a&#10;Out[28]: &#10;array([[ 9, 13, 14],&#10; [12, 10, 10]])&#10;&#10;&#10;In [29]: a=np.random.randint(5,15,(2,3,4))  # 5和15之间的随机整数，形成2维3行4列&#10;&#10;&#10;In [30]: a&#10;Out[30]: &#10;array([[[11, 9, 9, 12],&#10; [ 8, 10, 9, 9],&#10; [13, 13, 8, 13]],&#10;&#10;&#10; [[14, 6, 12, 8],&#10; [ 6, 10, 12, 11],&#10; [ 8, 13, 10, 9]]])&#10;&#10;&#10;In [31]: a=np.random.randint(5,15)  #5和15之间的随机整数&#10;&#10;&#10;In [32]: a&#10;Out[32]: 8&#10;&#10;```"/>
              <outline text="np.random.seed(s)" _note="&#10;是什么：随机数种子，s是给定的种子值&#10;&#10;使用场景：测试用&#10;&#10;使用方法：先给出seed，再用函数写出随机数；当再次给出相同种子，使用相同函数则给出相同随机数&#10;&#10;```&#10;&#10;In [35]: np.random.seed(2)&#10;&#10;&#10;In [36]: a=np.random.randint(5,15,(2,3,4))  &#10;&#10;&#10;In [37]: a&#10;Out[37]: &#10;array([[[13, 13, 11, 7],&#10; [13, 12, 7, 6],&#10; [10, 9, 9, 10]],&#10;&#10;&#10; [[12, 8, 11, 9],&#10; [ 8, 12, 11, 6],&#10; [ 8, 10, 13, 9]]])&#10;&#10;&#10;In [38]: a=np.random.randint(5,15,(2,3,4))&#10;&#10;&#10;In [39]: a&#10;Out[39]: &#10;array([[[11, 8, 14, 7],&#10; [ 5, 9, 7, 9],&#10; [ 6, 12, 13, 7]],&#10;&#10;&#10; [[14, 13, 12, 6],&#10; [11, 13, 10, 14],&#10; [14, 14, 8, 5]]])&#10;&#10;&#10;In [40]: np.random.seed(2)   #给出种子值，随机数值和上次一样。&#10;&#10;&#10;In [41]: a=np.random.randint(5,15,(2,3,4))&#10;&#10;&#10;In [42]: a&#10;Out[42]: &#10;array([[[13, 13, 11, 7],&#10; [13, 12, 7, 6],&#10; [10, 9, 9, 10]],&#10;&#10;&#10; [[12, 8, 11, 9],&#10; [ 8, 12, 11, 6],&#10; [ 8, 10, 13, 9]]])&#10;```"/>
              <outline text="np.random.shuffle(a)" _note="&#10;是什么：根据数组a的第1轴进行随机排列，改变数组a&#10;&#10;使用场景：需要根据第一轴随机排列，并要改变数组a&#10;&#10;```&#10;&#10;&#10;In [106]: a = np.random.randint(3,39,(3,4))&#10;&#10;&#10;In [107]: a&#10;Out[107]: &#10;array([[12, 35, 6, 15],&#10; [35, 32, 31, 5],&#10; [36, 3, 5, 11]])&#10;&#10;&#10;In [108]: np.random.shuffle(a)   &#10;#只改变不同的轴，不改变数组内部，数组a发生变化&#10;&#10;&#10;In [112]: a&#10;Out[112]: &#10;array([[36, 3, 5, 11],&#10; [35, 32, 31, 5],&#10; [12, 35, 6, 15]])&#10;&#10;```"/>
              <outline text="np.random.permutation(a)" _note="&#10;根据数组a的第1轴产生一个新的乱序数组，不改变数组a&#10;&#10;```&#10;&#10;In [112]: a&#10;Out[112]: &#10;array([[36, 3, 5, 11],&#10; [35, 32, 31, 5],&#10; [12, 35, 6, 15]])&#10;&#10;&#10;In [113]: np.random.permutation(a)  #数组a不发生变化&#10;Out[113]: &#10;array([[35, 32, 31, 5],&#10; [12, 35, 6, 15],&#10; [36, 3, 5, 11]])&#10;&#10;&#10;In [114]: a&#10;Out[114]: &#10;array([[36, 3, 5, 11],&#10; [35, 32, 31, 5],&#10; [12, 35, 6, 15]])&#10;```"/>
              <outline text="np.random.choice(a[, size, replace, p ])" _note="&#10;从一维数组a中以概率p抽取元素，形成size形状行不数组&#10;&#10;replace表示是否可以重用元素，默认为False&#10;&#10;```&#10;&#10;In [91]: b=np.random.randint(100,200,(8,))&#10;&#10;&#10;In [92]: b&#10;Out[92]: array([150, 145, 140, 189, 173, 137, 100, 118])&#10;&#10;&#10;In [93]: np.random.choice(b,(3,2))&#10;Out[93]: &#10;array([[118, 189],&#10; [137, 150],&#10; [173, 140]])&#10;&#10;&#10;&#10;In [95]: np.random.choice(b,(3,2),replace=False)&#10;Out[95]: &#10;array([[118, 173],&#10; [140, 145],&#10; [137, 189]])&#10;&#10;&#10;In [96]: np.random.choice(b,(3,2),p=b/np.sum(b))&#10;Out[96]: &#10;array([[145, 150],&#10; [173, 145],&#10; [173, 189]])&#10;&#10;```"/>
              <outline text="np.random.uniform(low, high, size)" _note="&#10;产生具有均匀分布的数组，low起始值，high结束值，size形状&#10;&#10;```&#10;&#10;In [103]: np.random.uniform(3,13,(2,5))&#10;Out[103]: &#10;array([[8.8602198 , 3.37094413, 6.50656391, 8.63190684, 5.99729872],&#10; [8.12334153, 9.73466925, 4.59193733, 3.5047767 , 6.37815887]])&#10;&#10;```&#10;&#10;"/>
              <outline text="np.random.normal(loc, scale, size)" _note="&#10;产生具有正态分布的数组，loc均值，scale标准差，size形状&#10;&#10;```&#10;&#10;In [105]: np.random.normal(3,15,(4,3))&#10;Out[105]: &#10;array([[ 16.87121452, 6.52867147, -4.32912383],&#10; [ 1.60527688, 11.03102073, 11.26267052],&#10; [ 0.1271692 , 14.92046442, 14.77644749],&#10; [ -4.31586625, -12.08797297, 7.91363048]])&#10;&#10;```&#10;&#10;"/>
              <outline text="np.random.poisson(lam,size)" _note="&#10;产生具有泊松分布的数组，lam随机事件发生率，size形状&#10;&#10;```&#10;&#10;In [116]: np.random.poisson(4,(3,4))&#10;Out[116]: &#10;array([[2, 3, 0, 1],&#10; [8, 3, 1, 3],&#10; [3, 4, 6, 5]])&#10;&#10;```"/>
            </outline>
            <outline text="NumPy的统计函数 #重点" _note="&#10;NumPy直接提供的统计类函数&#10;&#10;np.*&#10;&#10;axis=None是统计函数的标配参数" collapsed="true">
              <outline text="np.sum(a, axis=None)" _note="&#10;根据给定轴axis计算数组a相关元素之和，axis整数或元组&#10;&#10;```&#10;&#10;In [117]: a&#10;Out[117]: &#10;array([[36, 3, 5, 11],&#10; [35, 32, 31, 5],&#10; [12, 35, 6, 15]])&#10;&#10;&#10;In [118]: np.sum(a)&#10;Out[118]: 226&#10;&#10;&#10;In [119]: np.sum(a, axis=1)    # axis=1，计算每行的值，相当于对行进行折叠&#10;Out[119]: array([ 55, 103, 68])&#10;&#10;&#10;In [120]: np.sum(a, axis=0)  # axis=0，计算每列的值，对列进行折叠。&#10;Out[120]: array([83, 70, 42, 31])&#10;&#10;&#10;In [122]: a=np.random.randint(3,27,(2,3,4))&#10;&#10;&#10;In [123]: a&#10;Out[123]: &#10;array([[[22, 7, 26, 7],&#10; [12, 18, 16, 24],&#10; [14, 19, 18, 20]],&#10;&#10;&#10; [[12, 6, 14, 13],&#10; [23, 13, 7, 8],&#10; [ 7, 25, 22, 24]]])&#10;&#10;&#10;In [124]: np.sum(a,axis=2)   # axis=2，计算每个维度每行的值，折叠每行&#10;Out[124]: &#10;array([[62, 70, 71],&#10; [45, 51, 78]])&#10;&#10;&#10;In [125]: np.sum(a,axis=0)  # axis=0，计算两个维度相加的值。&#10;Out[125]: &#10;array([[34, 13, 40, 20],&#10; [35, 31, 23, 32],&#10; [21, 44, 40, 44]])&#10;&#10;&#10;In [126]: np.sum(a,axis=1)  # axis=1，计算每个维度每一列相加的值，折叠每列&#10;Out[126]: &#10;array([[48, 44, 60, 51],&#10; [42, 44, 43, 45]])&#10;&#10;&#10;&#10;In [130]: a   #3维4行2列&#10;Out[130]: &#10;array([[[17, 10],&#10;        [ 4, 16],&#10;        [17, 12],&#10;        [ 6, 10]],&#10;&#10;       [[16, 21],&#10;        [23, 25],&#10;        [25,  8],&#10;        [ 6,  4]],&#10;&#10;       [[23, 13],&#10;        [ 6, 25],&#10;        [22,  5],&#10;        [22,  8]]])&#10;&#10;In [131]: np.sum(a,axis=0)  #计算每个维度相加的值&#10;Out[131]: &#10;array([[56, 44],&#10;       [33, 66],&#10;       [64, 25],&#10;       [34, 22]])&#10;&#10;In [132]: np.sum(a,axis=1)  #计算维度内的列值&#10;Out[132]: &#10;array([[44, 48],&#10;       [70, 58],&#10;       [73, 51]])&#10;&#10;In [133]: np.sum(a,axis=2)  #计算维度内的行值&#10;Out[133]: &#10;array([[27, 20, 29, 16],&#10;       [37, 48, 33, 10],&#10;       [36, 31, 27, 30]])&#10;&#10;```"/>
              <outline text="np.mean(a, axis=None)" _note="&#10;根据给定轴axis计算数组a相关元素的期望（平均值），axis整数或元组&#10;&#10;```&#10;&#10;In [135]: a&#10;Out[135]: &#10;array([[[17, 10],&#10; [ 4, 16],&#10; [17, 12],&#10; [ 6, 10]],&#10;&#10;&#10; [[16, 21],&#10; [23, 25],&#10; [25, 8],&#10; [ 6, 4]],&#10;&#10;&#10; [[23, 13],&#10; [ 6, 25],&#10; [22, 5],&#10; [22, 8]]])&#10;&#10;&#10;In [136]: np.mean(a)              #所有数的平均值&#10;Out[136]: 14.333333333333334&#10;&#10;&#10;In [137]: np.mean(a,axis=0)  #两个维度的平均值  18.66666667=(17+16+23)/3&#10;Out[137]: &#10;array([[18.66666667, 14.66666667],&#10; [11. , 22. ],&#10; [21.33333333, 8.33333333],&#10; [11.33333333, 7.33333333]])&#10;&#10;&#10;In [138]: np.mean(a,axis=1)  #维度内每列的平均值 11=(17+4+17+6)/4&#10;Out[138]: &#10;array([[11. , 12. ],&#10; [17.5 , 14.5 ],&#10; [18.25, 12.75]])&#10;&#10;&#10;In [139]: np.mean(a,axis=2)   #维度内每行的平均值  13.5= (17+10)/2&#10;Out[139]: &#10;array([[13.5, 10. , 14.5, 8. ],&#10; [18.5, 24. , 16.5, 5. ],&#10; [18. , 15.5, 13.5, 15. ]])&#10;&#10;```&#10;"/>
              <outline text="np.average(a, axis=None, weight=None)" _note="&#10;根据给定轴axis计算数组a相关元素的加权平均值&#10;&#10;```&#10;&#10;In [140]: a&#10;Out[140]: &#10;array([[[17, 10],&#10; [ 4, 16],&#10; [17, 12],&#10; [ 6, 10]],&#10;&#10;&#10; [[16, 21],&#10; [23, 25],&#10; [25, 8],&#10; [ 6, 4]],&#10;&#10;&#10; [[23, 13],&#10; [ 6, 25],&#10; [22, 5],&#10; [22, 8]]])&#10;&#10;&#10;In [141]: np.average(a)&#10;Out[141]: 14.333333333333334&#10;&#10;&#10;In [142]: np.mean(a)&#10;Out[142]: 14.333333333333334&#10;&#10;&#10;In [143]: np.average(a,axis=0)&#10;Out[143]: &#10;array([[18.66666667, 14.66666667],&#10; [11. , 22. ],&#10; [21.33333333, 8.33333333],&#10; [11.33333333, 7.33333333]])&#10;&#10;&#10;In [144]: np.mean(a,axis=0)&#10;Out[144]: &#10;array([[18.66666667, 14.66666667],&#10; [11. , 22. ],&#10; [21.33333333, 8.33333333],&#10; [11.33333333, 7.33333333]])&#10;&#10;&#10;In [156]: a=np.arange(15).reshape(3,5)&#10;&#10;&#10;In [157]: a&#10;Out[157]: &#10;array([[ 0, 1, 2, 3, 4],&#10; [ 5, 6, 7, 8, 9],&#10; [10, 11, 12, 13, 14]])&#10;&#10;&#10;In [158]: np.average(a, axis=0, weights=[10, 5, 1])    &#10;Out[158]: array([2.1875, 3.1875, 4.1875, 5.1875, 6.1875])&#10;&#10;# weights是加权 2.1875=(0*10 +5*5 + 10*1)/(10+5+1)&#10;&#10;```"/>
              <outline text="np.std(a, axis=None)" _note="&#10;根据给定轴axis计算数组a相关元素的标准差&#10;&#10;```&#10;&#10;In [146]: a&#10;Out[146]: &#10;array([[[17, 10],&#10;        [ 4, 16],&#10;        [17, 12],&#10;        [ 6, 10]],&#10;&#10;       [[16, 21],&#10;        [23, 25],&#10;        [25,  8],&#10;        [ 6,  4]],&#10;&#10;       [[23, 13],&#10;        [ 6, 25],&#10;        [22,  5],&#10;        [22,  8]]])&#10;&#10;In [147]: np.std(a)                                     #求所有值的标准差&#10;Out[147]: 7.3805299418281765&#10;&#10;In [148]: np.std(a, axis=0)&#10;Out[148]:                                                        #求两个维度的标准差&#10;array([[3.09120617, 4.64279609],&#10;       [8.52447457, 4.24264069],&#10;       [3.29983165, 2.86744176],&#10;       [7.54247233, 2.49443826]])&#10;&#10;In [149]: np.std(a, axis=1)                           #求维度内列的标准差&#10;Out[149]: &#10;array([[6.04152299, 2.44948974],&#10;       [7.43303437, 8.7321246 ],&#10;       [7.08431366, 7.62807315]])&#10;&#10;In [150]: np.std(a,axis=2)                            #求维度内行的标准差&#10;Out[150]: &#10;array([[3.5, 6. , 2.5, 2. ],&#10;       [2.5, 1. , 8.5, 1. ],&#10;       [5. , 9.5, 8.5, 7. ]])&#10;```"/>
              <outline text="np.var(a, axis=None)" _note="&#10;根据给定轴axis计算数组a相关元素的方差&#10;&#10;```&#10;&#10;In [151]: a&#10;Out[151]: &#10;array([[[17, 10],&#10; [ 4, 16],&#10; [17, 12],&#10; [ 6, 10]],&#10;&#10;&#10; [[16, 21],&#10; [23, 25],&#10; [25, 8],&#10; [ 6, 4]],&#10;&#10;&#10; [[23, 13],&#10; [ 6, 25],&#10; [22, 5],&#10; [22, 8]]])&#10;&#10;&#10;In [152]: np.var(a)&#10;Out[152]: 54.47222222222223&#10;&#10;&#10;In [153]: np.var(a, axis=0)&#10;Out[153]: &#10;array([[ 9.55555556, 21.55555556],&#10; [72.66666667, 18. ],&#10; [10.88888889, 8.22222222],&#10; [56.88888889, 6.22222222]])&#10;&#10;&#10;In [154]: np.var(a, axis=1)&#10;Out[154]: &#10;array([[36.5 , 6. ],&#10; [55.25 , 76.25 ],&#10; [50.1875, 58.1875]])&#10;&#10;&#10;In [155]: np.var(a,axis=2)&#10;Out[155]: &#10;array([[12.25, 36. , 6.25, 4. ],&#10; [ 6.25, 1. , 72.25, 1. ],&#10; [25. , 90.25, 72.25, 49. ]])&#10;&#10;```"/>
              <outline text="np.min(a)   np.max(a)" _note="&#10;计算数组a中元素的最小值，最大值&#10;&#10;```&#10;In [159]: a&#10;Out[159]: &#10;array([[ 0, 1, 2, 3, 4],&#10; [ 5, 6, 7, 8, 9],&#10; [10, 11, 12, 13, 14]])&#10;&#10;&#10;In [160]: np.max(a)&#10;Out[160]: 14&#10;&#10;&#10;In [161]: np.min(a)&#10;Out[161]: 0&#10;&#10;```"/>
              <outline text="np.argmin(a)   np.argmax(a)" _note="&#10;计算数组a中元素最小值、最大值的降一维后下标&#10;&#10;```&#10;&#10;In [166]: a = np.random.randint(3,15,(3,4))&#10;&#10;&#10;In [167]: a&#10;Out[167]: &#10;array([[11, 6, 12, 6],&#10; [13, 7, 4, 3],&#10; [11, 5, 11, 7]])&#10;&#10;&#10;In [168]: np.argmin(a)         #7是下标，数组a降一维后，最小值3的下标是7&#10;Out[168]: 7&#10;&#10;&#10;In [169]: np.argmax(a)        #4是下标，数组a降一维后，最大值13的下标是4&#10;Out[169]: 4&#10;&#10;```"/>
              <outline text="np.unravel_index(index, shape)" _note="&#10;根据shape将一维下标index转换成多维下标&#10;&#10;```&#10;&#10;In [183]: b= np.arange(15,0,-1).reshape(3,5)&#10;&#10;&#10;In [184]: b&#10;Out[184]: &#10;array([[15, 14, 13, 12, 11],&#10; [10, 9, 8, 7, 6],&#10; [ 5, 4, 3, 2, 1]])&#10;&#10;&#10;In [185]: np.argmax(b)&#10;Out[185]: 0&#10;&#10;&#10;In [186]: np.unravel_index(np.argmax(b),b.shape)&#10;Out[186]: (0, 0)&#10;&#10;&#10;In [187]: np.unravel_index(np.argmin(b),b.shape)     #(2,4)是数组b中元素1的多维下标值&#10;Out[187]: (2, 4)&#10;&#10;&#10;In [188]: np.argmin(b)&#10;Out[188]: 14&#10;&#10;```"/>
              <outline text="np.ptp(a)" _note="&#10;计算数组a中元素最大值与最小值的差&#10;```&#10;&#10;In [177]: a&#10;Out[177]: &#10;array([[11,  6, 12,  6],&#10;       [13,  7,  4,  3],&#10;       [11,  5, 11,  7]])&#10;&#10;In [178]: np.ptp(a)&#10;Out[178]: 10&#10;&#10;```&#10;"/>
              <outline text="np.median(a)" _note="&#10;计算数组a中元素的中位数（中值）&#10;&#10;```&#10;&#10;In [180]: np.median(a)&#10;Out[180]: 7.0&#10;&#10;&#10;In [181]: a&#10;Out[181]: &#10;array([[11, 6, 12, 6],&#10; [13, 7, 4, 3],&#10; [11, 5, 11, 7]])&#10;&#10;&#10;In [182]: np.median(a)&#10;Out[182]: 7.0&#10;```"/>
            </outline>
            <outline text="NumPy的梯度函数 #重点" collapsed="true">
              <outline text="np.gradient(f)" _note="&#10;计算数值f中元素的梯度，当f作为多维时，返回每个维度梯度&#10;&#10;梯度：连续值之间的变化率，即斜率&#10;&#10;XY坐标轴连续三个X坐标对应的Y轴值：a，b，c，其中，b的梯度是：(c-a)/2&#10;&#10;```&#10;&#10;In [3]: a&#10;Out[3]: array([10, 17, 15,  9, 16])&#10;&#10;In [4]: np.gradient(a)            # 第一个7 =(17-10)/1，2.5=(15-10)/2，最后一个7=(16-9)/1&#10;Out[4]: array([ 7. ,  2.5, -4. ,  0.5,  7. ])&#10;&#10;&#10;c = np.random.randint(0,50,(3,5))&#10;&#10;c&#10;Out[6]: &#10;array([[36, 20, 43, 47,  7],&#10;       [26, 40, 42, 22,  7],&#10;       [12, 29, 15, 10, 41]])&#10;&#10;np.gradient(c)&#10;Out[7]: &#10;[array([[-10. ,  20. ,  -1. , -25. ,   0. ],                # 最外侧维度的梯度，也就是沿着列的梯度&#10;        [-12. ,   4.5, -14. , -18.5,  17. ],&#10;        [-14. , -11. , -27. , -12. ,  34. ]]),&#10; array([[-16. ,   3.5,  13.5, -18. , -40. ],              # 第二层维度的梯度，也就是沿着行的梯度&#10;        [ 14. ,   8. ,  -9. , -17.5, -15. ],&#10;        [ 17. ,   1.5,  -9.5,  13. ,  31. ]])]&#10;&#10;&#10;&#10;&#10;In [8]: c = np.random.randint(0,50,(3,5,3))&#10;&#10;&#10;In [9]: c                                                                        #3维5行3列&#10;Out[9]: &#10;array([[[14, 43, 49],&#10; [39, 33, 49],&#10; [47, 0, 42],&#10; [41, 3, 6],&#10; [48, 0, 27]],&#10;&#10;&#10; [[37, 35, 6],&#10; [ 7, 38, 48],&#10; [36, 27, 19],&#10; [28, 4, 49],&#10; [ 4, 24, 22]],&#10;&#10;&#10; [[39, 17, 30],&#10; [36, 3, 15],&#10; [20, 6, 49],&#10; [47, 48, 23],&#10; [ 6, 27, 24]]])&#10;&#10;&#10;In [10]: np.gradient(c)                                        &#10;Out[10]: &#10;[array([[[ 23. , -8. , -43. ],                                          #维度之间的梯度&#10; [-32. , 5. , -1. ],&#10; [-11. , 27. , -23. ],&#10; [-13. , 1. , 43. ],&#10; [-44. , 24. , -5. ]],&#10; &#10; [[ 12.5, -13. , -9.5],&#10; [ -1.5, -15. , -17. ],&#10; [-13.5, 3. , 3.5],&#10; [ 3. , 22.5, 8.5],&#10; [-21. , 13.5, -1.5]],&#10; &#10; [[ 2. , -18. , 24. ],&#10; [ 29. , -35. , -33. ],&#10; [-16. , -21. , 30. ],&#10; [ 19. , 44. , -26. ],&#10; [ 2. , 3. , 2. ]]]),&#10; array([[[ 25. , -10. , 0. ],                                           #维度内每列的梯度&#10; [ 16.5, -21.5, -3.5],&#10; [ 1. , -15. , -21.5],&#10; [ 0.5, 0. , -7.5],&#10; [ 7. , -3. , 21. ]],&#10; &#10; [[-30. , 3. , 42. ],&#10; [ -0.5, -4. , 6.5],&#10; [ 10.5, -17. , 0.5],&#10; [-16. , -1.5, 1.5],&#10; [-24. , 20. , -27. ]],&#10; &#10; [[ -3. , -14. , -15. ],&#10; [ -9.5, -5.5, 9.5],&#10; [ 5.5, 22.5, 4. ],&#10; [ -7. , 10.5, -12.5],&#10; [-41. , -21. , 1. ]]]),&#10; array([[[ 29. , 17.5, 6. ],                                          #维度内每行的梯度&#10; [ -6. , 5. , 16. ],&#10; [-47. , -2.5, 42. ],&#10; [-38. , -17.5, 3. ],&#10; [-48. , -10.5, 27. ]],&#10; &#10; [[ -2. , -15.5, -29. ],&#10; [ 31. , 20.5, 10. ],&#10; [ -9. , -8.5, -8. ],&#10; [-24. , 10.5, 45. ],&#10; [ 20. , 9. , -2. ]],&#10; &#10; [[-22. , -4.5, 13. ],&#10; [-33. , -10.5, 12. ],&#10; [-14. , 14.5, 43. ],&#10; [ 1. , -12. , -25. ],&#10; [ 21. , 9. , -3. ]]])]&#10;```"/>
            </outline>
          </outline>
          <outline text="单元3：图像的手绘效果 #实例 " collapsed="true">
            <outline text="图像的数组表示" collapsed="true">
              <outline text="图像的RGB色彩模式" _note="&#10;图像一般使用RGB色彩模式，即每个像素点的颜色由红（R）、绿(G)、蓝(B)组成，取值范围0~255。"/>
              <outline text="PIL库" _note="&#10;PIL， Python Image Library&#10;&#10;PIL库是一个具有强大图像处理能力的第三方库&#10;&#10;在命令行下的安装方法：pip install pillow&#10;&#10;from PIL import Image&#10;&#10;Image是PIL库中代表一个图像的类（对象）"/>
              <outline text="图像的数组表示" _note="&#10;图像是一个由像素组成的二维矩阵，每个元素是一个RGB值"/>
              <outline text="实例" _note="&#10;&#10;In [1]: from PIL import Image&#10;&#10;&#10;In [2]: import numpy as np&#10;&#10;&#10;In [3]: im = np.array(Image.open(&quot;D:/ex/beijing.jpg&quot;))&#10;&#10;&#10;In [4]: print(im.shape, im.dtype)&#10;(333, 500, 3) uint8&#10;&#10;图像是一个三维数组，维度分别是高度、宽度和像素RGB值。"/>
            </outline>
            <outline text="图像的变换">
              <outline text="图像的变换" _note="&#10;读入图像后，获得像素RGB值，修改后保存为新的文件&#10;&#10;"/>
              <outline text="曝光效果" _note="&#10;In [11]: from PIL import Image&#10;&#10;&#10;In [12]: import numpy as np&#10;&#10;&#10;In [13]: a = np.array(Image.open(&quot;D:/ex/beijing.jpg&quot;)) #打开文件，获得像素RGB值&#10;&#10;&#10;In [14]: print(a.shape, a.dtype) &#10;(333, 500, 3) uint8&#10;&#10;&#10;In [15]: b = [255, 255, 255] -a #修改图片 &#10;&#10;&#10;In [17]: im = Image.fromarray(b.astype(&apos;uint8&apos;)) #保存图片&#10;&#10;&#10;In [18]: im.save(&quot;D:/ex/fcity2.jpg&quot;)"/>
              <outline text="胶圈曝光效果" _note="&#10;In [1]: from PIL import Image&#10;&#10;&#10;In [2]: import numpy as np&#10;&#10;&#10;In [3]: a = np.array(Image.open(&quot;D:/ex/beijing.jpg&quot;).convert(&apos;L&apos;))&#10;&#10;# 模式“L”为灰色图像，它的每个像素用8个bit表示，0表示黑，255表示白，其他数字表示不同的灰度。&#10;&#10;&#10;In [4]: b = 255 - a&#10;&#10;&#10;In [5]: im = Image.fromarray(b.astype(&apos;uint8&apos;))&#10;&#10;&#10;In [7]: im.save(&quot;D:/ex/fcity3.jpg&quot;)&#10;&#10;&#10;更多关于convert()的介绍，详见[Python图像处理库PIL中图像格式转换（一）_icamera0的博客-CSDN博客](https://blog.csdn.net/icamera0/article/details/50843172)"/>
              <outline text="黑白蒙尘效果" _note="&#10;&#10;In [1]: from PIL import Image&#10;&#10;In [2]: import numpy as np&#10;&#10;In [3]: a = np.array(Image.open(&quot;D:/ex/beijing.jpg&quot;).convert(&apos;L&apos;))&#10;&#10;In [5]: c = (100/255)*a + 150  #区间变换&#10;&#10;In [6]: im = Image.fromarray(c.astype(&apos;uint8&apos;))&#10;&#10;In [7]: im.save(&quot;D:/ex/fcity4.jpg&quot;)"/>
              <outline text="黑白效果" _note="&#10;In [1]: from PIL import Image&#10;&#10;In [2]: import numpy as np&#10;&#10;In [3]: a = np.array(Image.open(&quot;D:/ex/beijing.jpg&quot;).convert(&apos;L&apos;))&#10;&#10;In [11]: d = 255 * (a/255)**2     #像素平方&#10;&#10;&#10;In [12]: im = Image.fromarray(d.astype(&apos;uint8&apos;))&#10;&#10;&#10;In [13]: im.save(&quot;D:/ex/fcity5.jpg&quot;)"/>
            </outline>
            <outline text="“图像的手绘效果”实例分析">
              <outline text="手绘效果的几个特征" _note="&#10;黑白灰色&#10;&#10;边界线条较重&#10;&#10;相同或相近色彩趋于白色&#10;&#10;略有光源效果"/>
              <outline text="代码" _note="&#10;#PictureDraw.py&#10;from PIL import Image&#10;import numpy as np&#10;&#10;a = np.asarray(Image.open(&apos;D:/ex/beijing.jpg&apos;).convert(&apos;L&apos;)).astype(&apos;float&apos;)&#10;&#10;depth = 10                                    #(0-100)&#10;grad = np.gradient(a)                         #取图像灰度的梯度值&#10;grad_x, grad_y = grad                         #分别取横纵图像梯度值&#10;grad_x = grad_x*depth/100&#10;grad_y = grad_y*depth/100&#10;A = np.sqrt(grad_x**2 + grad_y**2 +1)&#10;uni_x = grad_x/A&#10;uni_y = grad_y/A&#10;uni_z =1 /A&#10;&#10;vec_el = np.pi/2.2                            #光源的俯视角度，弧度值&#10;vec_az = np.pi/4                              #光源的方位角度，弧度值&#10;dx = np.cos(vec_el)*np.cos(vec_az)            #光源对x轴的影响&#10;dy = np.cos(vec_el)*np.sin(vec_az)            #光源对y轴的影响&#10;dz = np.sin(vec_el)                           #光源对z轴的影响&#10;&#10;b = 255*(dx*uni_x + dy*uni_y + dz*uni_z)      #光源归一化&#10;b = b.clip(0,255)&#10;&#10;im = Image.fromarray(b.astype(&apos;uint8&apos;))       #重构图像&#10;im.save(&apos;D:/ex/beijingHD.jpg&apos;)&#10;&#10;&#10;# np.pi就是3.141592653589793，通常数组乘 pi/180，可以转化为弧度 &#10;"/>
              <outline text="代码详解">
                <outline text="梯度的重构" _note="&#10;根据像素之间的梯度值和虚拟深度值对图像进行重构&#10;&#10;根据灰度变化来模拟人类视觉的远近程度&#10;&#10;depth = 10                                   #预设深度值为10，取值范围是(0-100)&#10;grad = np.gradient(a)              &#10;grad_x, grad_y = grad              #提取x和y方向的梯度值&#10;grad_x = grad_x*depth/100&#10;grad_y = grad_y*depth/100   #根据深度调整x和y方向的梯度值"/>
                <outline text="光源效果" _note="&#10;根据灰度变化来模拟人类视觉的远近程度&#10;&#10;&#10;设计一个位于图像斜上方的虚拟光源&#10;&#10;光源相对于图像的俯视角为Elevation，方向角为Azimuth&#10;&#10;建立光源对个地面梯度值的影响函数&#10;&#10;运算出各点的新像素值&#10;&#10;&#10;vec_el = np.pi/2.2&#10;vec_az = np.pi/4 &#10;dx = np.cos(vec_el)*np.cos(vec_az)&#10;dy = np.cos(vec_el)*np.sin(vec_az) &#10;dz = np.sin(vec_el)&#10;&#10;np.cos(vec_el)为单位光线在地平面上的投影长度&#10;&#10;dx, dy, dz是光源对x/y/z三方向的影响程度&#10;"/>
                <outline text="梯度归一化" _note="&#10;#构造x和y轴梯度的三维归一化单位坐标系&#10;A = np.sqrt(grad_x**2 + grad_y**2 +1)&#10;uni_x = grad_x/A&#10;uni_y = grad_y/A&#10;&#10;#梯度和光源相互作用，将梯度转化为灰度&#10;b = 255*(dx*uni_x + dy*uni_y + dz*uni_z) "/>
                <outline text="图像生成" _note="&#10;#为避免数据越界，将生成的灰度值裁剪值0-255区间&#10;b = b.clip(0,255)&#10;&#10;#生成图像&#10;im = Image.fromarray(b.astype(&apos;uint8&apos;)) &#10;im.save(&apos;D:/ex/beijingHD.jpg&apos;)"/>
              </outline>
            </outline>
          </outline>
        </outline>
        <outline text="第2周：数据分析之展示">
          <outline text="单元4：Matplotlib库入门" collapsed="true">
            <outline text="Matplotlib的介绍" collapsed="true">
              <outline text="Python优秀的数据可视化第三方库"/>
              <outline text="网址" _note="&#10;matplotlib.org/gallery.html"/>
              <outline text="Matplotlib库的使用" _note="&#10;Matplotlib库由各种可视化类构成，内部结构复杂，受Matlib启发&#10;&#10;matplotlib.pyplot是绘制各类可视化图形的命令子库，相当于快捷方式&#10;&#10;import matplotlib.pyplot as plt"/>
              <outline text="Matplotlib库小测" collapsed="true">
                <outline text="小测1   只有一个参数" collapsed="true">
                  <outline text="代码" _note="&#10;&#10;import matplotlib.pyplot as plt&#10;&#10;plt.plot([3,1,4,5,2])&#10;plt.ylabel(&quot;Grade&quot;)&#10;plt.show()&#10;&#10;&#10;plt.plot()只有一个输入列表或数组时，参数被当做Y轴，X轴以索引自动生成"/>
                  <outline text="![小测1   只有一个参数](https://user-images.githubusercontent.com/19257507/96817516-13621180-1452-11eb-93f1-e125c24bbaa2.png)"/>
                </outline>
                <outline text="小测2  保存为图片" _note="&#10;import matplotlib.pyplot as plt&#10;&#10;plt.plot([3,1,4,5,2])&#10;plt.ylabel(&quot;Grade&quot;)&#10;plt.savefig(&apos;test&apos;,dpi=600) #PNG文件&#10;plt.show()&#10;&#10;&#10;plt.savefig()将输出图形存储为文件，默认PNG格式，可以通过dpi修改输出质量"/>
                <outline text="小测3  有两个参数" collapsed="true">
                  <outline text="代码" _note="&#10;import matplotlib.pyplot as plt&#10;&#10;plt.plot([0,2,4,5,8],[3,1,4,5,2])&#10;plt.ylabel(&quot;Grade&quot;)&#10;plt.axis([-1,10,0,6])&#10;plt.show()&#10;&#10;&#10;plt.plot(x,y)当有两个以上参数时，按照X轴和Y轴顺序绘制数据点。&#10;"/>
                  <outline text="![小测3  有两个参数](https://user-images.githubusercontent.com/19257507/96817441-eb72ae00-1451-11eb-87e4-64a39ae8b5cb.png)"/>
                </outline>
              </outline>
              <outline text="pyplot的绘图区域" collapsed="true">
                <outline text="plt.subplot(nrows, ncols, plot_number)" _note="&#10;可以有两种形式：&#10;&#10;plt.subplot( 3, 2, 4)&#10;&#10;plt.subplot(324)&#10;&#10;&#10;在全局绘图区域中创建一个分区体系，并定位到一个子绘图区域&#10;&#10;全局区域分成3行2列，定位到子区域4。&#10;"/>
                <outline text="实例1">
                  <outline text="代码" _note="&#10;&#10;可以有两种形式：&#10;&#10;plt.subplot( 3, 2, 4)&#10;&#10;plt.subplot(324)"/>
                  <outline text="![实例1pyplot的绘图区域](https://upload-images.jianshu.io/upload_images/64046-225eb12b351a0f9a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)"/>
                </outline>
                <outline text="实例2">
                  <outline text="代码" _note="&#10;import numpy as np&#10;&#10;import matplotlib.pyplot as plt&#10;&#10;def f(t):&#10;    return np.exp(-t) * np.cos(2*np.pi*t)&#10;&#10;a = np.arange(0.0, 5.0, 0.02)&#10;&#10;plt.subplot(211)&#10;plt.plot(a,f(a))&#10;&#10;plt.subplot(2,1,2)&#10;plt.plot(a,np.cos(2*np.pi*f(a)),&apos;r--&apos;)&#10;plt.show()"/>
                  <outline text="![实例2 pyplot的绘图区域](https://user-images.githubusercontent.com/19257507/96819834-2b885f80-1457-11eb-987f-15d952469533.png)"/>
                </outline>
              </outline>
            </outline>
            <outline text="pyplot的plot()函数" collapsed="true">
              <outline text="plt.plot(x, y, format_string, **kwarge)" _note="&#10;&#10;x：X轴数据，列表或数组，可选&#10;&#10;y：Y轴数据，列表或数组&#10;&#10;format_string：控制曲线的格式字符串，可选&#10;&#10;**kwarg：第二组或更多（x，y，format_string）&#10;&#10;当绘制多条曲线时，各条曲线的x不能省略。">
                <outline text="代码" _note="&#10;import matplotlib.pyplot as plt &#10;import numpy as np&#10;&#10;a = np.arange(10)&#10;plt.plot(a, a*1.5, a, a*2.5, a, a*3.5, a, a*4.5)&#10;plt.show()&#10;"/>
                <outline text="![代码结果](https://user-images.githubusercontent.com/19257507/97125687-a57a5a80-176f-11eb-827d-7530f842e9e5.png)"/>
                <outline text="format_string格式字符串" _note="&#10;format_string：控制曲线的格式字符串，可选由颜色字符、风格字符和标记字符组成" collapsed="true">
                  <outline text="颜色字符" collapsed="true">
                    <outline text="&apos;b&apos;" _note="蓝色"/>
                    <outline text="&apos;g&apos;" _note="绿色"/>
                    <outline text="&apos;r&apos;" _note="&#10;红色"/>
                    <outline text="&apos;c&apos;" _note="&#10;cyan 青绿色"/>
                    <outline text="&apos;#008000&apos;" _note="&#10;RGB某颜色"/>
                    <outline text="&apos;m&apos;" _note="&#10;magenta 洋红色"/>
                    <outline text="&apos;y&apos;" _note="&#10;黄色"/>
                    <outline text="&apos;k&apos;" _note="&#10;黑色"/>
                    <outline text="&apos;w&apos;" _note="&#10;白色"/>
                    <outline text="&apos;0.8&apos;" _note="&#10;灰度值字符串"/>
                  </outline>
                  <outline text="风格字符" collapsed="true">
                    <outline text="&apos;-&apos;" _note="实线"/>
                    <outline text="&apos;--&apos;" _note="&#10;破折线"/>
                    <outline text="&apos;-.&apos;" _note="&#10;点划线"/>
                    <outline text="&apos;:&apos;" _note="&#10;虚线"/>
                    <outline text="&apos; &apos;  &apos;  &apos;" _note="&#10;无线条"/>
                  </outline>
                  <outline text="标记字符" collapsed="true">
                    <outline text="&apos;.&apos;" _note="&#10;点标记"/>
                    <outline text="&apos;,&apos;" _note="&#10;像素标记（极小点）"/>
                    <outline text="&apos;o&apos;" _note="&#10;实心圈标记"/>
                    <outline text="&apos;v&apos;" _note="&#10;倒三角标记"/>
                    <outline text="&apos;^&apos;" _note="&#10;上三角标记"/>
                    <outline text="&apos;&gt;&apos;" _note="&#10;右三角标记"/>
                    <outline text="&apos;&lt;&apos;" _note="&#10;左三角标记"/>
                    <outline text="&apos;1&apos;" _note="&#10;下花三角标记"/>
                    <outline text="&apos;2&apos;" _note="&#10;上花三角标记"/>
                    <outline text="&apos;3&apos;" _note="&#10;左花三角标记"/>
                    <outline text="&apos;4&apos;" _note="&#10;右花三角标记"/>
                    <outline text="&apos;5&apos;" _note="&#10;实心方形标记"/>
                    <outline text="&apos;p&apos;" _note="&#10;实心五角标记"/>
                    <outline text="&apos;*&apos;" _note="&#10;星形标记"/>
                    <outline text="&apos;h&apos;" _note="&#10;竖六边形标记"/>
                    <outline text="&apos;H&apos;" _note="&#10;横六变形标记"/>
                    <outline text="&apos;+&apos;" _note="&#10;十字标记"/>
                    <outline text="&apos;x&apos;" _note="&#10;x标记"/>
                    <outline text="&apos;D&apos;" _note="&#10;菱形标记"/>
                    <outline text="&apos;d&apos;" _note="&#10;瘦菱形标记"/>
                    <outline text="&apos;|&apos;" _note="&#10;垂直线标记"/>
                  </outline>
                  <outline text="组合使用代码举例" _note="&#10;import matplotlib.pyplot as plt &#10;import numpy as np&#10;&#10;a = np.arange(10)&#10;plt.plot(a, a*1.5, &apos;go-&apos;,a, a*2.5,&apos;rx&apos;, a, a*3.5,&apos;*&apos;, a, a*4.5,&apos;b-.&apos;)&#10;plt.show()"/>
                  <outline text="![组合使用结果](https://user-images.githubusercontent.com/19257507/97127224-fd1ac500-1773-11eb-9c16-ce28a14e3f9d.png)"/>
                </outline>
                <outline text="**kwargs  ：第二组或更多(x, y, format_string)">
                  <outline text="color" _note="&#10;控制颜色  &#10;&#10;color = &apos;green&apos;"/>
                  <outline text="linestyle" _note="&#10;线条风格&#10;&#10;linestyle = &apos;dashed&apos;"/>
                  <outline text="marker" _note="&#10;标记风格&#10;&#10;marker = ’o‘"/>
                  <outline text="markerfacecolor" _note="&#10;标记颜色&#10;&#10;markerfacecolor = &apos;blue&apos;"/>
                  <outline text="markersize" _note="&#10;标记尺寸&#10;&#10;markersize = 20"/>
                </outline>
              </outline>
            </outline>
            <outline text="pyplot的中文显示" _note="&#10;pyplot并不默认支持中文显示，要显示中文有两个方法：rcParams 和 fontproperties&#10;&#10;&#10;import numpy as np &#10;import matplotlib.pyplot as plt &#10;&#10;a = np.arange(0.0, 5.0, 0.02)&#10;&#10;plt.xlabel(&apos;横轴：时间&apos;, fontproperties=&apos;SimHei&apos;, fontsize =20)&#10;plt.ylabel(&apos;纵轴：振幅&apos;, fontproperties=&apos;SimHei&apos;, fontsize =20)&#10;plt.plot(a, np.cos(2*np.pi*a), &apos;r--&apos;)&#10;plt.show()&#10;&#10;&#10;" collapsed="true">
              <outline text="rcParams" _note="&#10;pyplot并不默认支持中文显示，需要rcParams修改字体实现" collapsed="true">
                <outline text="代码示例" _note="&#10;import matplotlib.pyplot as plt &#10;import matplotlib&#10;&#10;matplotlib.rcParams[&apos;font.family&apos;]=&apos;SimHei&apos;&#10;plt.plot([3, 1, 5, 4, 2])&#10;plt.ylabel(&quot;纵轴(值)&quot;)&#10;plt.savefig(&apos;test&apos;, dpi=600)&#10;plt.show()&#10;&#10;&#10;’SimHei‘是黑体"/>
                <outline text="![代码示例图片](https://user-images.githubusercontent.com/19257507/97127906-e37a7d00-1775-11eb-9b48-df6a826514bf.png)"/>
                <outline text="&apos;font.famliy&apos;" _note="&#10;用于显示字体的名字&#10;&#10;&#10;import numpy as np &#10;import matplotlib.pyplot as plt &#10;import matplotlib&#10;&#10;matplotlib.rcParams[&apos;font.family&apos;]=&apos;STSong&apos;&#10;matplotlib.rcParams[&apos;font.size&apos;]=20&#10;&#10;a = np.arange(0.0, 5.0, 0.02)&#10;&#10;plt.xlabel(&apos;横轴：时间&apos;)&#10;plt.ylabel(&apos;纵轴：振幅&apos;)&#10;plt.plot(a, np.cos(2*np.pi*a), &apos;r--&apos;)&#10;plt.show()&#10;">
                  <outline text="&apos;SimHei&apos;" _note="&#10;中文黑体"/>
                  <outline text="&apos;Kaiti&apos;" _note="&#10;中文楷体"/>
                  <outline text="&apos;LiSu&apos;" _note="&#10;中文隶书"/>
                  <outline text="&apos;FangSong&apos;" _note="&#10;中文仿宋"/>
                  <outline text="&apos;YouYuan&apos;" _note="&#10;中文幼圆"/>
                  <outline text="&apos;STSong&apos;" _note="&#10;华文宋体"/>
                </outline>
                <outline text="&apos;font.style&apos;" _note="&#10;字体风格，正常&apos;normal&apos;或 斜体&apos;italic&apos;"/>
                <outline text="&apos;font.size&apos;" _note="&#10;字体大小，整数字号或者’large‘、’x-small‘"/>
              </outline>
              <outline text="fontproperties" _note="&#10;在有中文输出的地方，增加一个属性：fontproperties"/>
            </outline>
            <outline text="pyplot的文本显示" collapsed="true">
              <outline text="pyplot的文本显示函数" collapsed="true">
                <outline text="plt.xlabel()" _note="&#10;对x轴增加文本标签"/>
                <outline text="plt.ylabel()" _note="&#10;对Y轴增加文本标签"/>
                <outline text="plt.title()" _note="&#10;对图形整体增加文本标签"/>
                <outline text="plt.text()" _note="&#10;在任意位置增加文本"/>
                <outline text="plt.annotate()" _note="&#10;在图形中增加带箭头的注释"/>
                <outline text="实例1" _note="&#10;import numpy as np &#10;import matplotlib.pyplot as plt &#10;&#10;a = np.arange(0.0, 5.0, 0.02)&#10;plt.plot(a, np.cos(2*np.pi*a), &apos;r--&apos;)&#10;&#10;plt.xlabel(&apos;横轴：时间&apos;, fontproperties=&apos;SimHei&apos;, fontsize =15, color=&apos;green&apos;)&#10;plt.ylabel(&apos;纵轴：振幅&apos;, fontproperties=&apos;SimHei&apos;, fontsize =20)&#10;plt.title(r&apos;正弦波实例 $y=cos(2\pi x)$&apos;, fontproperties=&apos;SimHei&apos;,fontsize=25)&#10;plt.text(2, 1, r&apos;$\mu=100$&apos;, fontsize=15)&#10;&#10;plt.axis([-1, 6, -2, 2])&#10;plt.grid(True)&#10;plt.show()&#10;&#10;&#10;&#10;$y=cos(2\pi x)$是一种排版格式Latex&#10;&#10;"/>
              </outline>
              <outline text="plt.annotate(s, xy=arrow_crd, xytext=text_crd, arrowprops=dict)" _note="&#10;import numpy as np &#10;import matplotlib.pyplot as plt &#10;&#10;a = np.arange(0.0, 5.0, 0.02)&#10;plt.plot(a, np.cos(2*np.pi*a), &apos;r--&apos;)&#10;&#10;plt.xlabel(&apos;横轴：时间&apos;, fontproperties=&apos;SimHei&apos;, fontsize =15, color=&apos;green&apos;)&#10;plt.ylabel(&apos;纵轴：振幅&apos;, fontproperties=&apos;SimHei&apos;, fontsize =20)&#10;plt.title(r&apos;正弦波实例 $y=cos(2\pi x)$&apos;, fontproperties=&apos;SimHei&apos;,fontsize=25)&#10;plt.annotate(r&apos;$\mu=100$&apos;, xy=(2,1), xytext=(3, 1.5), arrowprops=dict(facecolor=&apos;black&apos;,shrink=0.1, width=2))&#10;&#10;&#10;plt.axis([-1, 6, -2, 2])&#10;plt.grid(True)&#10;plt.show()&#10;&#10;"/>
            </outline>
            <outline text="pyplot的自绘图区域" collapsed="true">
              <outline text="复杂的绘图区域">
                <outline text="![复杂的绘图区域](https://upload-images.jianshu.io/upload_images/64046-d66dcf4211e3f3a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)"/>
              </outline>
              <outline text="plt.subplot2gird()" _note="&#10;plt.subplot2grid(GridSpec, CurSec, colspan=1, rowspan=1)&#10;&#10;&#10;理念：设定网络，选中网络，确定选中行列区域数量，编号从0开始&#10;&#10;&#10;plt.subplot2grid((3, 3), (0, 0), colspan=3)            选中的是ax1区域&#10;&#10;plt.subplot2grid((3, 3), (1, 0), colspan=2)              选中的是ax2区域&#10;&#10;plt.subplot2grid((3, 3), (1, 2), colspan=2)              选中的是ax3区域&#10;&#10;plt.subplot2grid((3, 3), (2, 0))                                   选中的是ax4区域&#10;&#10;plt.subplot2grid((3, 3), (2, 1))                                   选中的是ax5区域&#10;&#10;&#10;"/>
              <outline text="GridSpec类" _note="&#10;import matplotlib.gridspec as gridspec&#10;import matplotlib.pyplot as plt&#10;&#10;gs = gridspec.GridSpec(3,3)&#10;&#10;ax1 = plt.subplot(gs[0, :])&#10;ax2 = plt.subplot(gs[1, :-1])&#10;ax3 = plt.subplot(gs[1:, -1])&#10;ax4 = plt.subplot(gs[2,0])&#10;ax5 = plt.subplot(gs[2,1])&#10;&#10;plt.show()&#10;&#10;"/>
            </outline>
          </outline>
          <outline text="单元5：Matplotlib基础绘图函数示例（5个实例）" collapsed="true">
            <outline text="plot基础图表函数概述" collapsed="true">
              <outline text="plt.plot(x, y, fmt, ...)" _note="&#10;绘制一个坐标图"/>
              <outline text="plt.boxplot(data, notch, position)" _note="&#10;绘制一个箱型图"/>
              <outline text="plt.bar(left, height, width, bottom)" _note="&#10;绘制一个条形图"/>
              <outline text="plt.polar(theta, r)" _note="&#10;绘制极坐标图"/>
              <outline text="plt.pie(data, explode)" _note="&#10;绘制饼图"/>
              <outline text="plt.psd(x, NFFT=256, pad_to, Fs)" _note="&#10;绘制功率谱密度图"/>
              <outline text="plt.specgram(x, NFFT=256, pad_to, F)" _note="&#10;绘制谱图"/>
              <outline text="plt.cohere(x,y ,NFFT=256, Fs)" _note="&#10;绘制X-Y的相关性函数"/>
              <outline text="plt.scatter(x, y)" _note="&#10;绘制三点图， 其中，x和y长度相同"/>
              <outline text="plt.step(x, y, where)" _note="&#10;绘制步阶图"/>
              <outline text="plt.hist(x, bins, normed)" _note="&#10;绘制直方图"/>
              <outline text="plt.contour(X, Y, Z, N)" _note="&#10;绘制等值图"/>
              <outline text="plt.vlines()" _note="&#10;绘制垂直图"/>
              <outline text="plt.stem(x, y, linefmt, markerfmt)" _note="&#10;绘制柴火图"/>
              <outline text="plt.plot_date()" _note="&#10;绘制数据日期"/>
            </outline>
            <outline text="pyplot饼图的绘制——plt.pie()" collapsed="true">
              <outline text="实例1：普通饼图" _note="&#10;import matplotlib.pyplot as plt&#10;&#10;labels = &apos;Frogs&apos;,&apos;Hogs&apos;,&apos;Dogs&apos;,&apos;Logs&apos;&#10;sizes = [15, 30, 45, 10]&#10;explode = (0, 0.1, 0, 0)&#10;&#10;plt.pie(sizes, explode= explode, labels=labels, autopct=&apos;%1.1f%%&apos;,&#10;        shadow=False, startangle=90)&#10;&#10;plt.show()&#10;&#10;"/>
              <outline text="实例2：强调其中一块的饼图" _note="&#10;import matplotlib.pyplot as plt&#10;&#10;labels = &apos;Frogs&apos;,&apos;Hogs&apos;,&apos;Dogs&apos;,&apos;Logs&apos;&#10;sizes = [15, 30, 45, 10]&#10;explode = (0, 0.1, 0, 0)&#10;&#10;plt.pie(sizes, explode= explode, labels=labels, autopct=&apos;%1.1f%%&apos;,&#10;        shadow=False, startangle=90)&#10;&#10;plt.axis(&apos;equal&apos;)&#10;plt.show()&#10;&#10;"/>
            </outline>
            <outline text="pyplot直方图的绘制——plt.hist()" collapsed="true">
              <outline text="实例：普通直方图" _note="&#10;import numpy as np&#10;import matplotlib.pyplot as plt&#10;&#10;np.random.seed(0)&#10;mu,sigma = 100, 20 #均值和标准差&#10;a = np.random.normal(mu, sigma, size=100)&#10;&#10;plt.hist(a, 20, density=True, histtype=&apos;stepfilled&apos;, facecolor=&apos;b&apos;, alpha=0.75)&#10;plt.title(&apos;Histogram&apos;)&#10;&#10;plt.show()&#10;&#10;&#10;课程里是&#10;&#10;plt.hist(a, 20, normed=1, histtype=&apos;stepfilled&apos;, facecolor=&apos;b&apos;, alpha=0.75)&#10;&#10;运行时显示，&apos;Polygon&apos; object has no property &apos;normed&apos;&#10;&#10;经查找，normed=1的属性已经取消，可以使用density=True。"/>
              <outline text="实例：控制直方图的直方个数" _note="&#10;import numpy as np&#10;import matplotlib.pyplot as plt&#10;&#10;np.random.seed(0)&#10;mu,sigma = 100, 20 #均值和标准差&#10;a = np.random.normal(mu, sigma, size=100)&#10;&#10;plt.hist(a, 10, density=True, histtype=&apos;stepfilled&apos;, facecolor=&apos;b&apos;, alpha=0.75)  # 10个直方&#10;plt.title(&apos;Histogram&apos;)&#10;&#10;plt.show()&#10;&#10;&#10;&#10;import numpy as np&#10;import matplotlib.pyplot as plt&#10;&#10;np.random.seed(0)&#10;mu,sigma = 100, 20 #均值和标准差&#10;a = np.random.normal(mu, sigma, size=100)&#10;&#10;plt.hist(a, 40, density=True, histtype=&apos;stepfilled&apos;, facecolor=&apos;b&apos;, alpha=0.75) # 40个直方&#10;plt.title(&apos;Histogram&apos;)&#10;&#10;plt.show()&#10;&#10;&#10;plt.hist()中的bin是控制直方图的直方个数的，比如10就是10个直方，40就是40个直方。&#10;&#10;"/>
            </outline>
            <outline text="pyplot极坐标图的绘制——面向对象绘制极坐标" collapsed="true">
              <outline text="实例代码1" _note="&#10;import numpy as np&#10;import matplotlib.pyplot as plt &#10;&#10;N = 20&#10;theta = np.linspace(0.0, 2 * np.pi, N, endpoint=False)&#10;radii = 10 * np.random.rand(N)&#10;width = np.pi / 4 * np.random.rand(N)&#10;&#10;ax = plt.subplot(111, projection=&apos;polar&apos;)&#10;bars = ax.bar(theta, radii, width=width, bottom=0.0)&#10;&#10;for r,bar in zip(radii, bars):&#10;        bar.set_facecolor(plt.cm.viridis(r / 10.))&#10;        bar.set_alpha(0.5)&#10;&#10;plt.show()&#10;&#10;&#10;注意：&#10;bars = ax.bar(theta, radii, width=width, bottom=0.0)&#10;中的theta是left，radii是height， width=width是width&#10;&#10;"/>
              <outline text="![面向对象绘制极坐标图](https://upload-images.jianshu.io/upload_images/64046-657f1c59e9221118.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)"/>
              <outline text="实例代码2" _note="&#10;import numpy as np&#10;import matplotlib.pyplot as plt &#10;&#10;N = 10&#10;theta = np.linspace(0.0, 2 * np.pi, N, endpoint=False)&#10;radii = 10 * np.random.rand(N)&#10;width = np.pi / 4 * np.random.rand(N)&#10;&#10;ax = plt.subplot(111, projection=&apos;polar&apos;)&#10;bars = ax.bar(theta, radii, width=width, bottom=0.0)&#10;&#10;for r,bar in zip(radii, bars):&#10;        bar.set_facecolor(plt.cm.viridis(r / 10.))&#10;        bar.set_alpha(0.5)&#10;&#10;plt.show()&#10;&#10;&#10;注意：&#10;&#10;N的个数发生变化。&#10;"/>
            </outline>
            <outline text="pyplot散点图的绘制——面向对象绘制散点图" _note="&#10;import numpy as np&#10;import matplotlib.pyplot as plt &#10;&#10;fig,  ax = plt.subplots()&#10;ax.plot(10*np.random.randn(100), 10*np.random.randn(100), &apos;o&apos;)&#10;ax.set_title(&apos;Simple Scatter&apos;)&#10;  &#10;plt.show()"/>
          </outline>
          <outline text="单元6：引力波的绘制  #实例 " collapsed="true">
            <outline text="数据源" _note="&#10;python123.io/dv/grawave.html&#10;"/>
            <outline text="实例编写" _note="&#10;import numpy as np&#10;import matplotlib.pyplot as plt &#10;from scipy.io import wavfile&#10;&#10;rate_h, hstrain= wavfile.read(r&quot;H1_Strain.wav&quot;, &quot;rb&quot;)&#10;rate_l, lstrain= wavfile.read(r&quot;L1_Strain.wav&quot;,&quot;rb&quot;)&#10;reftime, ref_H1 = np.genfromtxt(&apos;wf_template.txt&apos;).transpose()&#10;&#10;htime_interval = 1/rate_h&#10;litme_interval = 1/rate_l&#10;&#10;htime_len = hstrain.shape[0]/rate_h&#10;htime = np.arange(-htime_len/2, htime_len/2, htime_interval)&#10;ltime_len = lstrain.shape[0]/rate_l&#10;ltime = np.arange(-ltime_len/2, ltime_len/2, litme_interval)&#10;&#10;fig = plt.figure(figsize=(12, 6))&#10;&#10;plth = fig.add_subplot(221)&#10;plth.plot(htime, hstrain, &apos;y&apos;)&#10;plth.set_xlabel(&apos;Time(seconds)&apos;)&#10;plth.set_ylabel(&apos;H1 Strain&apos;)&#10;plth.set_title(&apos;H1 Strain&apos;)&#10;&#10;pltl = fig.add_subplot(222)&#10;pltl.plot(ltime, lstrain, &apos;g&apos;)&#10;pltl.set_xlabel(&apos;Time (seconds)&apos;)&#10;pltl.set_ylabel(&apos;L1 Strain&apos;)&#10;pltl.set_title(&apos;L1 Strain&apos;)&#10;&#10;pltref = fig.add_subplot(212)&#10;pltref.plot(reftime, ref_H1)&#10;pltref.set_xlabel(&apos;Time (seconds)&apos;)&#10;pltref.set_ylabel(&apos;Timplate Strain&apos;)&#10;pltref.set_title(&apos;Template&apos;)&#10;fig.tight_layout()&#10;&#10;plt.savefig(&quot;Gravitational_Waves_Original.png&quot;)&#10;plt.show()&#10;plt.close(fig)&#10;&#10;&#10;"/>
            <outline text="实例解说">
              <outline text="产生时间序列" _note="&#10;从配置文档中读取时间相关数据&#10;&#10;import numpy as np&#10;import matplotlib.pyplot as plt &#10;from scipy.io import wavfile&#10;&#10;rate_h, hstrain= wavfile.read(r&quot;H1_Strain.wav&quot;, &quot;rb&quot;)&#10;rate_l, lstrain= wavfile.read(r&quot;L1_Strain.wav&quot;,&quot;rb&quot;)&#10;reftime, ref_H1 = np.genfromtxt(&apos;wf_template.txt&apos;).transpose()"/>
              <outline text="读取应变数据" _note="&#10;htime_interval = 1/rate_h&#10;litme_interval = 1/rate_l&#10;&#10;htime_len = hstrain.shape[0]/rate_h&#10;htime = np.arange(-htime_len/2, htime_len/2, htime_interval)&#10;ltime_len = lstrain.shape[0]/rate_l&#10;ltime = np.arange(-ltime_len/2, ltime_len/2, litme_interval)"/>
              <outline text="绘制H1 Strain" _note="&#10;使用来自“H1”探测器的数据作图&#10;&#10;fig = plt.figure(figsize=(12, 6))   # 创建一个大型为12*6的绘图空间&#10;&#10;# 画出以时间为X轴，应变数据为Y轴的图像并设置标题和坐标轴的标签&#10;plth = fig.add_subplot(221)&#10;plth.plot(htime, hstrain, &apos;y&apos;)&#10;plth.set_xlabel(&apos;Time(seconds)&apos;)&#10;plth.set_ylabel(&apos;H1 Strain&apos;)&#10;plth.set_title(&apos;H1 Strain&apos;)"/>
              <outline text="绘制L1 Strain &amp; Template" _note="&#10;pltl = fig.add_subplot(222)&#10;pltl.plot(ltime, lstrain, &apos;g&apos;)&#10;pltl.set_xlabel(&apos;Time (seconds)&apos;)&#10;pltl.set_ylabel(&apos;L1 Strain&apos;)&#10;pltl.set_title(&apos;L1 Strain&apos;)&#10;&#10;pltref = fig.add_subplot(212)&#10;pltref.plot(reftime, ref_H1)&#10;pltref.set_xlabel(&apos;Time (seconds)&apos;)&#10;pltref.set_ylabel(&apos;Timplate Strain&apos;)&#10;pltref.set_title(&apos;Template&apos;)&#10;fig.tight_layout()&#10;&#10;以完全相同的方法绘制另外两幅图像。&#10;分别放在绘图区域的第一列右边和第二列"/>
              <outline text="显示并保存图像" _note="&#10;# 自动调整图像外部边缘&#10;fig.tight_layout()&#10;&#10;plt.savefig(&quot;Gravitational_Waves_Original.png&quot;)  # 保存图像为PNG格式&#10;plt.show()&#10;plt.close(fig)&#10;&#10;&#10;"/>
            </outline>
          </outline>
        </outline>
        <outline text="第3周：数据分析之概要">
          <outline text="单元7：Pandas库入门" _note="&#10;www.pandas.pydata.org" collapsed="true">
            <outline text="Pandas的介绍" collapsed="true">
              <outline text="Pandas库的引用" _note="&#10;Pandas是Python第三方库，提供高性能应用数据类型和分析工具&#10;&#10;Pandas基于Numpy实现，常与Numpy和Matplotlib一同使用&#10;&#10;import pandas as pd"/>
              <outline text="Pandas库小测" _note="&#10;In [2]: import pandas as pd&#10;&#10;&#10;In [3]: d= pd.Series(range(20))&#10;&#10;&#10;In [4]: d&#10;Out[4]: &#10;0  0&#10;1    1&#10;2   2&#10;3   3&#10;4   4&#10;5    5&#10;6    6&#10;7    7&#10;8    8&#10;9    9&#10;10 10&#10;11  11&#10;12  12&#10;13  13&#10;14  14&#10;15  15&#10;16  16&#10;17  17&#10;18  18&#10;19  19&#10;dtype: int64&#10;&#10;&#10;In [5]: d.cumsum()&#10;Out[5]: &#10;0    0&#10;1      1&#10;2     3&#10;3     6&#10;4   10&#10;5    15&#10;6    21&#10;7    28&#10;8    36&#10;9    45&#10;10   55&#10;11    66&#10;12   78&#10;13    91&#10;14 105&#10;15 120&#10;16 136&#10;17 153&#10;18 171&#10;19 190&#10;dtype: int64&#10;&#10;计算前N项累加和&#10;&#10;&#10;&#10;&#10;"/>
              <outline text="Pandas库的理解">
                <outline text="两个数据类型" _note="&#10;&#10;两个数据类型： Series, DataFrame&#10;&#10;基于上述数据类型的各类操作&#10;&#10;基本操作，运算操作，特征类操作，关联类操作"/>
                <outline text="Numpy VS Pandas" _note="&#10;Numpy：基础数据类型   关注数据的结构表达     维度：数据间的关系&#10;&#10;Pandas：扩展数据类型    关注数据的应用表达     数据与索引间关系"/>
              </outline>
            </outline>
            <outline text="Pandas库的Series类型" collapsed="true">
              <outline text="Series类型由一组数据及与之相关的数据索引构成" _note="&#10;index_0 → data_a&#10;&#10;index_1 → data_b&#10;&#10;index_2 → data_c&#10;&#10;index_3 → data_d&#10;&#10;索引            数据"/>
              <outline text="索引类型">
                <outline text="可以自动索引" _note="&#10;In [6]: import pandas as pd&#10;&#10;&#10;In [7]: a = pd.Series([9, 8, 7, 6])&#10;&#10;&#10;In [8]: a&#10;Out[8]: &#10;0   9&#10;1    8&#10;2   7&#10;3   6&#10;dtype: int64&#10;&#10;里面的0，1，2，3是自动索引&#10;&#10;dtype: int64是NumPy中数据类型&#10;&#10;"/>
                <outline text="可以自定义索引" _note="&#10;&#10;import pandas as pd&#10;&#10;b = pd.Series([9, 8, 7, 6], index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]) # index作为第二个参数，可以省略&#10;&#10;b&#10;Out[11]: &#10;a    9&#10;b    8&#10;c    7&#10;d    6&#10;dtype: int64&#10;&#10;里面的a，b，c，d是自定义索引&#10;"/>
              </outline>
              <outline text="Series类型创建" collapsed="true">
                <outline text="Python列表" _note="&#10;index与列表元素个数一致&#10;&#10;In [15]: import pandas as pd&#10;&#10;&#10;In [16]: b = pd.Series([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;])&#10;&#10;&#10;In [17]: b&#10;Out[17]: &#10;0 a&#10;1  b&#10;2 c&#10;dtype: object"/>
                <outline text="标量值" _note="&#10;index表达Series类型的尺寸&#10;&#10;In [12]: import pandas as pd&#10;&#10;&#10;In [13]: b = pd.Series(25, index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;])  # 不能省略index&#10;&#10;&#10;In [14]: b&#10;Out[14]: &#10;a 25&#10;b 25&#10;c 25&#10;dtype: int64"/>
                <outline text="Python字典" _note="&#10;键值对中的“键”是索引，index从字典中进行选择操作&#10;&#10;In [20]: import pandas as pd&#10;&#10;&#10;In [21]: b = pd.Series({&apos;a&apos;:9,&apos;b&apos;:8,&apos;c&apos;:7})&#10;&#10;&#10;In [22]: b&#10;Out[22]: &#10;a 9&#10;b 8&#10;c 7&#10;dtype: int64&#10;&#10;&#10;&#10;&#10;In [23]: import pandas as pd&#10;&#10;&#10;In [24]: e = pd.Series({&apos;a&apos;:9,&apos;b&apos;:8,&apos;c&apos;:7}, index=[&apos;c&apos;,&apos;a&apos;,&apos;b&apos;,&apos;d&apos;])  # index从字典中进行选择操作&#10;&#10;&#10;In [25]: e&#10;Out[25]: &#10;c 7.0&#10;a 9.0&#10;b 8.0&#10;d NaN&#10;dtype: float64&#10;"/>
                <outline text="ndarray" _note="&#10;索引和数据都可以通过ndarray类型创建&#10;&#10;&#10;In [26]: import pandas as pd&#10;&#10;&#10;In [27]: import numpy as np&#10;&#10;&#10;In [28]: n = pd.Series(np.arange(5))&#10;&#10;&#10;In [29]: n&#10;Out[29]: &#10;0 0&#10;1   1&#10;2  2&#10;3  3&#10;4  4&#10;dtype: int32&#10;&#10;&#10;In [30]: m = pd.Series(np.arange(5), index= np.arange(9,4,-1))&#10;&#10;In [31]: m&#10;Out[31]: &#10;9    0&#10;8    1&#10;7    2&#10;6    3&#10;5    4&#10;dtype: int32"/>
                <outline text="其他函数" _note="&#10;range()函数等"/>
              </outline>
              <outline text="Series类型的基本操作" collapsed="true">
                <outline text="Series类型包括index和values两部分" _note="&#10;.index获得索引&#10;&#10;.values获得数据&#10;&#10;In [32]: import pandas as pd&#10;&#10;&#10;In [33]: b= pd.Series([9, 8, 7, 6],[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])&#10;&#10;&#10;In [34]: b&#10;Out[34]: &#10;a 9&#10;b 8&#10;c 7&#10;d 6&#10;dtype: int64&#10;&#10;&#10;In [35]: b.index&#10;Out[35]: Index([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;], dtype=&apos;object&apos;)&#10;&#10;&#10;In [36]: b.values&#10;Out[36]: array([9, 8, 7, 6], dtype=int64)&#10;&#10;&#10;&#10;" collapsed="true">
                  <outline text="自动索引和自定义索引并存，但不能混用" _note="&#10;&#10;&#10;In [37]: b[&apos;b&apos;]&#10;Out[37]: 8&#10;&#10;&#10;In [38]: b[1]&#10;Out[38]: 8&#10;&#10;In [40]: b[[&apos;c&apos;,&apos;d&apos;,&apos;a&apos;]]&#10;Out[40]: &#10;c 7&#10;d 6&#10;a 9&#10;dtype: int64"/>
                </outline>
                <outline text="Series类型的操作类似ndarray类型" _note="&#10;索引方法相同，采用[]&#10;&#10;Numpy中运算和操作可以用于Series类型&#10;&#10;可以通过自定义索引的列表进行切片&#10;&#10;可以通过自动索引进行切片，如果存在自定义索引，则一同被切片&#10;&#10;">
                  <outline text="实例" _note="&#10;In [42]: import pandas as pd&#10;&#10;&#10;In [43]: b= pd.Series([9, 8, 7, 6],[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])&#10;&#10;&#10;In [44]: b&#10;Out[44]: &#10;a 9&#10;b 8&#10;c 7&#10;d 6&#10;dtype: int64&#10;&#10;&#10;In [45]: b[3]&#10;Out[45]: 6&#10;&#10;&#10;In [46]: b[:3]&#10;Out[46]: &#10;a 9&#10;b 8&#10;c 7&#10;dtype: int64&#10;&#10;&#10;In [47]: b[b &gt; b.median()]&#10;Out[47]: &#10;a 9&#10;b 8&#10;dtype: int64&#10;&#10;&#10;In [48]: np.exp(b)&#10;Out[48]: &#10;a 8103.083928&#10;b 2980.957987&#10;c 1096.633158&#10;d 403.428793&#10;dtype: float64"/>
                </outline>
                <outline text="Series类型的操作类似Python字典类型" _note="&#10;· 通过自定义索引访问&#10;&#10;· 保留字in操作&#10;&#10;· 使用.get()方法&#10;&#10;&#10;In [49]: import pandas as pd&#10;&#10;&#10;In [50]: b= pd.Series([9, 8, 7, 6],[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])&#10;&#10;&#10;In [51]: b[&apos;b&apos;]&#10;Out[51]: 8&#10;&#10;&#10;In [52]: &apos;c&apos; in b&#10;Out[52]: True&#10;&#10;In [54]: 0 in b&#10;Out[54]: False&#10;&#10;&#10;In [55]: b.get(&apos;f&apos;, 100)&#10;Out[55]: 100"/>
              </outline>
              <outline text="Series类型对齐操作">
                <outline text="Series + Series" _note="&#10;Series类型在运算中自动对齐不同索引的数据&#10;&#10;In [57]: import pandas as pd&#10;&#10;&#10;In [58]: a= pd.Series([1, 2, 3],[&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])&#10;&#10;&#10;In [59]: b= pd.Series([9, 8, 7, 6],[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])&#10;&#10;&#10;In [60]: a+b&#10;Out[60]: &#10;a NaN&#10;b NaN&#10;c 8.0&#10;d 8.0&#10;e NaN&#10;dtype: float64"/>
              </outline>
              <outline text="Series类型的name属性" _note="&#10;Series对象和索引都可以有一个名字，存储在属性.name中&#10;&#10;In [64]: import pandas as pd&#10;&#10;&#10;In [65]: b= pd.Series([9, 8, 7, 6],[&apos;a&apos;,&apos;b&apos;,&apos;d&apos;,&apos;d&apos;])&#10;&#10;&#10;In [66]: b.name&#10;&#10;&#10;In [67]: b.name = &apos;Series对象&apos;&#10;&#10;&#10;In [68]: b.index.name = &apos;索引列&apos;&#10;&#10;&#10;In [69]: b&#10;Out[69]: &#10;索引列&#10;a 9&#10;b 8&#10;d 7&#10;d 6&#10;Name: Series对象, dtype: int64"/>
              <outline text="Series类型的修改" _note="&#10;Series对象可以随时修改并即刻生效&#10;&#10;In [70]: import pandas as pd&#10;&#10;&#10;In [71]: b= pd.Series([9, 8, 7, 6],[&apos;a&apos;,&apos;b&apos;,&apos;d&apos;,&apos;d&apos;])&#10;&#10;&#10;In [72]: b[&apos;a&apos;]=15&#10;&#10;&#10;In [73]: b.name=&apos;Series&apos;&#10;&#10;&#10;In [74]: b&#10;Out[74]: &#10;a 15&#10;b 8&#10;d 7&#10;d 6&#10;Name: Series, dtype: int64&#10;&#10;&#10;In [75]: b.name=&apos;New Series&apos;&#10;&#10;&#10;In [78]: b&#10;Out[78]: &#10;a    15&#10;b     8&#10;d     7&#10;d     6&#10;Name: New Series, dtype: int64"/>
              <outline text="Series是一维带“标签”数组" _note="&#10;index_0 →data_a&#10;&#10;Series基本操作类似ndarray和字典，根据索引对齐"/>
            </outline>
            <outline text="Pandas库的DataFrame类型" collapsed="true">
              <outline text="DataFrame类型由共用相同索引的一组列表构成" _note="&#10;&#10;ndex_0 → data_a     data_1  ...                       data_w&#10;&#10;index_1 → data_b     data_2  ...                       data_x&#10;&#10;index_2 → data_c     data_3 ...                        data_y&#10;&#10;index_3 → data_d     data_4 ...                        data_z&#10;&#10;索引             多列数据"/>
              <outline text="DataFrame类型是一个表格类型的数据类型" _note="&#10;每列值类型可以不同&#10;&#10;DataFrame既有行索引，也有列索引&#10;&#10;DataFrame常用于表达二维数据，但可以表达多维数据&#10;&#10;&#10;                      colum                        axis=1&#10;&#10;index            index_0 → data_a   data_1 ... data_w&#10;&#10;                       index_1 → data_b    data_2 ... data_x&#10;&#10;                       index_2 → data_c   data_3 ... data_y&#10;&#10;axis=0          index_3 → data_d   data_4 ... data_z"/>
              <outline text="DataFrame类型创建">
                <outline text="二维ndarray对象" _note="&#10;In [84]: import pandas as pd&#10;&#10;&#10;In [85]: import numpy as np&#10;&#10;&#10;In [86]: d = pd.DataFrame(np.arange(10).reshape(2,5))&#10;&#10;&#10;In [87]: d&#10;Out[87]: &#10;        0 1 2 3 4  # 自动列索引&#10;0     0 1 2 3 4&#10;1      5 6 7 8 9&#10;&#10;# 竖着的0   1是自动行索引&#10;&#10;"/>
                <outline text="由一维ndarray、列表、字典、元组或Series构成的字典">
                  <outline text="由一维ndarray对象构成的字典创建" _note="&#10;&#10;In [9]: import pandas as pd&#10;&#10;In [11]: dt = {&apos;one&apos;: pd.Series([1,2,3], index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]),&#10;    ...: &apos;two&apos;: pd.Series([9,8,7,6], index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])}&#10;&#10;&#10;In [12]: d = pd.DataFrame(dt)&#10;&#10;&#10;In [13]: d&#10;Out[13]: &#10;  one two&#10;a 1.0      9&#10;b 2.0     8&#10;c 3.0      7&#10;d NaN   6&#10;&#10;# one，two是自定义列索引，a、b、c、d是自定义行索引&#10;&#10;In [15]: pd.DataFrame(dt, index=[&apos;b&apos;,&apos;c&apos;,&apos;d&apos;],columns=[&apos;two&apos;,&apos;three&apos;])&#10;Out[15]: &#10;   two three&#10;b  8      NaN&#10;c  7      NaN&#10;d  6      NaN&#10;&#10;# 数据根据行列索引自动补齐"/>
                  <outline text="从列表类型的字典创建">
                    <outline text="实例1" _note="&#10;In [17]: import pandas as pd&#10;&#10;&#10;In [18]: dl={&apos;one&apos;: [1,2,3,4], &apos;two&apos;:[9,8,7,6]}&#10;&#10;&#10;In [19]: d=pd.DataFrame(dl, index = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])&#10;&#10;&#10;In [20]: d&#10;Out[20]: &#10; one two&#10;a 1      9&#10;b 2     8&#10;c 3     7&#10;d 4    6"/>
                    <outline text="实例2" _note="&#10;import pandas as pd&#10;&#10;In [26]: dl={&apos;城市&apos;:[&apos;北京&apos;,&apos;上海&apos;,&apos;广州&apos;,&apos;深圳&apos;,&apos;沈阳&apos;],&#10; ...:                   &apos;环比&apos;:[101.5, 101.2, 101.3,102.0, 100.1],&#10; ...:                   &apos;同比&apos;:[120.7,127.3,119.4,140.9,101.4],&#10; ...:                   &apos;定基&apos;:[121.4,127.8,120.0,145.5, 101.6]}&#10;&#10;&#10;In [27]: d = pd.DataFrame(dl, index=[&apos;c1&apos;,&apos;c2&apos;,&apos;c3&apos;,&apos;c4&apos;,&apos;c5&apos;])&#10;&#10;&#10;In [28]: d&#10;Out[28]: &#10;     城市 环比 同比 定基&#10;c1 北京 101.5 120.7 121.4&#10;c2 上海 101.2 127.3 127.8&#10;c3 广州 101.3 119.4 120.0&#10;c4 深圳 102.0 140.9 145.5&#10;c5 沈阳 100.1 101.4 101.6&#10;&#10;&#10;In [29]: d.index&#10;Out[29]: Index([&apos;c1&apos;, &apos;c2&apos;, &apos;c3&apos;, &apos;c4&apos;, &apos;c5&apos;], dtype=&apos;object&apos;)&#10;&#10;&#10;In [30]: d.columns&#10;Out[30]: Index([&apos;城市&apos;, &apos;环比&apos;, &apos;同比&apos;, &apos;定基&apos;], dtype=&apos;object&apos;)&#10;&#10;&#10;In [31]: d.values&#10;Out[31]: &#10;array([[&apos;北京&apos;, 101.5, 120.7, 121.4],&#10;              [&apos;上海&apos;, 101.2, 127.3, 127.8],&#10;              [&apos;广州&apos;, 101.3, 119.4, 120.0],&#10;              [&apos;深圳&apos;, 102.0, 140.9, 145.5],&#10;              [&apos;沈阳&apos;, 100.1, 101.4, 101.6]], dtype=object)&#10;&#10;&#10;&#10;&#10;"/>
                    <outline text="实例3" _note="&#10;In [49]: import pandas as pd&#10;&#10;&#10;In [50]: dl={&apos;城市&apos;:[&apos;北京&apos;,&apos;上海&apos;,&apos;广州&apos;,&apos;深圳&apos;,&apos;沈阳&apos;],&#10;    ...:                &apos;环比&apos;:[101.5, 101.2, 101.3,102.0, 100.1],&#10;    ...:                &apos;同比&apos;:[120.7,127.3,119.4,140.9,101.4],&#10;    ...:                &apos;定基&apos;:[121.4,127.8,120.0,145.5, 101.6]}&#10;&#10;&#10;In [51]: d[&apos;同比&apos;]&#10;Out[51]: &#10;c1 120.7&#10;c2 127.3&#10;c3 119.4&#10;c4 140.9&#10;c5 101.4&#10;Name: 同比, dtype: float64&#10;&#10;&#10;In [52]: d.loc[&apos;c2&apos;]&#10;Out[52]: &#10;城市 上海&#10;环比 101.2&#10;同比 127.3&#10;定基 127.8&#10;Name: c2, dtype: object&#10;&#10;&#10;In [53]: d[&apos;同比&apos;][&apos;c2&apos;]&#10;Out[53]: 127.3"/>
                  </outline>
                </outline>
                <outline text="Series类型"/>
                <outline text="其他的DataFrame类型"/>
              </outline>
              <outline text="DataFrame是二维带“标签”数组" _note="&#10;DataFrame基本操作类似Series，依据行列索引&#10;&#10;                                          colum_0      colum_1       colum_i&#10;&#10;index_0      index_0 → data_a          data_1 ...      data_w"/>
            </outline>
            <outline text="Pandas库的数据类型操作" collapsed="true">
              <outline text="数据类型操作" _note="&#10;如何改变Series和DataFrame对象？&#10;&#10;增加或重排：重新索引&#10;&#10;删除：drop"/>
              <outline text="索引类型" _note="&#10;Series和DataFrame的索引是Index类型，Index对象是不可修改类型&#10;&#10;In [100]: d.index&#10;Out[100]: Index([&apos;c5&apos;, &apos;c4&apos;, &apos;c3&apos;, &apos;c2&apos;, &apos;c1&apos;], dtype=&apos;object&apos;)&#10;&#10;&#10;In [101]: d.columns&#10;Out[101]: Index([&apos;城市&apos;, &apos;同比&apos;, &apos;环比&apos;, &apos;定基&apos;], dtype=&apos;object&apos;)&#10;&#10;" collapsed="true">
                <outline text="索引类型的常用方法" collapsed="true">
                  <outline text=".append(idx)" _note="&#10;连接里一个Index对象，产生新的Index对象"/>
                  <outline text=".diff(idx)" _note="&#10;计算差集，产生新的Index对象"/>
                  <outline text=".intersection(idx)" _note="&#10;计算交集"/>
                  <outline text=".union(idx)" _note="&#10;计算并集"/>
                  <outline text=".delete(loc)" _note="&#10;删除loc位置处的元素"/>
                  <outline text=".insert(loc, e)" _note="&#10;在loc位置增加一个元素e"/>
                </outline>
                <outline text="索引类型的使用" _note="&#10;In [102]: d&#10;Out[102]: &#10;      城市 同比 环比 定基&#10;c5 沈阳 101.4 100.1 101.6&#10;c4 深圳 140.9 102.0 145.5&#10;c3 广州 119.4 101.3 120.0&#10;c2 上海 127.3 101.2 127.8&#10;c1 北京 120.7 101.5 121.4&#10;&#10;&#10;In [103]: nc= d.columns.delete(2)&#10;&#10;&#10;In [104]: ni = d.index.insert(5, &apos;c0&apos;)&#10;&#10;In [116]: nd = d.reindex(index=ni, columns=nc).ffill()    # 嵩天课件已不适用，已修正&#10;&#10;&#10;In [117]: nd&#10;Out[117]: &#10;      城市 同比 定基&#10;c5 沈阳 101.4 101.6&#10;c4 深圳 140.9 145.5&#10;c3 广州 119.4 120.0&#10;c2 上海 127.3 127.8&#10;c1 北京 120.7 121.4&#10;c0 北京 120.7 121.4"/>
              </outline>
              <outline text="重新索引  .reindex()" _note="&#10;.reindex()能够改变或重排Series和DataFrame索引&#10;&#10;&#10;In [54]: import pandas as pd&#10;&#10;&#10;In [55]: dl={&apos;城市&apos;:[&apos;北京&apos;,&apos;上海&apos;,&apos;广州&apos;,&apos;深圳&apos;,&apos;沈阳&apos;],&#10;    ...:               &apos;环比&apos;:[101.5, 101.2, 101.3,102.0, 100.1],&#10;    ...:               &apos;同比&apos;:[120.7,127.3,119.4,140.9,101.4],&#10;    ...:               &apos;定基&apos;:[121.4,127.8,120.0,145.5, 101.6]}&#10;&#10;&#10;In [56]: d = pd.DataFrame(dl, index=[&apos;c1&apos;,&apos;c2&apos;,&apos;c3&apos;,&apos;c4&apos;,&apos;c5&apos;])&#10;&#10;&#10;In [57]: d&#10;Out[57]: &#10;     城市 环比 同比 定基&#10;c1 北京 101.5 120.7 121.4&#10;c2 上海 101.2 127.3 127.8&#10;c3 广州 101.3 119.4 120.0&#10;c4 深圳 102.0 140.9 145.5&#10;c5 沈阳 100.1 101.4 101.6&#10;&#10;&#10;In [58]: d= d.reindex(index=[&apos;c5&apos;,&apos;c4&apos;,&apos;c3&apos;,&apos;c2&apos;,&apos;c1&apos;])&#10;&#10;&#10;In [59]: d&#10;Out[59]: &#10;      城市 环比 同比 定基&#10;c5 沈阳 100.1 101.4 101.6&#10;c4 深圳 102.0 140.9 145.5&#10;c3 广州 101.3 119.4 120.0&#10;c2 上海 101.2 127.3 127.8&#10;c1 北京 101.5 120.7 121.4&#10;&#10;In [66]: d= d.reindex(columns=[&apos;同比&apos;,&apos;城市&apos;,&apos;定基&apos;,&apos;环比&apos;])&#10;&#10;&#10;In [67]: d&#10;Out[67]: &#10;     同比 城市 定基 环比&#10;c1 120.7 北京 121.4 101.5&#10;c2 127.3 上海 127.8 101.2&#10;c3 119.4 广州 120.0 101.3&#10;c4 140.9 深圳 145.5 102.0&#10;c5 101.4 沈阳 101.6 100.1" collapsed="true">
                <outline text=".reindex(index=None, columns=None, ...)的参数">
                  <outline text="index, columns" _note="&#10;新的行列自定义索引"/>
                  <outline text="fill_values" _note="&#10;重新索引中，用于填充缺失位置的值"/>
                  <outline text="method" _note="&#10;填充方法，ffill当前值向前填充，bfill向后填充"/>
                  <outline text="limit" _note="&#10;最大填充量"/>
                  <outline text="copy" _note="&#10;默认True，生成新的对象，False时，新旧相等不复制"/>
                </outline>
                <outline text="实例" _note="&#10;&#10;In [69]: import pandas as pd&#10;&#10;&#10;In [70]: dl={&apos;城市&apos;:[&apos;北京&apos;,&apos;上海&apos;,&apos;广州&apos;,&apos;深圳&apos;,&apos;沈阳&apos;],&#10;    ...:               &apos;环比&apos;:[101.5, 101.2, 101.3,102.0, 100.1],&#10;    ...:               &apos;同比&apos;:[120.7,127.3,119.4,140.9,101.4],&#10;    ...:                &apos;定基&apos;:[121.4,127.8,120.0,145.5, 101.6]}&#10;&#10;&#10;In [71]: d= d.reindex(index=[&apos;c5&apos;,&apos;c4&apos;,&apos;c3&apos;,&apos;c2&apos;,&apos;c1&apos;])&#10;&#10;&#10;In [72]: d&#10;Out[72]: &#10;      同比 城市 定基 环比&#10;c5 101.4 沈阳 101.6 100.1&#10;c4 140.9 深圳 145.5 102.0&#10;c3 119.4 广州 120.0 101.3&#10;c2 127.3 上海 127.8 101.2&#10;c1 120.7 北京 121.4 101.5&#10;&#10;&#10;In [73]: d = d.reindex(columns=[&apos;城市&apos;,&apos;同比&apos;,&apos;环比&apos;,&apos;定基&apos;])&#10;&#10;&#10;In [74]: d&#10;Out[74]: &#10;      城市 同比 环比 定基&#10;c5 沈阳 101.4 100.1 101.6&#10;c4 深圳 140.9 102.0 145.5&#10;c3 广州 119.4 101.3 120.0&#10;c2 上海 127.3 101.2 127.8&#10;c1 北京 120.7 101.5 121.4&#10;&#10;&#10;In [76]: newc= d.columns.insert(4,&apos;新增&apos;)&#10;&#10;&#10;In [77]: newd=d.reindex(columns=newc, fill_value=200)&#10;&#10;&#10;In [78]: newd&#10;Out[78]: &#10;      城市 同比 环比 定基 新增&#10;c5 沈阳 101.4 100.1 101.6 200&#10;c4 深圳 140.9 102.0 145.5 200&#10;c3 广州 119.4 101.3 120.0 200&#10;c2 上海 127.3 101.2 127.8 200&#10;c1 北京 120.7 101.5 121.4 200"/>
              </outline>
              <outline text="删除指定索引对象" _note="&#10;.drop()能够删除Series和DataFrame指定行或列索引&#10;&#10;In [118]: a = pd.Series([9,8,7,6], index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])&#10;&#10;&#10;In [119]: a&#10;Out[119]: &#10;a 9&#10;b 8&#10;c 7&#10;d 6&#10;dtype: int64&#10;&#10;&#10;In [120]: a.drop([&apos;b&apos;,&apos;c&apos;])&#10;Out[120]: &#10;a 9&#10;d 6&#10;dtype: int64&#10;&#10;&#10;In [121]: d&#10;Out[121]: &#10;     城市 同比 环比 定基&#10;c5 沈阳 101.4 100.1 101.6&#10;c4 深圳 140.9 102.0 145.5&#10;c3 广州 119.4 101.3 120.0&#10;c2 上海 127.3 101.2 127.8&#10;c1 北京 120.7 101.5 121.4&#10;&#10;&#10;In [122]: d.drop(&apos;c5&apos;)&#10;Out[122]: &#10;      城市 同比 环比 定基&#10;c4 深圳 140.9 102.0 145.5&#10;c3 广州 119.4 101.3 120.0&#10;c2 上海 127.3 101.2 127.8&#10;c1 北京 120.7 101.5 121.4&#10;&#10;In [124]: d.drop(&apos;同比&apos;, axis=1)&#10;Out[124]: &#10;      城市 环比 定基&#10;c5 沈阳 100.1 101.6&#10;c4 深圳 102.0 145.5&#10;c3 广州 101.3 120.0&#10;c2 上海 101.2 127.8&#10;c1 北京 101.5 121.4"/>
            </outline>
            <outline text="Pandas库的数据类型运算" collapsed="true">
              <outline text="算术运算">
                <outline text="算术运算法则" _note="&#10;算数运算法则根据行列索引，补齐后运算，运算默认产生浮点数&#10;&#10;补齐时缺项填充NaN(空值)&#10;&#10;二维和一维、一维和零维间为广播运算&#10;&#10;采用 +  -  *  / 符号进行的二元运算产生新的对象"/>
                <outline text="数据类型的算术运算" _note="&#10;In [125]: import pandas as pd&#10;&#10;&#10;In [126]: import numpy as np&#10;&#10;&#10;In [127]: a = pd.DataFrame(np.arange(12).reshape(3,4))&#10;&#10;&#10;In [128]: a&#10;Out[128]: &#10;    0 1 2 3&#10;0 0 1 2 3&#10;1 4 5 6 7&#10;2 8 9 10 11&#10;&#10;&#10;In [129]: b = pd.DataFrame(np.arange(20).reshape(4,5))&#10;&#10;&#10;In [130]: b&#10;Out[130]: &#10;    0 1 2 3 4&#10;0 0 1 2 3 4&#10;1 5 6 7 8 9&#10;2 10 11 12 13 14&#10;3 15 16 17 18 19&#10;&#10;&#10;In [131]: a+b&#10;Out[131]: &#10;    0     1       2    3       4&#10;0 0.0 2.0 4.0 6.0 NaN&#10;1 9.0 11.0 13.0 15.0 NaN&#10;2 18.0 20.0 22.0 24.0 NaN&#10;3 NaN NaN NaN NaN NaN&#10;&#10;&#10;In [132]: a * b&#10;Out[132]: &#10;     0    1      2     3     4&#10;0 0.0 1.0 4.0 9.0 NaN&#10;1 20.0 30.0 42.0 56.0 NaN&#10;2 80.0 99.0 120.0 143.0 NaN&#10;3 NaN NaN NaN NaN NaN">
                  <outline text="方法形式的运算" collapsed="true">
                    <outline text=".add(d, **argws)" _note="&#10;类型间加法运算，可选参数"/>
                    <outline text=".sub(d, **argws)" _note="&#10;类型间减法运算，可选参数"/>
                    <outline text=".mul(d, **argws)" _note="&#10;类型间乘法运算，可选参数"/>
                    <outline text=".div(d, **argws)" _note="&#10;类型间除法运算，可选参数"/>
                  </outline>
                  <outline text="实例1" _note="&#10;fill_value参数替代NaN，替代后参与运算&#10;&#10;In [133]: import pandas as pd&#10;&#10;&#10;In [134]: import numpy as np&#10;&#10;&#10;In [135]: a = pd.DataFrame(np.arange(12).reshape(3,4))&#10;&#10;&#10;In [136]: a&#10;Out[136]: &#10;    0 1 2 3&#10;0 0 1 2 3&#10;1 4 5 6 7&#10;2 8 9 10 11&#10;&#10;&#10;In [137]: b = pd.DataFrame(np.arange(20).reshape(4,5))&#10;&#10;&#10;In [138]: b&#10;Out[138]: &#10;    0 1 2 3 4&#10;0 0 1 2 3 4&#10;1 5 6 7 8 9&#10;2 10 11 12 13 14&#10;3 15 16 17 18 19&#10;&#10;&#10;In [139]: b.add(a, fill_value = 100)&#10;Out[139]: &#10;     0     1      2     3       4&#10;0 0.0 2.0 4.0 6.0 104.0&#10;1 9.0 11.0 13.0 15.0 109.0&#10;2 18.0 20.0 22.0 24.0 114.0&#10;3 115.0 116.0 117.0 118.0 119.0&#10;&#10;In [141]: a.mul(b,fill_value=0)&#10;Out[141]: &#10;       0    1     2     3    4&#10;0 0.0 1.0 4.0 9.0 0.0&#10;1 20.0 30.0 42.0 56.0 0.0&#10;2 80.0 99.0 120.0 143.0 0.0&#10;3 0.0 0.0 0.0 0.0 0.0&#10;&#10;&#10;&#10;"/>
                  <outline text="实例2" _note="&#10;不同维度间为广播运算，一维Series默认在轴1参与运算（即和行进行运算）&#10;&#10;In [142]: import pandas as pd&#10;&#10;&#10;In [143]: import numpy as np&#10;&#10;&#10;In [144]: b = pd.DataFrame(np.arange(20).reshape(4,5))&#10;&#10;&#10;In [145]: b&#10;Out[145]: &#10;    0 1 2 3 4&#10;0 0 1 2 3 4&#10;1 5 6 7 8 9&#10;2 10 11 12 13 14&#10;3 15 16 17 18 19&#10;&#10;&#10;In [146]: c = pd.Series(np.arange(4))&#10;&#10;&#10;In [147]: c&#10;Out[147]: &#10;0 0&#10;1 1&#10;2 2&#10;3 3&#10;dtype: int32&#10;&#10;&#10;In [148]: c - 10&#10;Out[148]: &#10;0 -10&#10;1 -9&#10;2 -8&#10;3 -7&#10;dtype: int32&#10;&#10;&#10;In [149]: b - c&#10;Out[149]: &#10;     0     1      2     3      4&#10;0 0.0 0.0 0.0 0.0 NaN&#10;1 5.0 5.0 5.0 5.0 NaN&#10;2 10.0 10.0 10.0 10.0 NaN&#10;3 15.0 15.0 15.0 15.0 NaN"/>
                  <outline text="实例3" _note="&#10;使用运算方法可以令一维Series参与轴0运算（即和列运算）&#10;&#10;In [151]: import pandas as pd&#10;&#10;In [152]: import numpy as np&#10;&#10;In [153]: b = pd.DataFrame(np.arange(20).reshape(4,5))&#10;&#10;In [154]: b&#10;Out[154]: &#10;      0   1   2   3   4&#10;0   0   1   2   3   4&#10;1   5   6   7   8   9&#10;2  10  11  12  13  14&#10;3  15  16  17  18  19&#10;&#10;In [155]: c = pd.Series(np.arange(4))&#10;&#10;In [156]: c&#10;Out[156]: &#10;0    0&#10;1    1&#10;2    2&#10;3    3&#10;dtype: int32&#10;&#10;In [157]: b.sub(c,axis=0)&#10;Out[157]: &#10;      0   1   2   3   4&#10;0   0   1   2   3   4&#10;1   4   5   6   7   8&#10;2   8   9  10  11  12&#10;3  12  13  14  15  16"/>
                </outline>
              </outline>
              <outline text="比较运算">
                <outline text="比较运算法则" _note="&#10;比较运算只能比较相应索引的元素，不进行补齐&#10;&#10;二维和一维，一维和零维间为广播运算&#10;&#10;采用 &gt;  &lt;   &gt;=   &lt;=  ==  != 等符号进行的二元运算产生布尔对象"/>
                <outline text="数据类型的比较运算">
                  <outline text="实例1" _note="&#10;同维度运算，尺寸一致&#10;&#10;In [159]: import pandas as pd&#10;&#10;&#10;In [160]: import numpy as np&#10;&#10;&#10;In [161]: a= pd.DataFrame(np.arange(12).reshape(3,4))&#10;&#10;&#10;In [162]: a&#10;Out[162]: &#10;   0 1 2 3&#10;0 0 1 2 3&#10;1 4 5 6 7&#10;2 8 9 10 11&#10;&#10;&#10;In [163]: d = pd.DataFrame(np.arange(12,0,-1).reshape(3,4))&#10;&#10;&#10;In [164]: d&#10;Out[164]: &#10;    0   1  2   3&#10;0 12 11 10 9&#10;1 8 7 6 5&#10;2 4 3 2 1&#10;&#10;&#10;In [165]: a &gt; d&#10;Out[165]: &#10;    0          1          2         3&#10;0 False False False False&#10;1 False False False True&#10;2 True True True True&#10;&#10;&#10;In [166]: a == d&#10;Out[166]: &#10;      0         1         2        3&#10;0 False False False False&#10;1 False False True False&#10;2 False False False False"/>
                  <outline text="实例2" _note="&#10;不同维度，广播运算，默认在1轴（即和每一行运算）&#10;&#10;In [167]: import pandas as pd&#10;&#10;&#10;In [168]: import numpy as np&#10;&#10;&#10;In [169]: a= pd.DataFrame(np.arange(12).reshape(3,4))&#10;&#10;&#10;In [170]: a&#10;Out[170]: &#10;    0 1 2 3&#10;0 0 1 2 3&#10;1 4 5 6 7&#10;2 8 9 10 11&#10;&#10;&#10;In [171]: c = pd.Series(np.arange(4))&#10;&#10;&#10;In [172]: c&#10;Out[172]: &#10;0 0&#10;1 1&#10;2 2&#10;3 3&#10;dtype: int32&#10;&#10;&#10;In [173]: a &gt; c&#10;Out[173]: &#10;       0        1           2     3&#10;0 False False False False&#10;1 True True True True&#10;2 True True True True&#10;&#10;&#10;In [174]: c &gt; 0&#10;Out[174]: &#10;0 False&#10;1 True&#10;2 True&#10;3 True&#10;dtype: bool&#10;"/>
                  <outline text="实例3"/>
                </outline>
              </outline>
            </outline>
          </outline>
          <outline text="单元8：Pandas数据特征分析" collapsed="true">
            <outline text="数据的排序">
              <outline text="对一组数据的理解" _note="&#10;一组数据表达一个或多个含义 → 通过摘要，数据形成有损特征的过程→基本统计（含排序），分布/累计统计，数据特征（相关性、周期性等），数据挖掘（形成知识）"/>
              <outline text="Pandas库的数据排序" _note="&#10;" collapsed="true">
                <outline text=".sort_index(axis=0, ascending=True)" _note="&#10;.sort_index()方法在指定轴上根据索引进行排序，默认升序">
                  <outline text="实例1" _note="&#10;In [176]: import pandas as pd&#10;&#10;&#10;In [177]: import numpy as np&#10;&#10;&#10;In [178]: b = pd.DataFrame(np.arange(20).reshape(4,5), index=[&apos;c&apos;,&apos;a&apos;,&apos;d&apos;,&apos;b&apos;])&#10;&#10;&#10;In [179]: b&#10;Out[179]: &#10; 0 1 2 3 4&#10;c 0 1 2 3 4&#10;a 5 6 7 8 9&#10;d 10 11 12 13 14&#10;b 15 16 17 18 19&#10;&#10;&#10;In [180]: b.sort_index()   #  按照abcd升序&#10;Out[180]: &#10;    0 1 2 3 4&#10;a 5 6 7 8 9&#10;b 15 16 17 18 19&#10;c 0 1 2 3 4&#10;d 10 11 12 13 14&#10;&#10;&#10;In [181]: b.sort_index(ascending=False)  # 使用ascending=False，按照dcba降序&#10;Out[181]: &#10;    0   1    2   3 4&#10;d 10 11 12 13 14&#10;c 0 1 2 3 4&#10;b 15 16 17 18 19&#10;a 5 6 7 8 9&#10;&#10;"/>
                  <outline text="实例2" _note="&#10;&#10;In [183]: import pandas as pd&#10;&#10;&#10;In [184]: import numpy as np&#10;&#10;&#10;In [185]: b = pd.DataFrame(np.arange(20).reshape(4,5), index=[&apos;c&apos;,&apos;a&apos;,&apos;d&apos;,&apos;b&apos;])&#10;&#10;&#10;In [186]: b&#10;Out[186]: &#10;    0 1 2 3 4&#10;c 0 1 2 3 4&#10;a 5 6 7 8 9&#10;d 10 11 12 13 14&#10;b 15 16 17 18 19&#10;&#10;&#10;In [187]: c = b.sort_index(axis=1, ascending=False) # 按照列索引排序&#10;&#10;&#10;In [188]: c&#10;Out[188]: &#10;   4 3 2 1 0&#10;c 4 3 2 1 0&#10;a 9 8 7 6 5&#10;d 14 13 12 11 10&#10;b 19 18 17 16 15&#10;&#10;&#10;In [189]: c = c.sort_index()   # 按照行索引排序&#10;&#10;&#10;In [190]: c&#10;Out[190]: &#10;   4 3 2 1 0&#10;a 9 8 7 6 5&#10;b 19 18 17 16 15&#10;c 4 3 2 1 0&#10;d 14 13 12 11 10"/>
                </outline>
                <outline text="sort_values()" _note="&#10;sort_values()方法在指定轴上根据数据进行排序，默认升序&#10;&#10;Series.sort_values(axis=0, ascending=True)&#10;&#10;DataFrame.sort_values(by, axis=0, ascending=True)&#10;&#10;by：axis轴上的某个索引或索引列表">
                  <outline text=".sort_values(axis=0, ascending=True)" _note="&#10;&#10;In [192]: import pandas as pd&#10;&#10;In [193]: import numpy as np&#10;&#10;In [194]: b = pd.DataFrame(np.arange(20).reshape(4,5), index=[&apos;c&apos;,&apos;a&apos;,&apos;d&apos;,&apos;b&apos;])&#10;&#10;In [195]: b&#10;Out[195]: &#10;     0   1   2   3   4&#10;c   0   1   2   3   4&#10;a   5   6   7   8   9&#10;d  10  11  12  13  14&#10;b  15  16  17  18  19&#10;&#10; # 根据axis0上的索引2开展行排序&#10;&#10;In [196]: c = b.sort_values(2, ascending=False) &#10;&#10;In [197]: c&#10;Out[197]: &#10;     0   1    2     3    4&#10;b  15  16  17  18  19&#10;d  10  11  12  13  14&#10;a   5   6   7   8   9&#10;c   0   1   2   3   4&#10;&#10;# 根据axis1上的索引‘a’开展列排序&#10;&#10;In [198]: c = c.sort_values(&apos;a&apos;, axis=1, ascending=False)  &#10;&#10;In [199]: c&#10;Out[199]: &#10;      4   3   2   1   0&#10;b  19  18  17  16  15&#10;d  14  13  12  11  10&#10;a   9   8   7   6   5&#10;c   4   3   2   1   0">
                    <outline text="实例" _note="&#10;无论升序降序，NaN统一放到排序末尾&#10;&#10;In [201]: import pandas as pd&#10;&#10;In [202]: import numpy as np&#10;&#10;In [203]: a = pd.DataFrame(np.arange(12).reshape(3,4), index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;])&#10;&#10;In [204]: a&#10;Out[204]: &#10;    0  1   2   3&#10;a  0  1   2   3&#10;b  4  5   6   7&#10;c  8  9  10  11&#10;&#10;In [205]: b = pd.DataFrame(np.arange(20).reshape(4,5), index=[&apos;c&apos;,&apos;a&apos;,&apos;d&apos;,&apos;b&apos;])&#10;&#10;In [206]: b&#10;Out[206]: &#10;     0   1   2   3   4&#10;c   0   1   2   3   4&#10;a   5   6   7   8   9&#10;d  10  11  12  13  14&#10;b  15  16  17  18  19&#10;&#10;In [207]: c = a+b&#10;&#10;In [208]: c&#10;Out[208]: &#10;      0     1          2       3     4&#10;a   5.0   7.0   9.0  11.0 NaN&#10;b  19.0  21.0  23.0  25.0 NaN&#10;c   8.0  10.0  12.0  14.0 NaN&#10;d   NaN   NaN   NaN   NaN NaN&#10;&#10;In [209]: c.sort_values(2, ascending= False)&#10;Out[209]: &#10;      0     1            2        3       4 &#10;b  19.0  21.0  23.0  25.0 NaN&#10;c   8.0  10.0  12.0  14.0 NaN&#10;a   5.0   7.0   9.0  11.0 NaN&#10;d   NaN   NaN   NaN   NaN NaN&#10;&#10;In [210]: c.sort_values(2, ascending= True)&#10;Out[210]: &#10;      0     1          2       3     4&#10;a   5.0   7.0   9.0  11.0 NaN&#10;c   8.0  10.0  12.0  14.0 NaN&#10;b  19.0  21.0  23.0  25.0 NaN&#10;d   NaN   NaN   NaN   NaN NaN"/>
                  </outline>
                </outline>
              </outline>
            </outline>
            <outline text="数据的基本统计分析" collapsed="true">
              <outline text="基本的统计分析函数">
                <outline text="适用于Series 和DataFrame类型" collapsed="true">
                  <outline text=".sum" _note="&#10;计算数据的总和，按0轴计算，下同&#10;"/>
                  <outline text=".count()" _note="计算非NaN值的数量&#10;"/>
                  <outline text=".mean()   .median()" _note="&#10;计算数值的算术平均值，算术中位数"/>
                  <outline text=".var()        .std()" _note="&#10;计算数据的方差、标准差"/>
                  <outline text=".min()        .max()" _note="&#10;计算数据的最小值、最大值"/>
                  <outline text=".describe()" _note="&#10;针对0轴（各列）统计汇总"/>
                </outline>
                <outline text="适用于Series类型" collapsed="true">
                  <outline text=".argmin     .argmax()" _note="&#10;计算数据最大值、最小值所在位置的索引位置（自动索引）"/>
                  <outline text=".idxmin      .idxmax()" _note="&#10;计算数据最大值、最小值所在位置的索引（自动索引）"/>
                </outline>
              </outline>
              <outline text="实例1" _note="&#10;In [212]: import pandas as pd&#10;&#10;&#10;In [213]: a = pd.Series([9,8,7,6], index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])&#10;&#10;&#10;In [214]: a&#10;Out[214]: &#10;a 9&#10;b 8&#10;c 7&#10;d 6&#10;dtype: int64&#10;&#10;&#10;In [215]: a.describe()&#10;Out[215]: &#10;count 4.000000&#10;mean 7.500000&#10;std 1.290994&#10;min 6.000000&#10;25% 6.750000&#10;50% 7.500000&#10;75% 8.250000&#10;max 9.000000&#10;dtype: float64&#10;&#10;&#10;In [216]: type(a.describe())&#10;Out[216]: pandas.core.series.Series&#10;&#10;&#10;In [217]: a.describe()[&apos;count&apos;]&#10;Out[217]: 4.0&#10;&#10;&#10;In [218]: a.describe()[&apos;max&apos;]&#10;Out[218]: 9.0&#10;&#10;&#10;In [219]: a.describe()[&apos;min&apos;]&#10;Out[219]: 6.0"/>
              <outline text="实例2" _note="&#10;In [221]: import pandas as pd&#10;&#10;&#10;In [222]: import numpy as np&#10;&#10;&#10;In [223]: b = pd.DataFrame(np.arange(20).reshape(4,5), index=[&apos;c&apos;,&apos;a&apos;,&apos;d&apos;,&apos;b&apos;])&#10;&#10;&#10;In [224]: b&#10;Out[224]: &#10;   0 1 2 3 4&#10;c 0 1 2 3 4&#10;a 5 6 7 8 9&#10;d 10 11 12 13 14&#10;b 15 16 17 18 19&#10;&#10;&#10;In [225]: b.describe()&#10;Out[225]: &#10; 0 1 2 3 4&#10;count 4.000000 4.000000 4.000000 4.000000 4.000000&#10;mean 7.500000 8.500000 9.500000 10.500000 11.500000&#10;std 6.454972 6.454972 6.454972 6.454972 6.454972&#10;min 0.000000 1.000000 2.000000 3.000000 4.000000&#10;25% 3.750000 4.750000 5.750000 6.750000 7.750000&#10;50% 7.500000 8.500000 9.500000 10.500000 11.500000&#10;75% 11.250000 12.250000 13.250000 14.250000 15.250000&#10;max 15.000000 16.000000 17.000000 18.000000 19.000000&#10;&#10;&#10;In [226]: type(b.describe())&#10;Out[226]: pandas.core.frame.DataFrame&#10;&#10;In [230]: b.describe().loc[&apos;max&apos;]&#10;Out[230]: &#10;0 15.0&#10;1 16.0&#10;2 17.0&#10;3 18.0&#10;4 19.0&#10;Name: max, dtype: float64&#10;&#10;&#10;In [231]: b.describe()[2]&#10;Out[231]: &#10;count 4.000000&#10;mean 9.500000&#10;std 6.454972&#10;min 2.000000&#10;25% 5.750000&#10;50% 9.500000&#10;75% 13.250000&#10;max 17.000000&#10;Name: 2, dtype: float64"/>
            </outline>
            <outline text="数据的累计统计分析" _note="&#10;介绍累计统计分析函数" collapsed="true">
              <outline text="适用于Series和DataFrame类型，累计计算" _note="&#10;In [1]: import pandas as pd&#10;&#10;&#10;In [2]: import numpy as np&#10;&#10;&#10;In [3]: b = pd.DataFrame(np.arange(20).reshape(4,5),index=[&apos;c&apos;,&apos;a&apos;,&apos;d&apos;,&apos;b&apos;])&#10;&#10;&#10;In [4]: b&#10;Out[4]: &#10; 0 1 2 3 4&#10;c 0 1 2 3 4&#10;a 5 6 7 8 9&#10;d 10 11 12 13 14&#10;b 15 16 17 18 19&#10;&#10;In [10]: b.cumsum() # 计算每列的累计和&#10;Out[10]: &#10;   0 1 2 3 4&#10;c 0 1 2 3 4&#10;a 5 7 9 11 13&#10;d 15 18 21 24 27&#10;b 30 34 38 42 46&#10;&#10;&#10;In [11]: b.cumprod()  # 计算每列的累计积&#10;Out[11]: &#10;   0 1 2 3 4&#10;c 0 1 2 3 4&#10;a 0 6 14 24 36&#10;d 0 66 168 312 504&#10;b 0 1056 2856 5616 9576&#10;&#10;&#10;In [12]: b.cumsum(axis=1) # 计算每行的累计和&#10;Out[12]: &#10;   0 1 2 3 4&#10;c 0 1 3 6 10&#10;a 5 11 18 26 35&#10;d 10 21 33 46 60&#10;b 15 31 48 66 85&#10;&#10;&#10;In [13]: b.cumprod(axis=1)  # 计算每行的累计积&#10;Out[13]: &#10;    0 1 2 3 4&#10;c 0 0 0 0 0&#10;a 5 30 210 1680 15120&#10;d 10 110 1320 17160 240240&#10;b 15 240 4080 73440 1395360&#10;&#10;&#10;In [14]: b.cummin()  # 计算每列累计最小值&#10;Out[14]: &#10;   0 1 2 3 4&#10;c 0 1 2 3 4&#10;a 0 1 2 3 4&#10;d 0 1 2 3 4&#10;b 0 1 2 3 4&#10;&#10;&#10;In [15]: b.cummax()  #计算每列的累计最大值&#10;Out[15]: &#10;   0 1 2 3 4&#10;c 0 1 2 3 4&#10;a 5 6 7 8 9&#10;d 10 11 12 13 14&#10;b 15 16 17 18 19&#10;&#10;&#10;In [16]: b.cummin(axis=1) # 计算每行的累计最小值&#10;Out[16]: &#10;       0   1   2   3   4&#10;c   0   0   0   0   0&#10;a   5   5   5   5   5&#10;d  10  10  10  10  10&#10;b  15  15  15  15  15&#10;&#10;In [17]: b.cummax(axis=1)   # 计算每行的累计最大值&#10;Out[17]:  &#10;      0   1   2   3   4&#10;c   0   1   2   3   4&#10;a   5   6   7   8   9&#10;d  10  11  12  13  14&#10;b  15  16  17  18  19" collapsed="true">
                <outline text=".cumsum()" _note="&#10;以此给出前1、2、....、n个数的和"/>
                <outline text=".cumprod()" _note="&#10;依次给出前1、2、...、n个数的积"/>
                <outline text=".cummax()" _note="&#10;依次给出前1、2、...、n个数的最大值"/>
                <outline text=".cummin()" _note="&#10;依次给出1、2、...、n个数的最小值"/>
              </outline>
              <outline text="适用于Series和DataFrame类型，滚动计算（窗口计算）" _note="&#10;In [24]: import pandas as pd&#10;&#10;&#10;In [25]: import numpy as np&#10;&#10;&#10;In [26]: b = pd.DataFrame(np.arange(20).reshape(4,5), index=[&apos;c&apos;,&apos;a&apos;,&apos;d&apos;,&apos;b&apos;])&#10;&#10;&#10;In [27]: b&#10;Out[27]: &#10;    0 1 2 3 4&#10;c 0 1 2 3 4&#10;a 5 6 7 8 9&#10;d 10 11 12 13 14&#10;b 15 16 17 18 19&#10;&#10;&#10;In [28]: b.rolling(2).sum()  # 向上每列滚动计算，计算和上面1列的累计值&#10;Out[28]: &#10;     0          1      2      3        4&#10;c NaN NaN NaN NaN NaN&#10;a 5.0 7.0 9.0 11.0 13.0&#10;d 15.0 17.0 19.0 21.0 23.0&#10;b 25.0 27.0 29.0 31.0 33.0&#10;&#10;&#10;In [29]: b.rolling(3).sum()  #  向上每列滚动计算，计算和上面2列的累计值&#10;Out[29]: &#10;      0        1       2       3        4&#10;c NaN NaN NaN NaN NaN&#10;a NaN NaN NaN NaN NaN&#10;d 15.0 18.0 21.0 24.0 27.0&#10;b 30.0 33.0 36.0 39.0 42.0&#10;&#10;&#10;In [32]: b.rolling(2,axis=1).sum()&#10;Out[32]: &#10;      0       1     2    3    4&#10;c NaN 1.0 3.0 5.0 7.0&#10;a NaN 11.0 13.0 15.0 17.0&#10;d NaN 21.0 23.0 25.0 27.0&#10;b NaN 31.0 33.0 35.0 37.0&#10;&#10;b.rolling(2).mean()&#10;Out[35]: &#10;      0          1          2         3            4&#10;c   NaN   NaN   NaN   NaN   NaN&#10;a   2.5   3.5   4.5   5.5   6.5&#10;d   7.5   8.5   9.5  10.5  11.5&#10;b  12.5  13.5  14.5  15.5  16.5&#10;&#10;b.rolling(2).var()&#10;Out[36]: &#10;      0     1     2     3     4&#10;c   NaN   NaN   NaN   NaN   NaN&#10;a  12.5  12.5  12.5  12.5  12.5&#10;d  12.5  12.5  12.5  12.5  12.5&#10;b  12.5  12.5  12.5  12.5  12.5&#10;&#10;b.rolling(2,axis=1).std()&#10;Out[37]: &#10;       0               1             2                  3                  4&#10;c NaN  0.707107  0.707107  0.707107  0.707107&#10;a NaN  0.707107  0.707107  0.707107  0.707107&#10;d NaN  0.707107  0.707107  0.707107  0.707107&#10;b NaN  0.707107  0.707107  0.707107  0.707107&#10;&#10;b.rolling(2,axis=1).min()&#10;Out[38]: &#10;    0           1       2       3     4&#10;c NaN   0.0   1.0   2.0   3.0&#10;a NaN   5.0   6.0   7.0   8.0&#10;d NaN  10.0  11.0  12.0  13.0&#10;b NaN  15.0  16.0  17.0  18.0&#10;&#10;In [40]: b.rolling(2,axis=1).max()&#10;Out[40]: &#10;     0       1      2    3     4&#10;c NaN 1.0 2.0 3.0 4.0&#10;a NaN 6.0 7.0 8.0 9.0&#10;d NaN 11.0 12.0 13.0 14.0&#10;b NaN 16.0 17.0 18.0 19.0" collapsed="true">
                <outline text=".rolling(w).sum()" _note="&#10;依次计算相邻w个元素的和"/>
                <outline text=".rolling(w).mean()" _note="&#10;依次计算相邻w个元素的算术平均值"/>
                <outline text=".rolling(w).var()" _note="&#10;依次计算相邻w个元素的方差"/>
                <outline text=".rolling(w).std()" _note="&#10;依次计算相邻w个元素的标准差"/>
                <outline text=".rolling(w).min()             .rolling(w).max()" _note="&#10;依次计算相邻w个元素的最小值和最大值"/>
              </outline>
            </outline>
            <outline text="数据的相关分析" collapsed="true">
              <outline text="相关分析" _note="&#10;两个事物，表示为X和Y，如何判断它们之间的存在相关性？&#10;&#10;相关性&#10;&#10; ● X增大，Y增大，两个变量正相关&#10;&#10; ● X增大，Y减小，两个变量负相关&#10;&#10; ● X增大，Y无视，两个变量不相关"/>
              <outline text="协方差" _note="&#10;两个事物，表示为X和Y，如何它们之间的存在相关性？&#10;&#10;协方差 cov&#10;&#10; ● 协方差&gt;0，X和Y正相关&#10;&#10;● 协方差&lt;0，X和Y负相关&#10;&#10;● 协方差=0，X和Y独立无关&#10;"/>
              <outline text="Pearson相关系数" _note="&#10;两个事物，表示为X和Y，如何判断它们之间的存在相关性？&#10;&#10;Pearson相关系数r取值范围[-1, 1]&#10;&#10;●  0.8 - 1.0，极强相关&#10;&#10;● 0.6 - 0.8，强相关&#10;&#10;● 0.4 - 0.6，中等程度相关&#10;&#10;● 0.2 - 0.4，弱相关&#10;&#10;● 0.0 - 0.2，极弱相关或无相关"/>
              <outline text="相关分析函数" _note="&#10;适用于Series和DataFrame类型">
                <outline text=".cov()" _note="&#10;计算协方差矩阵"/>
                <outline text=".corr()" _note="&#10;计算相关系数矩阵，Pearson、Spearman、Kendall等系数"/>
              </outline>
              <outline text="实例：房价增幅与M2增幅的相关性" _note="&#10;&#10;In [42]: import pandas as pd&#10;&#10;In [43]: hprice =  pd.Series([3.04, 22.93, 12.75, 22.6, 12.33], index=[&apos;2008&apos;,&apos;2009&apos;,&apos;2010&apos;,&apos;2011&apos;,&apos;2012&apos;])&#10;&#10;In [44]: m2 =  pd.Series([8.18, 18.38, 9.13, 7.82, 6.69],index=[&apos;2008&apos;,&apos;2009&apos;,&apos;2010&apos;,&apos;2011&apos;,&apos;2012&apos;])&#10;&#10;In [45]: hprice.corr(m2)&#10;Out[45]: 0.5239439145220387&#10;"/>
            </outline>
          </outline>
          <outline text="房价趋势的关联因素分析 #实例 （暂缺）" _note="&#10;第3次开课（开课时间： 2018年10月30日 ~ 2018年12月04日）有，目前无法查到"/>
          <outline text="补充" collapsed="true">
            <outline text="DataFrame的数据选取" _note="&#10;import pandas&#10;&#10;In [58]: dict = {&#10;    ...: &apos;name&apos;:[&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;,&apos;赵六&apos;],&#10;    ...: &apos;sex&apos;:[&apos;男&apos;,&apos;男&apos;,&apos;男&apos;,&apos;女&apos;],&#10;    ...: &apos;age&apos;:[18,19,20,21]&#10;    ...: }&#10;&#10;&#10;In [59]: df = pd.DataFrame(dict)&#10;&#10;&#10;In [60]: df&#10;Out[60]: &#10;   name sex age&#10;0 张三 男 18&#10;1 李四 男 19&#10;2 王五 男 20&#10;3 赵六 女 21&#10;&#10;&#10;In [77]: df[&apos;contry&apos;]=&apos;China&apos;  # 添加数据&#10;&#10;&#10;In [78]: df&#10;Out[78]: &#10;   name sex age contry&#10;0 张三 男 18 China&#10;1 李四 男 19 China&#10;2 王五 男 20 China&#10;3 赵六 女 21 China&#10;&#10;&#10;In [84]: df[df.age&gt;20]  # 选取年龄大于20 的数组&#10;Out[84]: &#10;    name sex age contry&#10;3 赵六 女 21 China&#10;&#10;&#10;In [85]: df[df.sex==&apos;男&apos;]  # 选取姓名为男的数组&#10;Out[85]: &#10;    name sex age contry&#10;0 张三 男 18 China&#10;1 李四 男 19 China&#10;2 王五 男 20 China&#10;&#10;&#10;In [87]: df.sex ==&apos;男&apos;   # 比较sex是否为男性&#10;Out[87]: &#10;0 True&#10;1 True&#10;2 True&#10;3 False&#10;Name: sex, dtype: bool&#10;&#10;# 比较sex为男，而且age小于20&#10;In [88]: (df.sex ==&apos;男&apos;) &amp; (df.age &lt; 20)  &#10;Out[88]: &#10;0 True&#10;1 True&#10;2 False&#10;3 False&#10;dtype: bool&#10;&#10;# 选取sex为男，而且age小于20的数据，而且用 &amp; 表示 &#10;In [89]: df[(df.sex == &apos;男&apos;) &amp; (df.age &lt; 20)]&#10;Out[89]: &#10; name sex age contry&#10;0 张三 男 18 China&#10;1 李四 男 19 China&#10;&#10;# 选取sex为女性或者age小于20的数据，或者用 | 表示&#10;df[(df.sex ==&apos;女&apos;)|(df.age ==18)]&#10;Out[90]: &#10;  name sex  age contry&#10;0   张三   男   18  China&#10;3   赵六   女   21  China&#10;"/>
            <outline text="query使用" _note="&#10;&#10;import pandas&#10;&#10;In [58]: dict = {&#10; ...: &apos;name&apos;:[&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;,&apos;赵六&apos;],&#10; ...: &apos;sex&apos;:[&apos;男&apos;,&apos;男&apos;,&apos;男&apos;,&apos;女&apos;],&#10; ...: &apos;age&apos;:[18,19,20,21]&#10; ...: }&#10;&#10;&#10;In [59]: df = pd.DataFrame(dict)&#10;&#10;&#10;In [60]: df&#10;Out[60]: &#10; name sex age&#10;0 张三 男 18&#10;1 李四 男 19&#10;2 王五 男 20&#10;3 赵六 女 21&#10;&#10;&#10;In [77]: df[&apos;contry&apos;]=&apos;China&apos; # 添加数据&#10;&#10;&#10;In [78]: df&#10;Out[78]: &#10;  name sex age contry&#10;0 张三 男 18 China&#10;1 李四 男 19 China&#10;2 王五 男 20 China&#10;3 赵六 女 21 China&#10;&#10;&#10;格式df.query(&apos; &apos;)&#10;In [95]: df.query(&apos;age == 18 and sex == &quot;男&quot;&apos;)  &#10;Out[95]: &#10; name sex age contry&#10;0 张三 男 18 China&#10;&#10;&#10;In [96]: df.query(&apos;age &gt;18 and sex ==&quot;女&quot;&apos;)&#10;Out[96]: &#10; name sex age contry&#10;3 赵六 女 21 China&#10;&#10;&#10;In [99]: df.age +=1&#10;&#10;&#10;In [100]: df.age&#10;Out[100]: &#10;0 19&#10;1 20&#10;2 21&#10;3 22&#10;Name: age, dtype: int64"/>
            <outline text="DatFrame的运算" _note="&#10;import pandas&#10;&#10;In [58]: dict = {&#10; ...: &apos;name&apos;:[&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;,&apos;赵六&apos;],&#10; ...: &apos;sex&apos;:[&apos;男&apos;,&apos;男&apos;,&apos;男&apos;,&apos;女&apos;],&#10; ...: &apos;age&apos;:[18,19,20,21]&#10; ...: }&#10;&#10;&#10;In [59]: df = pd.DataFrame(dict)&#10;&#10;&#10;In [60]: df&#10;Out[60]: &#10; name sex age&#10;0 张三 男 18&#10;1 李四 男 19&#10;2 王五 男 20&#10;3 赵六 女 21&#10;&#10;&#10;In [77]: df[&apos;contry&apos;]=&apos;China&apos; # 添加数据&#10;&#10;&#10;In [78]: df&#10;Out[78]: &#10; name sex age contry&#10;0 张三 男 18 China&#10;1 李四 男 19 China&#10;2 王五 男 20 China&#10;3 赵六 女 21 China&#10;&#10;&#10;In [99]: df.age +=1&#10;&#10;&#10;In [100]: df.age&#10;Out[100]: &#10;0 19&#10;1 20&#10;2 21&#10;3 22&#10;Name: age, dtype: int64&#10;&#10;"/>
            <outline text="DataFrame和DataFrame的运算" _note="&#10;In [103]: df1= pd.DataFrame(np.arange(4).reshape(2,2), columns = [&apos;a&apos;,&apos;b&apos;])&#10;&#10;&#10;In [104]: df2= pd.DataFrame(np.arange(6).reshape(2,3), columns = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;])&#10;&#10;&#10;In [105]: df1&#10;Out[105]: &#10;    a b&#10;0 0 1&#10;1 2 3&#10;&#10;&#10;In [106]: df2&#10;Out[106]: &#10;    a b c&#10;0 0 1 2&#10;1 3 4 5&#10;&#10;&#10;In [107]: df1+df2&#10;Out[107]: &#10;     a b c&#10;0 0 2 NaN&#10;1 5 7 NaN&#10;&#10;# df1中有NaN的地方，自动填充df2的值&#10;In [108]: df1.add(df2, fill_value=0)&#10;Out[108]: &#10;    a   b  c&#10;0 0 2 2.0&#10;1 5 7 5.0&#10;&#10;# df1中有NaN的地方，自动填充（df2的值+1）&#10;In [109]: df1.add(df2, fill_value=1)&#10;Out[109]: &#10; a b c&#10;0 0 2 3.0&#10;1 5 7 6.0"/>
            <outline text="iloc和loc的区别" _note="&#10;In [117]: df&#10;Out[117]: &#10; name sex age contry&#10;0 张三 男 19 China&#10;1 李四 男 20 China&#10;2 王五 男 21 China&#10;3 赵六 女 22 China&#10;&#10;&#10;In [118]: df.iloc[1]&#10;Out[118]: &#10;name 李四&#10;sex 男&#10;age 20&#10;contry China&#10;Name: 1, dtype: object&#10;&#10;&#10;In [119]: df.index = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]&#10;&#10;&#10;In [120]: df&#10;Out[120]: &#10;   name sex age contry&#10;a 张三 男 19 China&#10;b 李四 男 20 China&#10;c 王五 男 21 China&#10;d 赵六 女 22 China&#10;&#10;&#10;In [121]: df.loc[&apos;a&apos;]&#10;Out[121]: &#10;name 张三&#10;sex 男&#10;age 19&#10;contry China&#10;Name: a, dtype: object&#10;&#10;&#10;In [127]: df.loc[&quot;a&quot;:&quot;c&quot;]&#10;Out[127]: &#10;   name sex age contry&#10;a 张三 男 19 China&#10;b 李四 男 20 China&#10;c 王五 男 21 China&#10;&#10;&#10;In [128]: df.iloc[:2]&#10;Out[128]: &#10;   name sex age contry&#10;a 张三 男 19 China&#10;b 李四 男 20 China&#10;&#10;iloc和loc通过索引选取行，iloc是通过所在行的数字为索引，loc是所在行的标签为索引，简单讲，iloc是第几行，loc是标签。当索引没有标签时，loc和iloc等价。两者支持冒号的范围选择。"/>
            <outline text="数据分析步骤 #实例" _note="&#10;实例参照[用pandas进行数据分析实战 - 知乎](https://zhuanlan.zhihu.com/p/27784143)">
              <outline text="读取数据 " _note="&#10;df = pd.read_csv(&apos;DataAnalyst.csv&apos;, encoding = &apos;gb2312&apos;)&#10;&#10;DataAnalyst.csv 是文件名称&#10;&#10;gb2312 不管用的话，可以用utf-8&#10;&#10;读取数据方法&#10;&#10;read_csv&#10;&#10;read_excel&#10;&#10;read_table  可以读取txt&#10;&#10;read_sql()  读取数据库"/>
              <outline text="数据浏览" _note="&#10;df.info()  看各列数据类型&#10;&#10;df.head()  默认显示前五行数据&#10;&#10;df.tail()   默认显示最后五行数据&#10;&#10;"/>
              <outline text="查看是否有重复数据" _note="&#10;使用.unique()返回唯一值。positionId是表头之一。&#10;In [148]: df.positionId.unique()&#10;Out[148]: &#10;array([2537336, 2427485, 2511252, ..., 1832950, 2582349, 1757974],&#10; dtype=int64)&#10;&#10;# 使用len查出有5031个唯一数据数据&#10;In [149]: len(df.positionId.unique())&#10;Out[149]: 5031&#10;&#10;# 通过df.info()查出有6876个字段，唯一值有5031个，说明数据有重复。"/>
              <outline text="清洗数据" _note="&#10;# .drop_duplicates中的subset选择以哪列为基准去重，keep是重复数据保留哪一行，first是保留第一行，last是保留最后一行&#10;&#10;# 使用.duplicated函数，功能类似，但它返回的是布尔值。&#10;&#10;df_duplicates = df.drop_duplicates(subset = &apos;positionId&apos;, keep = &apos;first&apos;)&#10;&#10;&#10;# 显示前5行数据&#10; df_duplicates.head(5)&#10;&#10;# 查看清洗后的数据情况&#10; df_duplicates.info()&#10;&#10;"/>
              <outline text="整理数据" _note="&#10;这个实例是salary一列需要处理，比如有“7k以上”、“7k-15K”等数据，所以要拆开，分别取salary的上限和下限">
                <outline text="取数据下限" _note="&#10;自定义函数，如果‘-’不在最后，则读取position-1前的值；其余的读取k变成大写字母后的前面的值&#10;&#10;def cut_word(word):&#10;      position = word.find(&apos;-&apos;)&#10;     if position != -1:&#10;      bottomSalary = word[:position-1]&#10;    else:&#10;         bottomSalary = word[:word.upper().find(&apos;K&apos;)]&#10;    return bottomSalary&#10;&#10;# 调用函数，取下限&#10;df_duplicates[&apos;bottomSalary&apos;]=df_duplicates.salary.apply(cut_word)&#10;&#10;# 改变数据类型为整数型&#10;df_duplicates.bottomSalary.astype(int)"/>
              </outline>
            </outline>
          </outline>
        </outline>
        <outline text="第四周：数据分析之处理（暂缺）" _note="&#10;第3次开课（开课时间： 2018年10月30日 ~ 2018年12月04日）有，目前无法查到。" collapsed="true">
          <outline text="单元9：数据的清洗和规约"/>
          <outline text="单元10：时间序列的处理和展示"/>
          <outline text="单元11：商品数据时序分析图"/>
          <outline text="单元12：股票数据的趋势分析曲线 #实例" _note="&#10;第2次开课（开课时间： 2017年10月24日 ~ 2017年11月25日）有该内容，目前无法查到。"/>
        </outline>
        <outline text="实例清单">
          <outline text="实例1：Pandas如何存取文件？" collapsed="true">
            <outline text="读取" collapsed="true">
              <outline text="pd.read_csv ()读取 csv 文件" _note="&#10;EG= pd.read_csv(EnterGoods,encoding=&apos;gbk&apos;)"/>
              <outline text="pd.read_json() 读取 json 文件"/>
              <outline text="pd.read_html ()读取 html 文件"/>
              <outline text="pd.read_excel ()读取 excel 文件"/>
            </outline>
            <outline text="存储" collapsed="true">
              <outline text="df.to_csv() 写入到 csv 文件"/>
              <outline text="df.to_json() 写入到 json 文件"/>
              <outline text="df.to_html ()写入到 html 文件"/>
              <outline text="df.to_excel ()写入到 excel 文件" _note="&#10;必须事先 pip install xlwt&#10;&#10;df.to_excel(&apos;路径/文件名&apos;)"/>
            </outline>
          </outline>
          <outline text="实例2：寻找某个字段的行？" _note="&#10;寻找所有字段为‘丝瓜’的行数&#10;&#10;criteria = (SortEg[&apos;货物/农机具名称&apos;]==&apos;丝瓜&apos;)&#10;&#10;SortEg[criteria].head()&#10;&#10;&#10;Out[62]: &#10;           入口站                 货物/农机具名称      总重量  总次数&#10;266  山东省山东东明北站       丝瓜               943.39   96&#10;188    河南省河南滑县               丝瓜                1210.17  161"/>
          <outline text="实例3：去掉numpy中重复项 np.unique()" _note="&#10;&#10;In [1]: import numpy as np&#10;&#10;&#10;In [2]: import pandas as pd&#10;&#10; # pandas读取数据&#10;&#10;In [3]: EnterGoods= pd.read_csv(&apos;d:/ex/EnterGoods.csv&apos;,encoding=&apos;gbk&apos;)&#10; &#10;&#10;# 转边为numpy&#10;&#10;In [4]: GoodsData=np.array(EnterGoods[&apos;货物/农机具名称&apos;])  &#10;&#10;&#10;# 通过np.unique去掉重复项&#10;&#10;In [11]: GoodsUniques=np.unique(GoodsData)&#10;&#10;&#10;&#10;"/>
          <outline text="实例4：Pandas如何合并一列中相同的字符，并计算出字符相应列的和？"/>
          <outline text="实例5：如何计算一行程序的运行时间？" _note="&#10;In [1]: import numpy as np&#10;&#10;&#10;In [2]: my_arr = np.arange(1000000)&#10;&#10;&#10;In [3]: my_list = list(range(1000000))&#10;&#10;# 在程序前面加上 %time&#10;In [4]: %time for _ in range(10):my_arr = my_arr * 2    &#10;Wall time: 24 ms&#10;&#10;&#10;In [5]: %time for _ in range(10):my_list2 = [x *2 for x in my_list]&#10;Wall time: 787 ms&#10;&#10;"/>
        </outline>
      </outline>
      <outline text="Python办公自动化">
        <outline text="word" collapsed="true">
          <outline text="引入docx" _note="&#10;import docx&#10;&#10;"/>
        </outline>
      </outline>
      <outline text="实例练习" collapsed="true">
        <outline text="股票提醒系统" _note="&#10;[股票提醒系统 - 简书](https://www.jianshu.com/p/5d792c32bf63)&#10;&#10;[allbluelai/share](https://github.com/allbluelai/share)"/>
      </outline>
      <outline text="问题清单">
        <outline text="调用函数带括号和不带括号的区别" _note="&#10;不带括号时，调用的是这个函数本身，是整个函数体，不须等函数执行完成。&#10;&#10;&#10;带括号时，调用的是函数执行的结果，须等函数执行完成的结果。&#10;&#10;```&#10;In [111]: def cut_word(word):&#10;     ...: position = word.find(&quot;-&quot;)&#10;     ...: bottomSalary = word[:position-1]&#10;     ...: return bottomSalary&#10;     ...: &#10;&#10;&#10;In [112]: cut_word(&quot;7k-10k&quot;)&#10;Out[112]: &apos;7&apos;&#10;&#10;In [122]: import pandas as pd&#10;&#10;&#10;In [123]: ls=pd.Series([&quot;3k-4k&quot;,&quot;5k-6k&quot;])&#10;&#10;&#10;In [124]: ls.apply(cut_word)&#10;Out[124]: &#10;0 3&#10;1 5&#10;dtype: object&#10;&#10;&#10;&#10;```&#10;&#10;&#10;&#10;&#10;&#10;[Python调用函数带括号和不带括号的区别 - 许爽歪歪 - 博客园](https://www.cnblogs.com/xushuangwaiwai/p/10730494.html)"/>
      </outline>
    </outline>
  </body>
</opml>
